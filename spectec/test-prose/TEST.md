# Preview

```sh
$ for v in 1 2 3; do ( \
>   echo "Generating prose for Wasm $v.0..." && \
>   cd ../spec/wasm-$v.0 && \
>   ../../src/exe-watsup/main.exe *.watsup -v -l --prose-rst && \
>   ../../src/exe-watsup/main.exe *.watsup -v -l --prose \
> ) done
Generating prose for Wasm 1.0...
watsup 0.4 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...



The limits :math:`({}[~n~..~m~])` is valid with :math:`k` if:


  * :math:`n` is less than or equal to :math:`m`.

  * :math:`m` is less than or equal to :math:`k`.




The function type :math:`{t_1^\ast}~\rightarrow~{t_2^?}` is valid.




The global type :math:`({\mathsf{mut}^?}, t)` is valid.




The table type :math:`{\mathit{limits}}` is valid if:


  * The table type :math:`{\mathit{limits}}` is valid with :math:`{2^{32}} - 1`.




The memory type :math:`{\mathit{limits}}` is valid if:


  * The memory type :math:`{\mathit{limits}}` is valid with :math:`{2^{16}}`.




The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid if:


  * Either:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{functype}})`.

    * The function type :math:`{\mathit{functype}}` is valid.

  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~{\mathit{globaltype}})`.

    * The global type :math:`{\mathit{globaltype}}` is valid.
  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~{\mathit{tabletype}})`.

    * The table type :math:`{\mathit{tabletype}}` is valid.
  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~{\mathit{memtype}})`.

    * The memory type :math:`{\mathit{memtype}}` is valid.




The external type :math:`(\mathsf{func}~{\mathit{functype}})` is valid if:


  * The function type :math:`{\mathit{functype}}` is valid.




The external type :math:`(\mathsf{global}~{\mathit{globaltype}})` is valid if:


  * The global type :math:`{\mathit{globaltype}}` is valid.




The external type :math:`(\mathsf{table}~{\mathit{tabletype}})` is valid if:


  * The table type :math:`{\mathit{tabletype}}` is valid.




The external type :math:`(\mathsf{mem}~{\mathit{memtype}})` is valid if:


  * The memory type :math:`{\mathit{memtype}}` is valid.




The limits :math:`({}[~n_{11}~..~n_{12}~])` matches the limits :math:`({}[~n_{21}~..~n_{22}~])` if:


  * :math:`n_{11}` is greater than or equal to :math:`n_{21}`.

  * :math:`n_{12}` is less than or equal to :math:`n_{22}`.




The function type :math:`{\mathit{ft}}` matches itself.




The global type :math:`{\mathit{gt}}` matches itself.




The table type :math:`{\mathit{lim}}_1` matches the table type :math:`{\mathit{lim}}_2` if:


  * The table type :math:`{\mathit{lim}}_1` matches the table type :math:`{\mathit{lim}}_2`.




The memory type :math:`{\mathit{lim}}_1` matches the memory type :math:`{\mathit{lim}}_2` if:


  * The memory type :math:`{\mathit{lim}}_1` matches the memory type :math:`{\mathit{lim}}_2`.




The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` matches the external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` if:


  * Either:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{ft}}_1)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{func}~{\mathit{ft}}_2)`.

    * The function type :math:`{\mathit{ft}}_1` matches the function type :math:`{\mathit{ft}}_2`.

  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~{\mathit{gt}}_1)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{global}~{\mathit{gt}}_2)`.

    * The global type :math:`{\mathit{gt}}_1` matches the global type :math:`{\mathit{gt}}_2`.
  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~{\mathit{tt}}_1)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{table}~{\mathit{tt}}_2)`.

    * The table type :math:`{\mathit{tt}}_1` matches the table type :math:`{\mathit{tt}}_2`.
  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~{\mathit{mt}}_1)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{mem}~{\mathit{mt}}_2)`.

    * The memory type :math:`{\mathit{mt}}_1` matches the memory type :math:`{\mathit{mt}}_2`.




The external type :math:`(\mathsf{func}~{\mathit{ft}}_1)` matches the external type :math:`(\mathsf{func}~{\mathit{ft}}_2)` if:


  * The function type :math:`{\mathit{ft}}_1` matches the function type :math:`{\mathit{ft}}_2`.




The external type :math:`(\mathsf{global}~{\mathit{gt}}_1)` matches the external type :math:`(\mathsf{global}~{\mathit{gt}}_2)` if:


  * The global type :math:`{\mathit{gt}}_1` matches the global type :math:`{\mathit{gt}}_2`.




The external type :math:`(\mathsf{table}~{\mathit{tt}}_1)` matches the external type :math:`(\mathsf{table}~{\mathit{tt}}_2)` if:


  * The table type :math:`{\mathit{tt}}_1` matches the table type :math:`{\mathit{tt}}_2`.




The external type :math:`(\mathsf{mem}~{\mathit{mt}}_1)` matches the external type :math:`(\mathsf{mem}~{\mathit{mt}}_2)` if:


  * The memory type :math:`{\mathit{mt}}_1` matches the memory type :math:`{\mathit{mt}}_2`.




The instruction :math:`\mathsf{nop}` is valid with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction :math:`\mathsf{unreachable}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`\mathsf{drop}` is valid with the function type :math:`t~\rightarrow~\epsilon`.




The instruction :math:`\mathsf{select}` is valid with the function type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t`.




The instruction :math:`(\mathsf{block}~{t^?}~{{\mathit{instr}}^\ast})` is valid with the function type :math:`\epsilon~\rightarrow~{t^?}` if:


  * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t^?}` prepended to the field :math:`\mathsf{labels}`.

  * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`\epsilon~\rightarrow~{t^?}`.




The instruction :math:`(\mathsf{loop}~{t^?}~{{\mathit{instr}}^\ast})` is valid with the function type :math:`\epsilon~\rightarrow~{t^?}` if:


  * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction :math:`(\mathsf{if}~{t^?}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^?}` if:


  * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t^?}` prepended to the field :math:`\mathsf{labels}`.

  * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_1^\ast}` is valid with the function type :math:`\epsilon~\rightarrow~{t^?}`.

  * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`\epsilon~\rightarrow~{t^?}`.




The instruction :math:`(\mathsf{br}~l)` is valid with the function type :math:`{t_1^\ast}~{t^?}~\rightarrow~{t_2^\ast}` if:


  * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

  * The result type :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^?}`.




The instruction :math:`(\mathsf{br\_if}~l)` is valid with the function type :math:`{t^?}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^?}` if:


  * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

  * The result type :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^?}`.




The instruction :math:`(\mathsf{br\_table}~{l^\ast}~{l'})` is valid with the function type :math:`{t_1^\ast}~{t^?}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


  * The result type :math:`C{.}\mathsf{labels}{}[{l'}]` exists.

  * The result type :math:`{t^?}` is equal to :math:`C{.}\mathsf{labels}{}[{l'}]`.

  * For all :math:`l` in :math:`{l^\ast}`:

    * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

  * For all :math:`l` in :math:`{l^\ast}`:

    * The result type :math:`{t^?}` is equal to :math:`C{.}\mathsf{labels}{}[l]`.




The instruction :math:`(\mathsf{call}~x)` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^?}` if:


  * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

  * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{t_1^\ast}~\rightarrow~{t_2^?}`.




The instruction :math:`(\mathsf{call\_indirect}~x)` is valid with the function type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^?}` if:


  * The function type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The function type :math:`C{.}\mathsf{types}{}[x]` is equal to :math:`{t_1^\ast}~\rightarrow~{t_2^?}`.




The instruction :math:`\mathsf{return}` is valid with the function type :math:`{t_1^\ast}~{t^?}~\rightarrow~{t_2^\ast}` if:


  * The result type :math:`C{.}\mathsf{return}` is equal to :math:`{t^?}`.




The instruction :math:`(t{.}\mathsf{const}~c_t)` is valid with the function type :math:`\epsilon~\rightarrow~t`.




The instruction :math:`(t {.} {\mathit{unop}}_t)` is valid with the function type :math:`t~\rightarrow~t`.




The instruction :math:`(t {.} {\mathit{binop}}_t)` is valid with the function type :math:`t~t~\rightarrow~t`.




The instruction :math:`(t {.} {\mathit{testop}}_t)` is valid with the function type :math:`t~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(t {.} {\mathit{relop}}_t)` is valid with the function type :math:`t~t~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{nt}}_1 {.} {{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is valid with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1` if:


  * Either:

    * :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{reinterpret}`.

    * :math:`{|{\mathit{nt}}_1|}` is equal to :math:`{|{\mathit{nt}}_2|}`.

  * Or:

    * :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{cvtop}}`.




The instruction :math:`(\mathsf{local{.}get}~x)` is valid with the function type :math:`\epsilon~\rightarrow~t` if:


  * The number type :math:`C{.}\mathsf{locals}{}[x]` exists.

  * The number type :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`t`.




The instruction :math:`(\mathsf{local{.}set}~x)` is valid with the function type :math:`t~\rightarrow~\epsilon` if:


  * The number type :math:`C{.}\mathsf{locals}{}[x]` exists.

  * The number type :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`t`.




The instruction :math:`(\mathsf{local{.}tee}~x)` is valid with the function type :math:`t~\rightarrow~t` if:


  * The number type :math:`C{.}\mathsf{locals}{}[x]` exists.

  * The number type :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`t`.




The instruction :math:`(\mathsf{global{.}get}~x)` is valid with the function type :math:`\epsilon~\rightarrow~t` if:


  * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

  * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`({\mathit{mut}}, t)`.




The instruction :math:`(\mathsf{global{.}set}~x)` is valid with the function type :math:`t~\rightarrow~\epsilon` if:


  * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

  * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`(\mathsf{mut}, t)`.




The instruction :math:`\mathsf{memory{.}size}` is valid with the function type :math:`\epsilon~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.




The instruction :math:`\mathsf{memory{.}grow}` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.




The instruction :math:`({t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{load}}{{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~t_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * Either:

    * The number type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`t`.

    * :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is absent.

    * The number type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is equal to :math:`t`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|t|} / 8`.

  * Or:

    * The number type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{n}`.

    * :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`(M, {\mathit{sx}})`.

    * The number type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is equal to :math:`{\mathsf{i}}{n}`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{store}}{{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}~\rightarrow~\epsilon` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * Either:

    * The number type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`t`.

    * The pack size :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is absent.

    * The number type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`t`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|t|} / 8`.

  * Or:

    * The number type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{n}`.

    * The pack size :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`M`.

    * The number type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathsf{i}}{n}`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({\mathit{nt}}_1 {.} {\mathsf{reinterpret}}{\mathsf{\_}}{{\mathit{nt}}_2})` is valid with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1` if:


  * :math:`{|{\mathit{nt}}_1|}` is equal to :math:`{|{\mathit{nt}}_2|}`.




The instruction :math:`({\mathit{nt}}_1 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is valid with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1`.




The instruction :math:`({t{.}\mathsf{load}}{\epsilon}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|t|} / 8`.




The instruction :math:`({{\mathsf{i}}{n}{.}\mathsf{load}}{(M, {\mathit{sx}})}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathsf{i}}{n}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({t{.}\mathsf{store}}{\epsilon}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~t~\rightarrow~\epsilon` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|t|} / 8`.




The instruction :math:`({{\mathsf{i}}{n}{.}\mathsf{store}}{M}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathsf{i}}{n}~\rightarrow~\epsilon` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is valid with the function type :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~\rightarrow~{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` if:


  * Either:

    * The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

    * The number type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

    * The number type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`\epsilon`.

  * Or:

    * The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}`.

    * The number type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{t_1^\ast}`.

    * The number type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`{t_3^\ast}`.

    * The instruction :math:`{\mathit{instr}}_1` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

    * The instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`{t_2^\ast}~\rightarrow~{t_3^\ast}`.
  * Or:

    * The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{{\mathit{instr}}^\ast}`.

    * The number type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{t^\ast}~{t_1^\ast}`.

    * The number type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`{t^\ast}~{t_2^\ast}`.

    * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction sequence :math:`\epsilon` is valid with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction sequence :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_3^\ast}` if:


  * The instruction :math:`{\mathit{instr}}_1` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * The instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`{t_2^\ast}~\rightarrow~{t_3^\ast}`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t^\ast}~{t_1^\ast}~\rightarrow~{t^\ast}~{t_2^\ast}` if:


  * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The expression :math:`{{\mathit{instr}}^\ast}` is valid with the result type :math:`{t^?}` if:


  * The expression :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`\epsilon~\rightarrow~{t^?}`.




:math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is const if:


  * Either:

    * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(t{.}\mathsf{const}~c)`.

  * Or:

    * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global{.}get}~x)`.

    * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

    * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`(\epsilon, t)`.




:math:`(t{.}\mathsf{const}~c)` is const.




:math:`(\mathsf{global{.}get}~x)` is const if:


  * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

  * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`(\epsilon, t)`.




:math:`{{\mathit{instr}}^\ast}` is const if:


  * For all :math:`{\mathit{instr}}` in :math:`{{\mathit{instr}}^\ast}`:

    * :math:`{\mathit{instr}}` is const.




The type :math:`(\mathsf{type}~{\mathit{ft}})` is valid with the function type :math:`{\mathit{ft}}` if:


  * The function type :math:`{\mathit{ft}}` is valid.




The function :math:`(\mathsf{func}~x~{(\mathsf{local}~t)^\ast}~{\mathit{expr}})` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^?}` if:


  * The function type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The function type :math:`C{.}\mathsf{types}{}[x]` is equal to :math:`{t_1^\ast}~\rightarrow~{t_2^?}`.

  * Under the context :math:`C{}[{.}\mathsf{locals} \mathrel{{=}{\oplus}} {t_1^\ast}~{t^\ast}]{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^?}]{}[{.}\mathsf{return} \mathrel{{=}{\oplus}} {t_2^?}]`, the expression :math:`{\mathit{expr}}` is valid with the result type :math:`{t_2^?}`.




The global :math:`(\mathsf{global}~{\mathit{gt}}~{\mathit{expr}})` is valid with the global type :math:`{\mathit{gt}}` if:


  * The global type :math:`{\mathit{gt}}` is valid.

  * The global type :math:`{\mathit{gt}}` is equal to :math:`({\mathit{mut}}, t)`.

  * The expression :math:`{\mathit{expr}}` is valid with the number type :math:`t`.

  * :math:`{\mathit{expr}}` is const.




The table :math:`(\mathsf{table}~{\mathit{tt}})` is valid with the table type :math:`{\mathit{tt}}` if:


  * The table type :math:`{\mathit{tt}}` is valid.




The memory :math:`(\mathsf{memory}~{\mathit{mt}})` is valid with the memory type :math:`{\mathit{mt}}` if:


  * The memory type :math:`{\mathit{mt}}` is valid.




The table segment :math:`(\mathsf{elem}~{\mathit{expr}}~{x^\ast})` is valid if:


  * The table type :math:`C{.}\mathsf{tables}{}[0]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[0]` is equal to :math:`{\mathit{lim}}`.

  * The expression :math:`{\mathit{expr}}` is valid with the number type :math:`\mathsf{i{\scriptstyle 32}}`.

  * :math:`{\mathit{expr}}` is const.

  * :math:`{|{\mathit{x*}}|}` is equal to :math:`{|{\mathit{ft*}}|}`.

  * For all :math:`x` in :math:`{x^\ast}`:

    * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

  * For all :math:`{\mathit{ft}}` in :math:`{{\mathit{ft}}^\ast}` and :math:`x` in :math:`{x^\ast}`:

    * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{\mathit{ft}}`.




The memory segment :math:`(\mathsf{data}~{\mathit{expr}}~{b^\ast})` is valid if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{lim}}`.

  * The expression :math:`{\mathit{expr}}` is valid with the number type :math:`\mathsf{i{\scriptstyle 32}}`.

  * :math:`{\mathit{expr}}` is const.




The start function :math:`(\mathsf{start}~x)` is valid if:


  * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

  * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`\epsilon~\rightarrow~\epsilon`.




The import :math:`(\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{xt}})` is valid with the external type :math:`{\mathit{xt}}` if:


  * The external type :math:`{\mathit{xt}}` is valid.




The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


  * Either:

    * The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~x)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{ft}})`.

    * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

    * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{\mathit{ft}}`.

  * Or:

    * The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~x)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~{\mathit{gt}})`.

    * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

    * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`{\mathit{gt}}`.
  * Or:

    * The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~x)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~{\mathit{tt}})`.

    * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

    * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`{\mathit{tt}}`.
  * Or:

    * The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~x)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~{\mathit{mt}})`.

    * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

    * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`{\mathit{mt}}`.




The external index :math:`(\mathsf{func}~x)` is valid with the external type :math:`(\mathsf{func}~{\mathit{ft}})` if:


  * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

  * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{\mathit{ft}}`.




The external index :math:`(\mathsf{global}~x)` is valid with the external type :math:`(\mathsf{global}~{\mathit{gt}})` if:


  * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

  * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`{\mathit{gt}}`.




The external index :math:`(\mathsf{table}~x)` is valid with the external type :math:`(\mathsf{table}~{\mathit{tt}})` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`{\mathit{tt}}`.




The external index :math:`(\mathsf{mem}~x)` is valid with the external type :math:`(\mathsf{mem}~{\mathit{mt}})` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`{\mathit{mt}}`.




The export :math:`(\mathsf{export}~{\mathit{name}}~{\mathit{externidx}})` is valid with the external type :math:`{\mathit{xt}}` if:


  * The external index :math:`{\mathit{externidx}}` is valid with the external type :math:`{\mathit{xt}}`.




The module :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` is valid if:


  * :math:`{|{\mathit{type*}}|}` is equal to :math:`{|{\mathit{ft'*}}|}`.

  * For all :math:`{\mathit{ft}'}` in :math:`{{\mathit{ft}'}^\ast}` and :math:`{\mathit{type}}` in :math:`{{\mathit{type}}^\ast}`:

    * The type :math:`{\mathit{type}}` is valid with the function type :math:`{\mathit{ft}'}`.

  * :math:`{|{\mathit{ixt*}}|}` is equal to :math:`{|{\mathit{import*}}|}`.

  * For all :math:`{\mathit{import}}` in :math:`{{\mathit{import}}^\ast}` and :math:`{\mathit{ixt}}` in :math:`{{\mathit{ixt}}^\ast}`:

    * Under the context :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon,\; \mathsf{return}~\epsilon \}\end{array}`, the import :math:`{\mathit{import}}` is valid with the external type :math:`{\mathit{ixt}}`.

  * :math:`{|{\mathit{gt*}}|}` is equal to :math:`{|{\mathit{global*}}|}`.

  * For all :math:`{\mathit{global}}` in :math:`{{\mathit{global}}^\ast}` and :math:`{\mathit{gt}}` in :math:`{{\mathit{gt}}^\ast}`:

    * Under the context :math:`{C'}`, the global :math:`{\mathit{global}}` is valid with the global type :math:`{\mathit{gt}}`.

  * :math:`{|{\mathit{func*}}|}` is equal to :math:`{|{\mathit{ft*}}|}`.

  * For all :math:`{\mathit{ft}}` in :math:`{{\mathit{ft}}^\ast}` and :math:`{\mathit{func}}` in :math:`{{\mathit{func}}^\ast}`:

    * The function :math:`{\mathit{func}}` is valid with the function type :math:`{\mathit{ft}}`.

  * :math:`{|{\mathit{tt*}}|}` is equal to :math:`{|{\mathit{table*}}|}`.

  * For all :math:`{\mathit{table}}` in :math:`{{\mathit{table}}^\ast}` and :math:`{\mathit{tt}}` in :math:`{{\mathit{tt}}^\ast}`:

    * The table :math:`{\mathit{table}}` is valid with the table type :math:`{\mathit{tt}}`.

  * :math:`{|{\mathit{mt*}}|}` is equal to :math:`{|{\mathit{mem*}}|}`.

  * For all :math:`{\mathit{mem}}` in :math:`{{\mathit{mem}}^\ast}` and :math:`{\mathit{mt}}` in :math:`{{\mathit{mt}}^\ast}`:

    * The memory :math:`{\mathit{mem}}` is valid with the memory type :math:`{\mathit{mt}}`.

  * For all :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}`:

    * The table segment :math:`{\mathit{elem}}` is valid.

  * For all :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}`:

    * The memory segment :math:`{\mathit{data}}` is valid.

  * If :math:`{\mathit{start}}` is defined, then:

    * The start function :math:`{\mathit{start}}` is valid.

  * :math:`{|{\mathit{xt*}}|}` is equal to :math:`{|{\mathit{export*}}|}`.

  * For all :math:`{\mathit{export}}` in :math:`{{\mathit{export}}^\ast}` and :math:`{\mathit{xt}}` in :math:`{{\mathit{xt}}^\ast}`:

    * The export :math:`{\mathit{export}}` is valid with the external type :math:`{\mathit{xt}}`.

  * :math:`{|{{\mathit{tt}}^\ast}|}` is less than or equal to :math:`1`.

  * :math:`{|{{\mathit{mt}}^\ast}|}` is less than or equal to :math:`1`.

  * The context :math:`C` is equal to :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~{{\mathit{ift}}^\ast}~{{\mathit{ft}}^\ast},\; \mathsf{globals}~{{\mathit{igt}}^\ast}~{{\mathit{gt}}^\ast},\; \mathsf{tables}~{{\mathit{itt}}^\ast}~{{\mathit{tt}}^\ast},\; \mathsf{mems}~{{\mathit{imt}}^\ast}~{{\mathit{mt}}^\ast},\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon,\; \mathsf{return}~\epsilon \}\end{array}`.

  * The context :math:`{C'}` is equal to :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~{{\mathit{ift}}^\ast}~{{\mathit{ft}}^\ast},\; \mathsf{globals}~{{\mathit{igt}}^\ast},\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon,\; \mathsf{return}~\epsilon \}\end{array}`.

  * The function type sequence :math:`{{\mathit{ift}}^\ast}` is equal to :math:`{\mathrm{funcs}}({{\mathit{ixt}}^\ast})`.

  * The global type sequence :math:`{{\mathit{igt}}^\ast}` is equal to :math:`{\mathrm{globals}}({{\mathit{ixt}}^\ast})`.

  * The table type sequence :math:`{{\mathit{itt}}^\ast}` is equal to :math:`{\mathrm{tables}}({{\mathit{ixt}}^\ast})`.

  * The memory type sequence :math:`{{\mathit{imt}}^\ast}` is equal to :math:`{\mathrm{mems}}({{\mathit{ixt}}^\ast})`.


:math:`\mathsf{unreachable}`
............................


1. Trap.


:math:`\mathsf{nop}`
....................


1. Do nothing.


:math:`\mathsf{drop}`
.....................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Do nothing.


:math:`\mathsf{select}`
.......................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_2` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_1` from the stack.

#. If :math:`c \neq 0`, then:

  a. Push the value :math:`{\mathit{val}}_1` to the stack.

#. Else:

  a. Push the value :math:`{\mathit{val}}_2` to the stack.


:math:`\mathsf{if}~{t^?}~{{\mathit{instr}}_1^\ast}~{{\mathit{instr}}_2^\ast}`
.............................................................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

  a. Execute the instruction :math:`(\mathsf{block}~{t^?}~{{\mathit{instr}}_1^\ast})`.

#. Else:

  a. Execute the instruction :math:`(\mathsf{block}~{t^?}~{{\mathit{instr}}_2^\ast})`.


:math:`\mathsf{label}`
......................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Pop the current :math:`\mathsf{label}` context from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`\mathsf{br}~n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`
.............................................................


1. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Let :math:`({{\mathsf{label}}_{n}}{\{}~{{\mathit{instr}'}^\ast}~\})` be the current :math:`\mathsf{label}` context.

#. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 0`, then:

  a. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

  #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

  #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

  #. Pop the current :math:`\mathsf{label}` context from the stack.

  #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

  #. Execute the instruction :math:`{{\mathit{instr}'}^\ast}`.

#. Else:

  a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

  #. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}} \geq 1`, then:

    1) Let :math:`l` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}} - 1`.

    #) Pop the current :math:`\mathsf{label}` context from the stack.

    #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

    #) Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{br\_if}~l`
.........................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

  a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

  a. Do nothing.


:math:`\mathsf{br\_table}~{l^\ast}~{l'}`
........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i < {|{l^\ast}|}`, then:

  a. Execute the instruction :math:`(\mathsf{br}~{l^\ast}{}[i])`.

#. Else:

  a. Execute the instruction :math:`(\mathsf{br}~{l'})`.


:math:`\mathsf{frame}`
......................


1. Let :math:`({{\mathsf{frame}}_{n}}{\{}~f~\})` be the current :math:`\mathsf{frame}` context.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{frame}`.

#. Pop the current :math:`\mathsf{frame}` context from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.


:math:`\mathsf{return}`
.......................


1. If the first non-value entry of the stack is a :math:`\mathsf{frame}`, then:

  a. Let :math:`({{\mathsf{frame}}_{n}}{\{}~f~\})` be the current :math:`\mathsf{frame}` context.

  #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

  #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

  #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

  #. Pop the current :math:`\mathsf{frame}` context from the stack.

  #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Else if the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

  a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

  #. Pop the current :math:`\mathsf{label}` context from the stack.

  #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Execute the instruction :math:`\mathsf{return}`.


:math:`t {.} {\mathit{unop}}`
.............................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`t` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{unop}}}{{}_{t}}{(c_1)}|} \leq 0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{unop}}}{{}_{t}}{(c_1)}`.

#. Push the value :math:`(t{.}\mathsf{const}~c)` to the stack.


:math:`t {.} {\mathit{binop}}`
..............................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`t` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{valtype}}_0` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{binop}}}{{}_{t}}{(c_1, c_2)}|} \leq 0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{binop}}}{{}_{t}}{(c_1, c_2)}`.

#. Push the value :math:`(t{.}\mathsf{const}~c)` to the stack.


:math:`t {.} {\mathit{testop}}`
...............................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`t` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{testop}}}{{}_{t}}{(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`t {.} {\mathit{relop}}`
..............................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`t` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{valtype}}_0` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{relop}}}{{}_{t}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`t_2 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{t_1}`
....................................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`t_1` is on the top of the stack.

#. Pop the value :math:`({\mathit{valtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{cvtop}}}{{}_{t_1, t_2}}{(c_1)}|} \leq 0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{cvtop}}}{{}_{t_1, t_2}}{(c_1)}`.

#. Push the value :math:`(t_2{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{local{.}tee}~x`
..............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Execute the instruction :math:`(\mathsf{local{.}set}~x)`.


:math:`\mathsf{block}~{t^?}~{{\mathit{instr}}^\ast}`
....................................................


1. Let :math:`n` be :math:`0`.

#. If :math:`{t^?}` is not defined, then:

  a. Enter :math:`{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{n}}{\{}~\epsilon~\})`.

#. Let :math:`n` be :math:`1`.

#. If :math:`{t^?} \neq \epsilon`, then:

  a. Enter :math:`{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{n}}{\{}~\epsilon~\})`.


:math:`\mathsf{loop}~{t^?}~{{\mathit{instr}}^\ast}`
...................................................


1. Enter :math:`{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{0}}{\{}~(\mathsf{loop}~{t^?}~{{\mathit{instr}}^\ast})~\})`.


:math:`\mathsf{call}~x`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Execute the instruction :math:`(\mathsf{call}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])`.


:math:`\mathsf{call\_indirect}~x`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[0]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`z{.}\mathsf{tables}{}[0]{.}\mathsf{refs}{}[i]` is not defined, then:

  a. Trap.

#. Let :math:`a` be :math:`z{.}\mathsf{tables}{}[0]{.}\mathsf{refs}{}[i]`.

#. If :math:`a \geq {|z{.}\mathsf{funcs}|}`, then:

  a. Trap.

#. If :math:`z{.}\mathsf{types}{}[x] \neq z{.}\mathsf{funcs}{}[a]{.}\mathsf{type}`, then:

  a. Trap.

#. Execute the instruction :math:`(\mathsf{call}~a)`.


:math:`\mathsf{call}~a`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{funcs}|}`.

#. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{t_1^{k}}~\rightarrow~{t_2^{n}},\; \mathsf{module}~{\mathit{mm}},\; \mathsf{code}~{\mathit{func}} \}\end{array}` be :math:`z{.}\mathsf{funcs}{}[a]`.

#. Assert: Due to validation, :math:`{\mathit{func}}` is of the case :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~x~{{\mathit{local}}_0^\ast}~{{\mathit{instr}}^\ast})` be :math:`{\mathit{func}}`.

#. Assert: Due to validation, for all :math:`{\mathit{local}}_0` in :math:`{{\mathit{local}}_0^\ast}`, :math:`{\mathit{local}}_0` is of the case :math:`\mathsf{local}`.

#. Let :math:`{(\mathsf{local}~t)^\ast}` be :math:`{{\mathit{local}}_0^\ast}`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~{{\mathit{val}}^{k}}~{{{\mathrm{default}}}_{t}^\ast},\; \mathsf{module}~{\mathit{mm}} \}\end{array}`.

#. Push the evaluation context :math:`({{\mathsf{frame}}_{n}}{\{}~f~\})` to the stack.

#. Enter :math:`{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{n}}{\{}~\epsilon~\})`.


:math:`\mathsf{local{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{locals}{}[x]` to the stack.


:math:`\mathsf{global{.}get}~x`
...............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{globals}{}[x]{.}\mathsf{value}` to the stack.


:math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{load}}{{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}}~{\mathit{ao}}`
......................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Let :math:`t` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|t|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

    1) Trap.

  #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{t}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|t|} / 8]`.

  #. Push the value :math:`(t{.}\mathsf{const}~c)` to the stack.

#. If the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. If :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

    1) Let :math:`{\mathit{loadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}`.

    #) Let :math:`(n, {\mathit{sx}})` be :math:`{\mathit{loadop\_{\scriptstyle 0}}}`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      a) Trap.

  #. Let :math:`{\mathsf{i}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

    1) Let :math:`{\mathit{loadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}`.

    #) Let :math:`(n, {\mathit{sx}})` be :math:`{\mathit{loadop\_{\scriptstyle 0}}}`.

    #) Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]`.

    #) Push the value :math:`({\mathsf{i}}{n}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{n, {|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{(c)})` to the stack.


:math:`\mathsf{memory{.}size}`
..............................


1. Let :math:`z` be the current state.

#. Let :math:`n \cdot 64 \cdot {\mathrm{Ki}}` be :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{local{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{locals}{}[x] = {\mathit{val}}]`.


:math:`\mathsf{global{.}set}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = {\mathit{val}}]`.


:math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{store}}{{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~{\mathit{ao}}`
.............................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is on the top of the stack.

#. Pop the value :math:`(t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Let :math:`t` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|t|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}` and :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = t` and :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Trap.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = t` and :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{t}(c)`.

  #. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|t|} / 8] = {b^\ast}]`.

#. If the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = {\mathsf{i}}{n}` and :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

    1) Let :math:`n` be :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      a) Trap.

    #) Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}({{\mathrm{wrap}}}_{{|{\mathsf{i}}{n}|}, n}(c))`.

    #) Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8] = {b^\ast}]`.


:math:`\mathsf{memory{.}grow}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Either:

  a. Let :math:`{\mathit{mi}}` be :math:`{\mathrm{growmemory}}(z{.}\mathsf{mems}{}[0], n)`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|} / 64 \, {\mathrm{Ki}})` to the stack.

  #. Perform :math:`z{}[{.}\mathsf{mems}{}[0] = {\mathit{mi}}]`.

#. Or:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{32}^{{-1}}}}{({-1})})` to the stack.


:math:`{\mathrm{Ki}}`
.....................


1. Return :math:`1024`.


:math:`{\mathrm{min}}(i, j)`
............................


1. If :math:`i \leq j`, then:

  a. Return :math:`i`.

#. Return :math:`j`.


:math:`{\mathrm{sum}}({n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................


1. If :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`0`.

#. Let :math:`n~{{n'}^\ast}` be :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`n + {\mathrm{sum}}({{n'}^\ast})`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`
........................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} = 1`.

#. Let :math:`w` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`w`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`
.....................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Return :math:`\epsilon`.

#. Let :math:`w` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

#. Return :math:`w`.


:math:`{\mathrm{concat}}({X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
...........................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{w^\ast}~{{{w'}^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{w^\ast}~{\mathrm{concat}}({{{w'}^\ast}^\ast})`.


:math:`{\mathrm{signif}}(N_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
....................................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 32`, then:

  a. Return :math:`23`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 64`.

#. Return :math:`52`.


:math:`{\mathrm{expon}}(N_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
...................................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 32`, then:

  a. Return :math:`8`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 64`.

#. Return :math:`11`.


:math:`M`
.........


1. Return :math:`{\mathrm{signif}}(N)`.


:math:`E`
.........


1. Return :math:`{\mathrm{expon}}(N)`.


:math:`{+0}`
............


1. Return :math:`({+((0 + 0 \cdot {2^{{-M}}}) \cdot {2^{e}})})`.


:math:`{+1}`
............


1. Return :math:`({+((1 + 1 \cdot {2^{{-M}}}) \cdot {2^{0}})})`.


:math:`{{\mathrm{canon}}}_{N}`
..............................


1. Return :math:`{2^{{\mathrm{signif}}(N) - 1}}`.


:math:`{|t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}|}`
.....................................................


1. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 32}}`, then:

  a. Return :math:`32`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 64}}`, then:

  a. Return :math:`64`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 32}}`, then:

  a. Return :math:`32`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 64}}`, then:

  a. Return :math:`64`.


:math:`{\mathrm{funcs}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
......................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{ft}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{ft}}~{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{gt}}~{\mathrm{globals}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{tt}}~{\mathrm{tables}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{mt}}~{\mathrm{mems}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xt}}^\ast})`.






1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{align}~0,\; \mathsf{offset}~0 \}\end{array}`.


:math:`{{\mathrm{signed}}}_{N}(i)`
..................................


1. If :math:`i < {2^{N - 1}}`, then:

  a. Return :math:`i`.

#. Assert: Due to validation, :math:`{2^{N - 1}} \leq i`.

#. Assert: Due to validation, :math:`i < {2^{N}}`.

#. Return :math:`i - {2^{N}}`.


:math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{(i)}`
...............................................


1. Let :math:`j` be the result for which :math:`{{\mathrm{signed}}}_{N}(j)` :math:`=` :math:`i`.

#. Return :math:`j`.


:math:`{{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{(c_{\mathit{u{\kern-0.1em\scriptstyle 1}}})}`
..............................................................................................................................................................


1. If the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{clz}`, then:

    1) Return :math:`{{\mathrm{iclz}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}})`.

  #. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ctz}`, then:

    1) Return :math:`{{\mathrm{ictz}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}})`.

  #. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{popcnt}`, then:

    1) Return :math:`{{\mathrm{ipopcnt}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}})`.

#. Assert: Due to validation, the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{abs}`, then:

  a. Return :math:`{{\mathrm{fabs}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{neg}`, then:

  a. Return :math:`{{\mathrm{fneg}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sqrt}`, then:

  a. Return :math:`{{\mathrm{fsqrt}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ceil}`, then:

  a. Return :math:`{{\mathrm{fceil}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{floor}`, then:

  a. Return :math:`{{\mathrm{ffloor}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{trunc}`, then:

  a. Return :math:`{{\mathrm{ftrunc}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.

#. Assert: Due to validation, :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{nearest}`.

#. Return :math:`{{\mathrm{fnearest}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}})`.


:math:`{{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{(c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, c_{\mathit{u{\kern-0.1em\scriptstyle 2}}})}`
..........................................................................................................................................................................................................


1. If the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

    1) Return :math:`{{\mathrm{iadd}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

    1) Return :math:`{{\mathrm{isub}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

    1) Return :math:`{{\mathrm{imul}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{div}`, then:

    1) Let :math:`({\mathsf{div}}{{\mathit{sx}}})` be :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{idiv}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{rem}`, then:

    1) Let :math:`({\mathsf{rem}}{{\mathit{sx}}})` be :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{irem}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{and}`, then:

    1) Return :math:`{{\mathrm{iand}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{or}`, then:

    1) Return :math:`{{\mathrm{ior}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{xor}`, then:

    1) Return :math:`{{\mathrm{ixor}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{shl}`, then:

    1) Return :math:`{{\mathrm{ishl}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{shr}`, then:

    1) Let :math:`({\mathsf{shr}}{{\mathit{sx}}})` be :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{ishr}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{rotl}`, then:

    1) Return :math:`{{\mathrm{irotl}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{rotr}`, then:

    1) Return :math:`{{\mathrm{irotr}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. Assert: Due to validation, the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_2` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

  a. Return :math:`{{\mathrm{fadd}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

  a. Return :math:`{{\mathrm{fsub}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

  a. Return :math:`{{\mathrm{fmul}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{div}`, then:

  a. Return :math:`{{\mathrm{fdiv}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{min}`, then:

  a. Return :math:`{{\mathrm{fmin}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{max}`, then:

  a. Return :math:`{{\mathrm{fmax}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{copysign}`.

#. Return :math:`{{\mathrm{fcopysign}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.


:math:`{\mathsf{eqz}}{{}_{{\mathsf{i}}{n}}}{({\mathit{iN}})}`
.............................................................


1. Return :math:`{{\mathrm{ieqz}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}})`.


:math:`{{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{(c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, c_{\mathit{u{\kern-0.1em\scriptstyle 2}}})}`
..........................................................................................................................................................................................................


1. If the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

    1) Return :math:`{{\mathrm{ieq}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

    1) Return :math:`{{\mathrm{ine}}}_{{|{\mathsf{i}}{n}|}}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{lt}`, then:

    1) Let :math:`({\mathsf{lt}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{ilt}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{gt}`, then:

    1) Let :math:`({\mathsf{gt}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{igt}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{le}`, then:

    1) Let :math:`({\mathsf{le}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{ile}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ge}`, then:

    1) Let :math:`({\mathsf{ge}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{ige}}}_{{|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

#. Assert: Due to validation, the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_2` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

  a. Return :math:`{{\mathrm{feq}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

  a. Return :math:`{{\mathrm{fne}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{lt}`, then:

  a. Return :math:`{{\mathrm{flt}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{gt}`, then:

  a. Return :math:`{{\mathrm{fgt}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{le}`, then:

  a. Return :math:`{{\mathrm{fle}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ge}`.

#. Return :math:`{{\mathrm{fge}}}_{{|{\mathsf{f}}{n}|}}({\mathit{fN}}_1, {\mathit{fN}}_2)`.


:math:`{{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}}}{(c_{\mathit{u{\kern-0.1em\scriptstyle 1}}})}`
..........................................................................................................................................................................................................


1. If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{extend}`, then:

  a. Let :math:`(\mathsf{extend}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 32}}` and :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}} = \mathsf{i{\scriptstyle 64}}`, then:

    1) Return :math:`{{{{\mathrm{extend}}}_{32, 64}^{{\mathit{sx}}}}}{({\mathit{iN}})}`.

#. Let :math:`{\mathit{iN}}` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 64}}` and :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}} = \mathsf{i{\scriptstyle 32}}` and :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{wrap}`, then:

  a. Return :math:`{{\mathrm{wrap}}}_{64, 32}({\mathit{iN}})`.

#. If the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is Inn, then:

    1) Let :math:`{\mathsf{i}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{trunc}`, then:

      a) Let :math:`(\mathsf{trunc}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{\mathit{fN}}` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{trunc}}}_{{|{\mathsf{f}}{n}|}, {|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{fN}})}`.

#. Let :math:`{\mathit{fN}}` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 32}}` and :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}} = \mathsf{f{\scriptstyle 64}}` and :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{promote}`, then:

  a. Return :math:`{{\mathrm{promote}}}_{32, 64}({\mathit{fN}})`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 64}}` and :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}} = \mathsf{f{\scriptstyle 32}}` and :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{demote}`, then:

  a. Return :math:`{{\mathrm{demote}}}_{64, 32}({\mathit{fN}})`.

#. If the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is Fnn, then:

    1) Let :math:`{\mathsf{f}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{convert}`, then:

      a) Let :math:`(\mathsf{convert}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{convert}}}_{{|{\mathsf{i}}{n}|}, {|{\mathsf{f}}{n}|}}^{{\mathit{sx}}}}}{({\mathit{iN}})}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{reinterpret}` and :math:`{|{\mathsf{i}}{n}|} = {|{\mathsf{f}}{n}|}`, then:

      a) Return :math:`{{\mathrm{reinterpret}}}_{{\mathsf{i}}{n}, {\mathsf{f}}{n}}({\mathit{iN}})`.

#. Assert: Due to validation, the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is Inn.

#. Let :math:`{\mathsf{i}}{n}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. Assert: Due to validation, :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{reinterpret}`.

#. Assert: Due to validation, :math:`{|{\mathsf{i}}{n}|} = {|{\mathsf{f}}{n}|}`.

#. Return :math:`{{\mathrm{reinterpret}}}_{{\mathsf{f}}{n}, {\mathsf{i}}{n}}({\mathit{fN}})`.


:math:`{{\mathrm{invibytes}}}_{N}({b^\ast})`
............................................


1. Let :math:`n` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(n)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`n`.


:math:`{{\mathrm{invfbytes}}}_{N}({b^\ast})`
............................................


1. Let :math:`p` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{f}}{N}}(p)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`p`.


:math:`{{\mathrm{default}}}_{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}`
........................................................................


1. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 32}}`, then:

  a. Return :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 64}}`, then:

  a. Return :math:`(\mathsf{i{\scriptstyle 64}}{.}\mathsf{const}~0)`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 32}}`, then:

  a. Return :math:`(\mathsf{f{\scriptstyle 32}}{.}\mathsf{const}~{+0})`.

#. Assert: Due to validation, :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 64}}`.

#. Return :math:`(\mathsf{f{\scriptstyle 64}}{.}\mathsf{const}~{+0})`.


:math:`{\mathrm{funcs}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
......................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xv}}^\ast})`.


:math:`z{.}\mathsf{store}`
..........................


1. Return.


:math:`z{.}\mathsf{frame}`
..........................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`f`.


:math:`z{.}\mathsf{module}{.}\mathsf{funcs}`
............................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`f{.}\mathsf{module}{.}\mathsf{funcs}`.


:math:`z{.}\mathsf{funcs}`
..........................


1. Return :math:`s{.}\mathsf{funcs}`.


:math:`z{.}\mathsf{globals}`
............................


1. Return :math:`s{.}\mathsf{globals}`.


:math:`z{.}\mathsf{tables}`
...........................


1. Return :math:`s{.}\mathsf{tables}`.


:math:`z{.}\mathsf{mems}`
.........................


1. Return :math:`s{.}\mathsf{mems}`.


:math:`z{.}\mathsf{module}`
...........................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`f{.}\mathsf{module}`.


:math:`z{.}\mathsf{types}{}[x]`
...............................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`f{.}\mathsf{module}{.}\mathsf{types}{}[x]`.


:math:`z{.}\mathsf{funcs}{}[x]`
...............................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`s{.}\mathsf{funcs}{}[f{.}\mathsf{module}{.}\mathsf{funcs}{}[x]]`.


:math:`z{.}\mathsf{globals}{}[x]`
.................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]`.


:math:`z{.}\mathsf{tables}{}[x]`
................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]`.


:math:`z{.}\mathsf{mems}{}[x]`
..............................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]`.


:math:`z{.}\mathsf{locals}{}[x]`
................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`f{.}\mathsf{locals}{}[x]`.


:math:`z{}[{.}\mathsf{locals}{}[x] = v]`
........................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`f{.}\mathsf{locals}{}[x]` with :math:`v`.


:math:`z{}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = v]`
..........................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]{.}\mathsf{value}` with :math:`v`.


:math:`z{}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = a]`
.............................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]{.}\mathsf{refs}{}[i]` with :math:`a`.


:math:`z{}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`
....................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]` with :math:`{\mathit{ti}}`.


:math:`z{}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i : j] = {b^\ast}]`
.......................................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]{.}\mathsf{bytes}{}[i : j]` with :math:`{b^\ast}`.


:math:`z{}[{.}\mathsf{mems}{}[x] = {\mathit{mi}}]`
..................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]` with :math:`{\mathit{mi}}`.


:math:`{\mathrm{growtable}}({\mathit{ti}}, n)`
..............................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({}[~i~..~j~]),\; \mathsf{refs}~{a^\ast} \}\end{array}` be :math:`{\mathit{ti}}`.

#. Let :math:`{i'}` be :math:`{|{a^\ast}|} + n`.

#. If :math:`{i'} \leq j`, then:

  a. Let :math:`{\mathit{ti}'}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({}[~{i'}~..~j~]),\; \mathsf{refs}~{a^\ast}~{\epsilon^{n}} \}\end{array}`.

  #. Return :math:`{\mathit{ti}'}`.


:math:`{\mathrm{growmemory}}({\mathit{mi}}, n)`
...............................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({}[~i~..~j~]),\; \mathsf{bytes}~{b^\ast} \}\end{array}` be :math:`{\mathit{mi}}`.

#. Let :math:`{i'}` be :math:`{|{b^\ast}|} / 64 \, {\mathrm{Ki}} + n`.

#. If :math:`{i'} \leq j`, then:

  a. Let :math:`{\mathit{mi}'}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({}[~{i'}~..~j~]),\; \mathsf{bytes}~{b^\ast}~{\mathtt{0x00}^{n \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

  #. Return :math:`{\mathit{mi}'}`.


:math:`{\mathrm{funcs}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
......................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{allocfunc}}(s, {\mathit{moduleinst}}, {\mathit{func}})`
.......................................................................


1. Assert: Due to validation, :math:`{\mathit{func}}` is of the case :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}})` be :math:`{\mathit{func}}`.

#. Let :math:`{\mathit{fi}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{moduleinst}}{.}\mathsf{types}{}[x],\; \mathsf{module}~{\mathit{moduleinst}},\; \mathsf{code}~{\mathit{func}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{funcs}|}`.

#. Append :math:`{\mathit{fi}}` to :math:`s{.}\mathsf{funcs}`.

#. Return :math:`a`.


:math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................................................


1. If :math:`{{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{func}}~{{\mathit{func}'}^\ast}` be :math:`{{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{fa}}` be :math:`{\mathrm{allocfunc}}(s, {\mathit{moduleinst}}, {\mathit{func}})`.

#. Let :math:`{{\mathit{fa}'}^\ast}` be :math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}'}^\ast})`.

#. Return :math:`{\mathit{fa}}~{{\mathit{fa}'}^\ast}`.


:math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`
........................................................................


1. Let :math:`{\mathit{gi}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{globaltype}},\; \mathsf{value}~{\mathit{val}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{globals}|}`.

#. Append :math:`{\mathit{gi}}` to :math:`s{.}\mathsf{globals}`.

#. Return :math:`a`.


:math:`{\mathrm{allocglobals}}(s, {{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
..................................................................................................................................................


1. If :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Assert: Due to validation, :math:`{v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`.

  #. Return :math:`\epsilon`.

#. Else:

  a. Let :math:`{\mathit{globaltype}}~{{\mathit{globaltype}'}^\ast}` be :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

  #. Assert: Due to validation, :math:`{|{v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

  #. Let :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}` be :math:`{v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

  #. Let :math:`{\mathit{ga}}` be :math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`.

  #. Let :math:`{{\mathit{ga}'}^\ast}` be :math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}'}^\ast}, {{\mathit{val}'}^\ast})`.

  #. Return :math:`{\mathit{ga}}~{{\mathit{ga}'}^\ast}`.


:math:`{\mathrm{alloctable}}(s, ({}[~i~..~j~]))`
................................................


1. Let :math:`{\mathit{ti}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({}[~i~..~j~]),\; \mathsf{refs}~{\epsilon^{i}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{tables}|}`.

#. Append :math:`{\mathit{ti}}` to :math:`s{.}\mathsf{tables}`.

#. Return :math:`a`.


:math:`{\mathrm{alloctables}}(s, {{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
...............................................................................................


1. If :math:`{{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{tabletype}}~{{\mathit{tabletype}'}^\ast}` be :math:`{{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{ta}}` be :math:`{\mathrm{alloctable}}(s, {\mathit{tabletype}})`.

#. Let :math:`{{\mathit{ta}'}^\ast}` be :math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}'}^\ast})`.

#. Return :math:`{\mathit{ta}}~{{\mathit{ta}'}^\ast}`.


:math:`{\mathrm{allocmem}}(s, ({}[~i~..~j~]))`
..............................................


1. Let :math:`{\mathit{mi}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({}[~i~..~j~]),\; \mathsf{bytes}~{\mathtt{0x00}^{i \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{mems}|}`.

#. Append :math:`{\mathit{mi}}` to :math:`s{.}\mathsf{mems}`.

#. Return :math:`a`.


:math:`{\mathrm{allocmems}}(s, {{\mathit{mt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.............................................................................................


1. If :math:`{{\mathit{mt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{memtype}}~{{\mathit{memtype}'}^\ast}` be :math:`{{\mathit{mt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{ma}}` be :math:`{\mathrm{allocmem}}(s, {\mathit{memtype}})`.

#. Let :math:`{{\mathit{ma}'}^\ast}` be :math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}'}^\ast})`.

#. Return :math:`{\mathit{ma}}~{{\mathit{ma}'}^\ast}`.


:math:`{\mathrm{instexport}}({{\mathit{fa}}^\ast}, {{\mathit{ga}}^\ast}, {{\mathit{ta}}^\ast}, {{\mathit{ma}}^\ast}, (\mathsf{export}~{\mathit{name}}~{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}))`
.....................................................................................................................................................................................................................


1. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{func}~{{\mathit{fa}}^\ast}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{global}~{{\mathit{ga}}^\ast}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{table}~{{\mathit{ta}}^\ast}{}[x]) \}\end{array}`.

#. Assert: Due to validation, :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{mem}`.

#. Let :math:`(\mathsf{mem}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{mem}~{{\mathit{ma}}^\ast}{}[x]) \}\end{array}`.


:math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast})`
.........................................................................................................


1. Assert: Due to validation, :math:`{\mathit{module}}` is of the case :math:`\mathsf{module}`.

#. Let :math:`(\mathsf{module}~{{\mathit{type}}_0^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^{n_{\mathit{func}}}}~{{\mathit{global}}_1^\ast}~{{\mathit{table}}_2^\ast}~{{\mathit{mem}}_3^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be :math:`{\mathit{module}}`.

#. Assert: Due to validation, for all :math:`{\mathit{mem}}_3` in :math:`{{\mathit{mem}}_3^\ast}`, :math:`{\mathit{mem}}_3` is of the case :math:`\mathsf{memory}`.

#. Let :math:`{(\mathsf{memory}~{\mathit{memtype}})^{n_{\mathit{mem}}}}` be :math:`{{\mathit{mem}}_3^\ast}`.

#. Assert: Due to validation, for all :math:`{\mathit{table}}_2` in :math:`{{\mathit{table}}_2^\ast}`, :math:`{\mathit{table}}_2` is of the case :math:`\mathsf{table}`.

#. Let :math:`{(\mathsf{table}~{\mathit{tabletype}})^{n_{\mathit{table}}}}` be :math:`{{\mathit{table}}_2^\ast}`.

#. Assert: Due to validation, for all :math:`{\mathit{global}}_1` in :math:`{{\mathit{global}}_1^\ast}`, :math:`{\mathit{global}}_1` is of the case :math:`\mathsf{global}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_1)^{n_{\mathit{global}}}}` be :math:`{{\mathit{global}}_1^\ast}`.

#. Assert: Due to validation, for all :math:`{\mathit{type}}_0` in :math:`{{\mathit{type}}_0^\ast}`, :math:`{\mathit{type}}_0` is of the case :math:`\mathsf{type}`.

#. Let :math:`{(\mathsf{type}~{\mathit{ft}})^\ast}` be :math:`{{\mathit{type}}_0^\ast}`.

#. Let :math:`{{\mathit{fa}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ga}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{globals}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ma}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{mems}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ta}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{tables}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{fa}}^\ast}` be :math:`{({|s{.}\mathsf{funcs}|} + i_{\mathit{func}})^{i_{\mathit{func}}<n_{\mathit{func}}}}`.

#. Let :math:`{{\mathit{ga}}^\ast}` be :math:`{({|s{.}\mathsf{globals}|} + i_{\mathit{global}})^{i_{\mathit{global}}<n_{\mathit{global}}}}`.

#. Let :math:`{{\mathit{ta}}^\ast}` be :math:`{({|s{.}\mathsf{tables}|} + i_{\mathit{table}})^{i_{\mathit{table}}<n_{\mathit{table}}}}`.

#. Let :math:`{{\mathit{ma}}^\ast}` be :math:`{({|s{.}\mathsf{mems}|} + i_{\mathit{mem}})^{i_{\mathit{mem}}<n_{\mathit{mem}}}}`.

#. Let :math:`{{\mathit{xi}}^\ast}` be :math:`{{\mathrm{instexport}}({{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast}, {{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast}, {{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast}, {{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast}, {\mathit{export}})^\ast}`.

#. Let :math:`{\mathit{moduleinst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}}^\ast},\; \mathsf{funcs}~{{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast},\; \mathsf{globals}~{{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast},\; \mathsf{tables}~{{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast},\; \mathsf{mems}~{{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast},\; \mathsf{exports}~{{\mathit{xi}}^\ast} \}\end{array}`.

#. Let :math:`{{\mathit{funcaddr}}_0^\ast}` be :math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}}^{n_{\mathit{func}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{funcaddr}}_0^\ast} = {{\mathit{fa}}^\ast}`.

#. Let :math:`{{\mathit{globaladdr}}_0^\ast}` be :math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}}^{n_{\mathit{global}}}}, {{\mathit{val}}^\ast})`.

#. Assert: Due to validation, :math:`{{\mathit{globaladdr}}_0^\ast} = {{\mathit{ga}}^\ast}`.

#. Let :math:`{{\mathit{tableaddr}}_0^\ast}` be :math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}}^{n_{\mathit{table}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{tableaddr}}_0^\ast} = {{\mathit{ta}}^\ast}`.

#. Let :math:`{{\mathit{memaddr}}_0^\ast}` be :math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}}^{n_{\mathit{mem}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{memaddr}}_0^\ast} = {{\mathit{ma}}^\ast}`.

#. Return :math:`{\mathit{moduleinst}}`.


:math:`{\mathrm{initelem}}(s, {\mathit{moduleinst}}, {i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {{\mathit{fa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................................................................................................


1. If :math:`{i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon` and :math:`{{\mathit{fa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return.

#. Assert: Due to validation, :math:`{|{{\mathit{fa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{a^\ast}~{{{a'}^\ast}^\ast}` be :math:`{{\mathit{fa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`i~{{i'}^\ast}` be :math:`{i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Replace :math:`s{.}\mathsf{tables}{}[{\mathit{moduleinst}}{.}\mathsf{tables}{}[0]]{.}\mathsf{refs}{}[i : {|{a^\ast}|}]` with :math:`{a^\ast}`.

#. Perform :math:`{\mathrm{initelem}}(s, {\mathit{moduleinst}}, {{i'}^\ast}, {{{a'}^\ast}^\ast})`.

#. Return.


:math:`{\mathrm{initdata}}(s, {\mathit{moduleinst}}, {i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.........................................................................................................................................................


1. If :math:`{i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon` and :math:`{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return.

#. Assert: Due to validation, :math:`{|{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{b^\ast}~{{{b'}^\ast}^\ast}` be :math:`{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`i~{{i'}^\ast}` be :math:`{i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Replace :math:`s{.}\mathsf{mems}{}[{\mathit{moduleinst}}{.}\mathsf{mems}{}[0]]{.}\mathsf{bytes}{}[i : {|{b^\ast}|}]` with :math:`{b^\ast}`.

#. Perform :math:`{\mathrm{initdata}}(s, {\mathit{moduleinst}}, {{i'}^\ast}, {{{b'}^\ast}^\ast})`.

#. Return.


:math:`{\mathrm{instantiate}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast})`
..................................................................................


1. Assert: Due to validation, :math:`{\mathit{module}}` is of the case :math:`\mathsf{module}`.

#. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be :math:`{\mathit{module}}`.

#. Assert: Due to validation, for all :math:`{\mathit{type}}` in :math:`{{\mathit{type}}^\ast}`, :math:`{\mathit{type}}` is of the case :math:`\mathsf{type}`.

#. Let :math:`{(\mathsf{type}~{\mathit{functype}})^\ast}` be :math:`{{\mathit{type}}^\ast}`.

#. Let :math:`n_{\mathsf{f}}` be :math:`{|{{\mathit{func}}^\ast}|}`.

#. Assert: Due to validation, for all :math:`{\mathit{start}}` in :math:`{{\mathit{start}}^?}`, :math:`{\mathit{start}}` is of the case :math:`\mathsf{start}`.

#. Let :math:`{(\mathsf{start}~{x'})^?}` be :math:`{{\mathit{start}}^?}`.

#. Assert: Due to validation, for all :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}`, :math:`{\mathit{data}}` is of the case :math:`\mathsf{data}`.

#. Let :math:`{(\mathsf{data}~{\mathit{expr}}_{\mathsf{d}}~{b^\ast})^\ast}` be :math:`{{\mathit{data}}^\ast}`.

#. Assert: Due to validation, for all :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}`, :math:`{\mathit{elem}}` is of the case :math:`\mathsf{elem}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{expr}}_{\mathsf{e}}~{x^\ast})^\ast}` be :math:`{{\mathit{elem}}^\ast}`.

#. Assert: Due to validation, for all :math:`{\mathit{global}}` in :math:`{{\mathit{global}}^\ast}`, :math:`{\mathit{global}}` is of the case :math:`\mathsf{global}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})^\ast}` be :math:`{{\mathit{global}}^\ast}`.

#. Let :math:`{\mathit{moduleinst}}_{\mathit{init}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{functype}}^\ast},\; \mathsf{funcs}~{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})~{({|s{.}\mathsf{funcs}|} + i_{\mathsf{f}})^{i_{\mathsf{f}}<n_{\mathsf{f}}}},\; \mathsf{globals}~{\mathrm{globals}}({{\mathit{externaddr}}^\ast}),\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{exports}~\epsilon \}\end{array}`.

#. Let :math:`f_{\mathit{init}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~\epsilon,\; \mathsf{module}~{\mathit{moduleinst}}_{\mathit{init}} \}\end{array}`.

#. Let :math:`z` be :math:`f_{\mathit{init}}`.

#. Push the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~z~\})` to the stack.

#. Let :math:`{(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_{\mathsf{d}})^\ast}` be :math:`{{\mathrm{eval}}_{\mathit{expr}}({\mathit{expr}}_{\mathsf{d}})^\ast}`.

#. Pop the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Push the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~z~\})` to the stack.

#. Let :math:`{(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_{\mathsf{e}})^\ast}` be :math:`{{\mathrm{eval}}_{\mathit{expr}}({\mathit{expr}}_{\mathsf{e}})^\ast}`.

#. Pop the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Push the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~z~\})` to the stack.

#. Let :math:`{{\mathit{val}}^\ast}` be :math:`{{\mathrm{eval}}_{\mathit{expr}}({\mathit{expr}}_{\mathsf{g}})^\ast}`.

#. Pop the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Let :math:`{\mathit{moduleinst}}` be :math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast})`.

#. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~\epsilon,\; \mathsf{module}~{\mathit{moduleinst}} \}\end{array}`.

#. Perform :math:`{\mathrm{initelem}}(s, {\mathit{moduleinst}}, {i_{\mathsf{e}}^\ast}, {{{\mathit{moduleinst}}{.}\mathsf{funcs}{}[x]^\ast}^\ast})`.

#. Perform :math:`{\mathrm{initdata}}(s, {\mathit{moduleinst}}, {i_{\mathsf{d}}^\ast}, {{b^\ast}^\ast})`.

#. Push the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~f~\})` to the stack.

#. Execute the sequence :math:`{(\mathsf{call}~{x'})^?}`.

#. Pop the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Return :math:`f{.}\mathsf{module}`.


:math:`{\mathrm{invoke}}(s, {\mathit{fa}}, {{\mathit{val}}^{n}})`
.................................................................


1. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~\epsilon,\; \mathsf{module}~\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{exports}~\epsilon \}\end{array} \}\end{array}`.

#. Push the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~f~\})` to the stack.

#. Let :math:`{t_1^{n}}~\rightarrow~{t_2^\ast}` be :math:`z{.}\mathsf{funcs}{}[{\mathit{fa}}]{.}\mathsf{type}`.

#. Pop the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Let :math:`k` be :math:`{|{t_2^\ast}|}`.

#. Push the evaluation context :math:`({\mathsf{frame}}_{k}\,\{~f~\})` to the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{call}~{\mathit{fa}})`.

#. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Pop the evaluation context :math:`({\mathsf{frame}}_{k}\,\{~f~\})` from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Return :math:`{{\mathit{val}}^{k}}`.


:math:`{\mathrm{eval}}_{\mathit{expr}}({{\mathit{instr}}^\ast})`
................................................................


1. Execute the instruction :math:`{{\mathit{instr}}^\ast}`.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Return :math:`{\mathit{val}}`.


== Complete.
watsup 0.4 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...
Limits_ok
- the limits ([ n .. m ]) is valid with k if:
  - n is less than or equal to m.
  - m is less than or equal to k.

Functype_ok
- the function type t_1* -> t_2? is valid.

Globaltype_ok
- the global type (MUT?, t) is valid.

Tabletype_ok
- the table type limits is valid if:
  - limits is valid with ((2 ^ 32) - 1).

Memtype_ok
- the memory type limits is valid if:
  - limits is valid with (2 ^ 16).

Externtype_ok
- the external type xt_u1 is valid if:
  - Either:
    - xt_u1 is (FUNC functype).
    - the function type functype is valid.
  - Or:
    - xt_u1 is (GLOBAL globaltype).
    - the global type globaltype is valid.
  - Or:
    - xt_u1 is (TABLE tabletype).
    - the table type tabletype is valid.
  - Or:
    - xt_u1 is (MEM memtype).
    - the memory type memtype is valid.

Externtype_ok/func
- the external type (FUNC functype) is valid if:
  - the function type functype is valid.

Externtype_ok/global
- the external type (GLOBAL globaltype) is valid if:
  - the global type globaltype is valid.

Externtype_ok/table
- the external type (TABLE tabletype) is valid if:
  - the table type tabletype is valid.

Externtype_ok/mem
- the external type (MEM memtype) is valid if:
  - the memory type memtype is valid.

Limits_sub
- the limits ([ n_11 .. n_12 ]) matches the limits ([ n_21 .. n_22 ]) if:
  - n_11 is greater than or equal to n_21.
  - n_12 is less than or equal to n_22.

Functype_sub
- the function type ft matches itself.

Globaltype_sub
- the global type gt matches itself.

Tabletype_sub
- the table type lim_1 matches the table type lim_2 if:
  - lim_1 matches lim_2.

Memtype_sub
- the memory type lim_1 matches the memory type lim_2 if:
  - lim_1 matches lim_2.

Externtype_sub
- the external type xt_u1 matches the external type xt_u2 if:
  - Either:
    - xt_u1 is (FUNC ft_1).
    - xt_u2 is (FUNC ft_2).
    - the function type ft_1 matches the function type ft_2.
  - Or:
    - xt_u1 is (GLOBAL gt_1).
    - xt_u2 is (GLOBAL gt_2).
    - the global type gt_1 matches the global type gt_2.
  - Or:
    - xt_u1 is (TABLE tt_1).
    - xt_u2 is (TABLE tt_2).
    - the table type tt_1 matches the table type tt_2.
  - Or:
    - xt_u1 is (MEM mt_1).
    - xt_u2 is (MEM mt_2).
    - the memory type mt_1 matches the memory type mt_2.

Externtype_sub/func
- the external type (FUNC ft_1) matches the external type (FUNC ft_2) if:
  - the function type ft_1 matches the function type ft_2.

Externtype_sub/global
- the external type (GLOBAL gt_1) matches the external type (GLOBAL gt_2) if:
  - the global type gt_1 matches the global type gt_2.

Externtype_sub/table
- the external type (TABLE tt_1) matches the external type (TABLE tt_2) if:
  - the table type tt_1 matches the table type tt_2.

Externtype_sub/mem
- the external type (MEM mt_1) matches the external type (MEM mt_2) if:
  - the memory type mt_1 matches the memory type mt_2.

Instr_ok/nop
- the instruction NOP is valid with the function type [] -> [].

Instr_ok/unreachable
- the instruction UNREACHABLE is valid with the function type t_1* -> t_2*.

Instr_ok/drop
- the instruction DROP is valid with the function type [t] -> [].

Instr_ok/select
- the instruction SELECT is valid with the function type [t, t, I32] -> [t].

Instr_ok/block
- the instruction (BLOCK t? instr*) is valid with the function type [] -> t? if:
  - the context C' is the context C with .LABELS prepended by [t?].
  - Under the context C', the instruction sequence instr* is valid with [] -> t?.

Instr_ok/loop
- the instruction (LOOP t? instr*) is valid with the function type [] -> t? if:
  - the instruction sequence instr* is valid with the function type [] -> [].

Instr_ok/if
- the instruction (IF t? instr_1* ELSE instr_2*) is valid with the function type [I32] -> t? if:
  - the context C' is the context C with .LABELS prepended by [t?].
  - Under the context C', the instruction sequence instr_1* is valid with the function type [] -> t?.
  - Under the context C', the instruction sequence instr_2* is valid with [] -> t?.

Instr_ok/br
- the instruction (BR l) is valid with the function type t_1* :: t? -> t_2* if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t?.

Instr_ok/br_if
- the instruction (BR_IF l) is valid with the function type t? :: [I32] -> t? if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t?.

Instr_ok/br_table
- the instruction (BR_TABLE l* l') is valid with the function type t_1* :: t? :: [I32] -> t_2* if:
  - the result type C.LABELS[l'] exists.
  - the result type t? is C.LABELS[l'].
  - For all l in l*:
    - the result type C.LABELS[l] exists.
  - For all l in l*:
    - t? is C.LABELS[l].

Instr_ok/call
- the instruction (CALL x) is valid with the function type t_1* -> t_2? if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is t_1* -> t_2?.

Instr_ok/call_indirect
- the instruction (CALL_INDIRECT x) is valid with the function type t_1* :: [I32] -> t_2? if:
  - the function type C.TYPES[x] exists.
  - C.TYPES[x] is t_1* -> t_2?.

Instr_ok/return
- the instruction RETURN is valid with the function type t_1* :: t? -> t_2* if:
  - the result type C.RETURN is ?(t?).

Instr_ok/const
- the instruction (t.CONST c_t) is valid with the function type [] -> [t].

Instr_ok/unop
- the instruction (UNOP t unop_t) is valid with the function type [t] -> [t].

Instr_ok/binop
- the instruction (BINOP t binop_t) is valid with the function type [t, t] -> [t].

Instr_ok/testop
- the instruction (TESTOP t testop_t) is valid with the function type [t] -> [I32].

Instr_ok/relop
- the instruction (RELOP t relop_t) is valid with the function type [t, t] -> [I32].

Instr_ok/cvtop
- the instruction (CVTOP nt_1 nt_2 cvtop_u1) is valid with the function type [nt_2] -> [nt_1] if:
  - Either:
    - cvtop_u1 is REINTERPRET.
    - $size(nt_1) is $size(nt_2).
  - Or:
    - cvtop_u1 is cvtop.

Instr_ok/local.get
- the instruction (LOCAL.GET x) is valid with the function type [] -> [t] if:
  - the number type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/local.set
- the instruction (LOCAL.SET x) is valid with the function type [t] -> [] if:
  - the number type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/local.tee
- the instruction (LOCAL.TEE x) is valid with the function type [t] -> [t] if:
  - the number type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/global.get
- the instruction (GLOBAL.GET x) is valid with the function type [] -> [t] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (mut, t).

Instr_ok/global.set
- the instruction (GLOBAL.SET x) is valid with the function type [t] -> [] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?(MUT), t).

Instr_ok/memory.size
- the instruction MEMORY.SIZE is valid with the function type [] -> [I32] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.

Instr_ok/memory.grow
- the instruction MEMORY.GROW is valid with the function type [I32] -> [I32] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.

Instr_ok/load
- the instruction (LOAD t_u1 loadop__u1? memarg) is valid with the function type [I32] -> [t_u3] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - Either:
    - the number type t_u1 is t.
    - loadop__u1? is ?().
    - the number type t_u3 is t.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(t) / 8).
  - Or:
    - t_u1 is Inn.
    - loadop__u1? is ?((M, sx)).
    - t_u3 is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store
- the instruction (STORE t_u1 sz_u1? memarg) is valid with the function type [I32, t_u2] -> [] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - Either:
    - the number type t_u1 is t.
    - the pack size sz_u1? is ?().
    - the number type t_u2 is t.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(t) / 8).
  - Or:
    - t_u1 is Inn.
    - sz_u1? is ?(M).
    - t_u2 is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/cvtop-reinterpret
- the instruction (CVTOP nt_1 nt_2 REINTERPRET) is valid with the function type [nt_2] -> [nt_1] if:
  - $size(nt_1) is $size(nt_2).

Instr_ok/cvtop-convert
- the instruction (CVTOP nt_1 nt_2 cvtop) is valid with [nt_2] -> [nt_1].

Instr_ok/load-val
- the instruction (LOAD t ?() memarg) is valid with the function type [I32] -> [t] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(t) / 8).

Instr_ok/load-pack
- the instruction (LOAD Inn ?((M, sx)) memarg) is valid with the function type [I32] -> [Inn] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store-val
- the instruction (STORE t ?() memarg) is valid with the function type [I32, t] -> [] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(t) / 8).

Instr_ok/store-pack
- the instruction (STORE Inn ?(M) memarg) is valid with the function type [I32, Inn] -> [] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instrs_ok
- the instruction sequence instr_u1* is valid with the function type t_u1* -> t_u2* if:
  - Either:
    - instr_u1* is [].
    - the number type sequence t_u1* is [].
    - the number type sequence t_u2* is [].
  - Or:
    - instr_u1* is [instr_1] :: instr_2*.
    - t_u1* is t_1*.
    - t_u2* is t_3*.
    - the instruction instr_1 is valid with the function type t_1* -> t_2*.
    - the instruction sequence instr_2* is valid with the function type t_2* -> t_3*.
  - Or:
    - instr_u1* is instr*.
    - t_u1* is t* :: t_1*.
    - t_u2* is t* :: t_2*.
    - the instruction sequence instr* is valid with t_1* -> t_2*.

Instrs_ok/empty
- the instruction sequence [] is valid with the function type [] -> [].

Instrs_ok/seq
- the instruction sequence [instr_1] :: instr_2* is valid with the function type t_1* -> t_3* if:
  - the instruction instr_1 is valid with the function type t_1* -> t_2*.
  - the instruction sequence instr_2* is valid with the function type t_2* -> t_3*.

Instrs_ok/frame
- the instruction sequence instr* is valid with the function type t* :: t_1* -> t* :: t_2* if:
  - instr* is valid with the function type t_1* -> t_2*.

Expr_ok
- the expression instr* is valid with the result type t? if:
  - instr* is valid with the function type [] -> t?.

Instr_const
- the instruction instr_u1 is constant if:
  - Either:
    - instr_u1 is (t.CONST c).
  - Or:
    - instr_u1 is (GLOBAL.GET x).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is (?(), t).

Instr_const/const
- the instruction (t.CONST c) is constant.

Instr_const/global.get
- the instruction (GLOBAL.GET x) is constant if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?(), t).

Expr_const
- the expression instr* is constant if:
  - For all instr in instr*:
    - the instruction instr is constant.

Type_ok
- the type (TYPE ft) is valid with the function type ft if:
  - ft is valid.

Func_ok
- the function (FUNC x (LOCAL t)* expr) is valid with the function type t_1* -> t_2? if:
  - the function type C.TYPES[x] exists.
  - C.TYPES[x] is t_1* -> t_2?.
  - Under the context C with .LOCALS appended by t_1* :: t* with .LABELS appended by [t_2?] with .RETURN appended by ?(t_2?), the expression expr is valid with the result type t_2?.

Global_ok
- the global (GLOBAL gt expr) is valid with the global type gt if:
  - gt is valid.
  - gt is (mut, t).
  - the expression expr is valid with the number type ?(t).
  - expr is constant.

Table_ok
- the table (TABLE tt) is valid with the table type tt if:
  - tt is valid.

Mem_ok
- the memory (MEMORY mt) is valid with the memory type mt if:
  - mt is valid.

Elem_ok
- the table segment (ELEM expr x*) is valid if:
  - the table type C.TABLES[0] exists.
  - C.TABLES[0] is lim.
  - the expression expr is valid with the number type ?(I32).
  - expr is constant.
  - |x*| is |ft*|.
  - For all x in x*:
    - the function type C.FUNCS[x] exists.
  - For all ft in ft* and x in x*:
    - C.FUNCS[x] is ft.

Data_ok
- the memory segment (DATA expr b*) is valid if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is lim.
  - the expression expr is valid with the number type ?(I32).
  - expr is constant.

Start_ok
- the start function (START x) is valid if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is [] -> [].

Import_ok
- the import (IMPORT name_1 name_2 xt) is valid with the external type xt if:
  - xt is valid.

Externidx_ok
- the external index externidx_u1 is valid with the external type xt_u1 if:
  - Either:
    - externidx_u1 is (FUNC x).
    - xt_u1 is (FUNC ft).
    - the function type C.FUNCS[x] exists.
    - C.FUNCS[x] is ft.
  - Or:
    - externidx_u1 is (GLOBAL x).
    - xt_u1 is (GLOBAL gt).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is gt.
  - Or:
    - externidx_u1 is (TABLE x).
    - xt_u1 is (TABLE tt).
    - the table type C.TABLES[x] exists.
    - C.TABLES[x] is tt.
  - Or:
    - externidx_u1 is (MEM x).
    - xt_u1 is (MEM mt).
    - the memory type C.MEMS[x] exists.
    - C.MEMS[x] is mt.

Externidx_ok/func
- the external index (FUNC x) is valid with the external type (FUNC ft) if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is ft.

Externidx_ok/global
- the external index (GLOBAL x) is valid with the external type (GLOBAL gt) if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is gt.

Externidx_ok/table
- the external index (TABLE x) is valid with the external type (TABLE tt) if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is tt.

Externidx_ok/mem
- the external index (MEM x) is valid with the external type (MEM mt) if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is mt.

Export_ok
- the export (EXPORT name externidx) is valid with the external type xt if:
  - the external index externidx is valid with xt.

Module_ok
- the module (MODULE type* import* func* global* table* mem* elem* data* start? export*) is valid if:
  - |type*| is |ft'*|.
  - For all ft' in ft'* and type in type*:
    - the type type is valid with the function type ft'.
  - |ixt*| is |import*|.
  - For all import in import* and ixt in ixt*:
    - Under the context { TYPES: ft'*; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; LOCALS: []; LABELS: []; RETURN: ?(); }, the import import is valid with the external type ixt.
  - |gt*| is |global*|.
  - For all global in global* and gt in gt*:
    - Under the context C', the global global is valid with the global type gt.
  - |func*| is |ft*|.
  - For all ft in ft* and func in func*:
    - the function func is valid with the function type ft.
  - |tt*| is |table*|.
  - For all table in table* and tt in tt*:
    - the table table is valid with the table type tt.
  - |mt*| is |mem*|.
  - For all mem in mem* and mt in mt*:
    - the memory mem is valid with the memory type mt.
  - For all elem in elem*:
    - the table segment elem is valid.
  - For all data in data*:
    - the memory segment data is valid.
  - If start is defined, then:
    - the start function start is valid.
  - |xt*| is |export*|.
  - For all export in export* and xt in xt*:
    - the export export is valid with the external type xt.
  - |tt*| is less than or equal to 1.
  - |mt*| is less than or equal to 1.
  - the context C is { TYPES: ft'*; FUNCS: ift* :: ft*; GLOBALS: igt* :: gt*; TABLES: itt* :: tt*; MEMS: imt* :: mt*; LOCALS: []; LABELS: []; RETURN: ?(); }.
  - the context C' is { TYPES: ft'*; FUNCS: ift* :: ft*; GLOBALS: igt*; TABLES: []; MEMS: []; LOCALS: []; LABELS: []; RETURN: ?(); }.
  - the function type sequence ift* is $funcsxt(ixt*).
  - the global type sequence igt* is $globalsxt(ixt*).
  - the table type sequence itt* is $tablesxt(ixt*).
  - the memory type sequence imt* is $memsxt(ixt*).

Step_pure/unreachable
1. Trap.

Step_pure/nop
1. Do nothing.

Step_pure/drop
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Do nothing.

Step_pure/select
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val_2 from the stack.
5. Assert: Due to validation, a value is on the top of the stack.
6. Pop the value val_1 from the stack.
7. If (c =/= 0), then:
  a. Push the value val_1 to the stack.
8. Else:
  a. Push the value val_2 to the stack.

Step_pure/if t? instr_1* instr_2*
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BLOCK t? instr_1*).
4. Else:
  a. Execute the instruction (BLOCK t? instr_2*).

Step_pure/label
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
3. Pop the current LABEL_ context from the stack.
4. Push the values val* to the stack.

Step_pure/br n_u1
1. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
2. Let (LABEL_ n { instr'* }) be the current LABEL_ context.
3. If (n_u1 = 0), then:
  a. Assert: Due to validation, there are at least n values on the top of the stack.
  b. Pop the values val^n from the stack.
  c. Pop all values val'* from the top of the stack.
  d. Pop the current LABEL_ context from the stack.
  e. Push the values val^n to the stack.
  f. Execute the instruction instr'*.
4. Else:
  a. Pop all values val* from the top of the stack.
  b. If (n_u1 >= 1), then:
    1) Let l be (n_u1 - 1).
    2) Pop the current LABEL_ context from the stack.
    3) Push the values val* to the stack.
    4) Execute the instruction (BR l).

Step_pure/br_if l
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BR l).
4. Else:
  a. Do nothing.

Step_pure/br_table l* l'
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. If (i < |l*|), then:
  a. Execute the instruction (BR l*[i]).
4. Else:
  a. Execute the instruction (BR l').

Step_pure/frame
1. Let (FRAME_ n { f }) be the current FRAME_ context.
2. Assert: Due to validation, there are at least n values on the top of the stack.
3. Assert: Due to validation, there are at least n values on the top of the stack.
4. Pop the values val^n from the stack.
5. Assert: Due to validation, the first non-value entry of the stack is a FRAME_.
6. Pop the current FRAME_ context from the stack.
7. Push the values val^n to the stack.

Step_pure/return
1. If the first non-value entry of the stack is a FRAME_, then:
  a. Let (FRAME_ n { f }) be the current FRAME_ context.
  b. Assert: Due to validation, there are at least n values on the top of the stack.
  c. Pop the values val^n from the stack.
  d. Pop all values val'* from the top of the stack.
  e. Pop the current FRAME_ context from the stack.
  f. Push the values val^n to the stack.
2. Else if the first non-value entry of the stack is a LABEL_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the current LABEL_ context from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction RETURN.

Step_pure/unop t unop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (valtype_0.CONST c_1) from the stack.
3. If (|$unop_(t, unop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $unop_(t, unop, c_1).
5. Push the value (t.CONST c) to the stack.

Step_pure/binop t binop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (valtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type valtype_0 is on the top of the stack.
4. Pop the value (valtype_0.CONST c_1) from the stack.
5. If (|$binop_(t, binop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $binop_(t, binop, c_1, c_2).
7. Push the value (t.CONST c) to the stack.

Step_pure/testop t testop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (valtype_0.CONST c_1) from the stack.
3. Let c be $testop_(t, testop, c_1).
4. Push the value (I32.CONST c) to the stack.

Step_pure/relop t relop
1. Assert: Due to validation, a value of value type t is on the top of the stack.
2. Pop the value (valtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type valtype_0 is on the top of the stack.
4. Pop the value (valtype_0.CONST c_1) from the stack.
5. Let c be $relop_(t, relop, c_1, c_2).
6. Push the value (I32.CONST c) to the stack.

Step_pure/cvtop t_2 t_1 cvtop
1. Assert: Due to validation, a value of value type t_1 is on the top of the stack.
2. Pop the value (valtype_0.CONST c_1) from the stack.
3. If (|$cvtop__(t_1, t_2, cvtop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $cvtop__(t_1, t_2, cvtop, c_1).
5. Push the value (t_2.CONST c) to the stack.

Step_pure/local.tee x
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Push the value val to the stack.
4. Push the value val to the stack.
5. Execute the instruction (LOCAL.SET x).

Step_read/block t? instr*
1. Let n be 0.
2. If t? is not defined, then:
  a. Enter instr* with label (LABEL_ n { [] }).
3. Let n be 1.
4. If (t? =/= ?()), then:
  a. Enter instr* with label (LABEL_ n { [] }).

Step_read/loop t? instr*
1. Enter instr* with label (LABEL_ 0 { [(LOOP t? instr*)] }).

Step_read/call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$funcaddr(z)|).
3. Execute the instruction (CALL_ADDR $funcaddr(z)[x]).

Step_read/call_indirect x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (i >= |$table(z, 0).REFS|), then:
  a. Trap.
5. If $table(z, 0).REFS[i] is not defined, then:
  a. Trap.
6. Let ?(a) be $table(z, 0).REFS[i].
7. If (a >= |$funcinst(z)|), then:
  a. Trap.
8. If ($type(z, x) =/= $funcinst(z)[a].TYPE), then:
  a. Trap.
9. Execute the instruction (CALL_ADDR a).

Step_read/call_addr a
1. Let z be the current state.
2. Assert: Due to validation, (a < |$funcinst(z)|).
3. Let { TYPE: t_1^k -> t_2^n; MODULE: mm; CODE: func; } be $funcinst(z)[a].
4. Assert: Due to validation, func is of the case FUNC.
5. Let (FUNC x local_0* instr*) be func.
6. Assert: Due to validation, local_0 is of the case LOCAL*.
7. Let (LOCAL t)* be local_0*.
8. Assert: Due to validation, there are at least k values on the top of the stack.
9. Pop the values val^k from the stack.
10. Let f be { LOCALS: val^k :: $default_(t)*; MODULE: mm; }.
11. Push the evaluation context (FRAME_ n { f }) to the stack.
12. Enter instr* with label (LABEL_ n { [] }).

Step_read/local.get x
1. Let z be the current state.
2. Push the value $local(z, x) to the stack.

Step_read/global.get x
1. Let z be the current state.
2. Push the value $global(z, x).VALUE to the stack.

Step_read/load t_u1 loadop__u1? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If loadop__u1? is not defined, then:
  a. Let t be t_u1.
  b. If (((i + ao.OFFSET) + ($size(t) / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  c. Let c be $bytes__1^-1(t, $mem(z, 0).BYTES[(i + ao.OFFSET) : ($size(t) / 8)]).
  d. Push the value (t.CONST c) to the stack.
5. If the type of t_u1 is Inn, then:
  a. If loadop__u1? is defined, then:
    1) Let ?(loadop__0) be loadop__u1?.
    2) Let (n, sx) be loadop__0.
    3) If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
  b. Let Inn be t_u1.
  c. If loadop__u1? is defined, then:
    1) Let ?(loadop__0) be loadop__u1?.
    2) Let (n, sx) be loadop__0.
    3) Let c be $ibytes__1^-1(n, $mem(z, 0).BYTES[(i + ao.OFFSET) : (n / 8)]).
    4) Push the value (Inn.CONST $extend__(n, $size(Inn), sx, c)) to the stack.

Step_read/memory.size
1. Let z be the current state.
2. Let ((n * 64) * $Ki()) be |$mem(z, 0).BYTES|.
3. Push the value (I32.CONST n) to the stack.

Step/local.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_local(z, x, val).

Step/global.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_global(z, x, val).

Step/store t_u1 sz_u1? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type t_u2 is on the top of the stack.
3. Pop the value (t_u2.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Let t be t_u2.
7. If ((((i + ao.OFFSET) + ($size(t) / 8)) > |$mem(z, 0).BYTES|) /\ ((t_u1 = t) /\ sz_u1? is not defined)), then:
  a. Trap.
8. If ((t_u1 = t) /\ sz_u1? is not defined), then:
  a. Let b* be $bytes_(t, c).
  b. Perform $with_mem(z, 0, (i + ao.OFFSET), ($size(t) / 8), b*).
9. If the type of t_u2 is Inn, then:
  a. Let Inn be t_u2.
  b. If ((t_u1 = Inn) /\ sz_u1? is defined), then:
    1) Let ?(n) be sz_u1?.
    2) If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let b* be $ibytes_(n, $wrap__($size(Inn), n, c)).
    4) Perform $with_mem(z, 0, (i + ao.OFFSET), (n / 8), b*).

Step/memory.grow
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Either:
  a. Let mi be $growmemory($mem(z, 0), n).
  b. Push the value (I32.CONST (|$mem(z, 0).BYTES| / (64 * $Ki()))) to the stack.
  c. Perform $with_meminst(z, 0, mi).
5. Or:
  a. Push the value (I32.CONST $invsigned_(32, (- 1))) to the stack.

Ki
1. Return 1024.

min i j
1. If (i <= j), then:
  a. Return i.
2. Return j.

sum n_u1*
1. If (n_u1* = []), then:
  a. Return 0.
2. Let [n] :: n'* be n_u1*.
3. Return (n + $sum(n'*)).

opt_ X X_u1*
1. If (X_u1* = []), then:
  a. Return ?().
2. Assert: Due to validation, (|X_u1*| = 1).
3. Let [w] be X_u1*.
4. Return ?(w).

list_ X X_u1?
1. If X_u1? is not defined, then:
  a. Return [].
2. Let ?(w) be X_u1?.
3. Return [w].

concat_ X X_u1*
1. If (X_u1* = []), then:
  a. Return [].
2. Let [w*] :: w'** be X_u1*.
3. Return w* :: $concat_(X, w'**).

signif N_u1
1. If (N_u1 = 32), then:
  a. Return 23.
2. Assert: Due to validation, (N_u1 = 64).
3. Return 52.

expon N_u1
1. If (N_u1 = 32), then:
  a. Return 8.
2. Assert: Due to validation, (N_u1 = 64).
3. Return 11.

M N
1. Return $signif(N).

E N
1. Return $expon(N).

fzero N
1. Return (POS (SUBNORM 0)).

fone N
1. Return (POS (NORM 1 0)).

canon_ N
1. Return (2 ^ ($signif(N) - 1)).

size t_u1
1. If (t_u1 = I32), then:
  a. Return 32.
2. If (t_u1 = I64), then:
  a. Return 64.
3. If (t_u1 = F32), then:
  a. Return 32.
4. If (t_u1 = F64), then:
  a. Return 64.

funcsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is of the case FUNC, then:
  a. Let (FUNC ft) be externtype_0.
  b. Return [ft] :: $funcsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $funcsxt(xt*).

globalsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is of the case GLOBAL, then:
  a. Let (GLOBAL gt) be externtype_0.
  b. Return [gt] :: $globalsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $globalsxt(xt*).

tablesxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is of the case TABLE, then:
  a. Let (TABLE tt) be externtype_0.
  b. Return [tt] :: $tablesxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $tablesxt(xt*).

memsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is of the case MEM, then:
  a. Let (MEM mt) be externtype_0.
  b. Return [mt] :: $memsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $memsxt(xt*).

memarg0
1. Return { ALIGN: 0; OFFSET: 0; }.

signed_ N i
1. If (i < (2 ^ (N - 1))), then:
  a. Return i.
2. Assert: Due to validation, ((2 ^ (N - 1)) <= i).
3. Assert: Due to validation, (i < (2 ^ N)).
4. Return (i - (2 ^ N)).

invsigned_ N i
1. Let j be $signed__1^-1(N, i).
2. Return j.

unop_ t_u1 unop_u1 c_u1
1. If the type of t_u1 is Inn, then:
  a. Let Inn be t_u1.
  b. Let iN be c_u1.
  c. If (unop_u1 = CLZ), then:
    1) Return [$iclz_($size(Inn), iN)].
  d. If (unop_u1 = CTZ), then:
    1) Return [$ictz_($size(Inn), iN)].
  e. If (unop_u1 = POPCNT), then:
    1) Return [$ipopcnt_($size(Inn), iN)].
2. Assert: Due to validation, the type of t_u1 is Fnn.
3. Let Fnn be t_u1.
4. Let fN be c_u1.
5. If (unop_u1 = ABS), then:
  a. Return $fabs_($size(Fnn), fN).
6. If (unop_u1 = NEG), then:
  a. Return $fneg_($size(Fnn), fN).
7. If (unop_u1 = SQRT), then:
  a. Return $fsqrt_($size(Fnn), fN).
8. If (unop_u1 = CEIL), then:
  a. Return $fceil_($size(Fnn), fN).
9. If (unop_u1 = FLOOR), then:
  a. Return $ffloor_($size(Fnn), fN).
10. If (unop_u1 = TRUNC), then:
  a. Return $ftrunc_($size(Fnn), fN).
11. Assert: Due to validation, (unop_u1 = NEAREST).
12. Return $fnearest_($size(Fnn), fN).

binop_ t_u1 binop_u1 c_u1 c_u2
1. If the type of t_u1 is Inn, then:
  a. Let Inn be t_u1.
  b. Let iN_1 be c_u1.
  c. Let iN_2 be c_u2.
  d. If (binop_u1 = ADD), then:
    1) Return [$iadd_($size(Inn), iN_1, iN_2)].
  e. If (binop_u1 = SUB), then:
    1) Return [$isub_($size(Inn), iN_1, iN_2)].
  f. If (binop_u1 = MUL), then:
    1) Return [$imul_($size(Inn), iN_1, iN_2)].
  g. If binop_u1 is of the case DIV, then:
    1) Let (DIV sx) be binop_u1.
    2) Return $list_(val_((Inn : Inn <: valtype)), $idiv_($size(Inn), sx, iN_1, iN_2)).
  h. If binop_u1 is of the case REM, then:
    1) Let (REM sx) be binop_u1.
    2) Return $list_(val_((Inn : Inn <: valtype)), $irem_($size(Inn), sx, iN_1, iN_2)).
  i. If (binop_u1 = AND), then:
    1) Return [$iand_($size(Inn), iN_1, iN_2)].
  j. If (binop_u1 = OR), then:
    1) Return [$ior_($size(Inn), iN_1, iN_2)].
  k. If (binop_u1 = XOR), then:
    1) Return [$ixor_($size(Inn), iN_1, iN_2)].
  l. If (binop_u1 = SHL), then:
    1) Return [$ishl_($size(Inn), iN_1, iN_2)].
  m. If binop_u1 is of the case SHR, then:
    1) Let (SHR sx) be binop_u1.
    2) Return [$ishr_($size(Inn), sx, iN_1, iN_2)].
  n. If (binop_u1 = ROTL), then:
    1) Return [$irotl_($size(Inn), iN_1, iN_2)].
  o. If (binop_u1 = ROTR), then:
    1) Return [$irotr_($size(Inn), iN_1, iN_2)].
2. Assert: Due to validation, the type of t_u1 is Fnn.
3. Let Fnn be t_u1.
4. Let fN_1 be c_u1.
5. Let fN_2 be c_u2.
6. If (binop_u1 = ADD), then:
  a. Return $fadd_($size(Fnn), fN_1, fN_2).
7. If (binop_u1 = SUB), then:
  a. Return $fsub_($size(Fnn), fN_1, fN_2).
8. If (binop_u1 = MUL), then:
  a. Return $fmul_($size(Fnn), fN_1, fN_2).
9. If (binop_u1 = DIV), then:
  a. Return $fdiv_($size(Fnn), fN_1, fN_2).
10. If (binop_u1 = MIN), then:
  a. Return $fmin_($size(Fnn), fN_1, fN_2).
11. If (binop_u1 = MAX), then:
  a. Return $fmax_($size(Fnn), fN_1, fN_2).
12. Assert: Due to validation, (binop_u1 = COPYSIGN).
13. Return $fcopysign_($size(Fnn), fN_1, fN_2).

testop_ Inn EQZ iN
1. Return $ieqz_($size(Inn), iN).

relop_ t_u1 relop_u1 c_u1 c_u2
1. If the type of t_u1 is Inn, then:
  a. Let Inn be t_u1.
  b. Let iN_1 be c_u1.
  c. Let iN_2 be c_u2.
  d. If (relop_u1 = EQ), then:
    1) Return $ieq_($size(Inn), iN_1, iN_2).
  e. If (relop_u1 = NE), then:
    1) Return $ine_($size(Inn), iN_1, iN_2).
  f. If relop_u1 is of the case LT, then:
    1) Let (LT sx) be relop_u1.
    2) Return $ilt_($size(Inn), sx, iN_1, iN_2).
  g. If relop_u1 is of the case GT, then:
    1) Let (GT sx) be relop_u1.
    2) Return $igt_($size(Inn), sx, iN_1, iN_2).
  h. If relop_u1 is of the case LE, then:
    1) Let (LE sx) be relop_u1.
    2) Return $ile_($size(Inn), sx, iN_1, iN_2).
  i. If relop_u1 is of the case GE, then:
    1) Let (GE sx) be relop_u1.
    2) Return $ige_($size(Inn), sx, iN_1, iN_2).
2. Assert: Due to validation, the type of t_u1 is Fnn.
3. Let Fnn be t_u1.
4. Let fN_1 be c_u1.
5. Let fN_2 be c_u2.
6. If (relop_u1 = EQ), then:
  a. Return $feq_($size(Fnn), fN_1, fN_2).
7. If (relop_u1 = NE), then:
  a. Return $fne_($size(Fnn), fN_1, fN_2).
8. If (relop_u1 = LT), then:
  a. Return $flt_($size(Fnn), fN_1, fN_2).
9. If (relop_u1 = GT), then:
  a. Return $fgt_($size(Fnn), fN_1, fN_2).
10. If (relop_u1 = LE), then:
  a. Return $fle_($size(Fnn), fN_1, fN_2).
11. Assert: Due to validation, (relop_u1 = GE).
12. Return $fge_($size(Fnn), fN_1, fN_2).

cvtop__ t_u1 t_u2 cvtop_u1 c_u1
1. If cvtop_u1 is of the case EXTEND, then:
  a. Let (EXTEND sx) be cvtop_u1.
  b. Let iN be c_u1.
  c. If ((t_u1 = I32) /\ (t_u2 = I64)), then:
    1) Return [$extend__(32, 64, sx, iN)].
2. Let iN be c_u1.
3. If ((t_u1 = I64) /\ ((t_u2 = I32) /\ (cvtop_u1 = WRAP))), then:
  a. Return [$wrap__(64, 32, iN)].
4. If the type of t_u1 is Fnn, then:
  a. Let Fnn be t_u1.
  b. If the type of t_u2 is Inn, then:
    1) Let Inn be t_u2.
    2) If cvtop_u1 is of the case TRUNC, then:
      a) Let (TRUNC sx) be cvtop_u1.
      b) Let fN be c_u1.
      c) Return $list_(val_((Inn : Inn <: valtype)), $trunc__($size(Fnn), $size(Inn), sx, fN)).
5. Let fN be c_u1.
6. If ((t_u1 = F32) /\ ((t_u2 = F64) /\ (cvtop_u1 = PROMOTE))), then:
  a. Return $promote__(32, 64, fN).
7. If ((t_u1 = F64) /\ ((t_u2 = F32) /\ (cvtop_u1 = DEMOTE))), then:
  a. Return $demote__(64, 32, fN).
8. If the type of t_u1 is Inn, then:
  a. Let Inn be t_u1.
  b. If the type of t_u2 is Fnn, then:
    1) Let Fnn be t_u2.
    2) If cvtop_u1 is of the case CONVERT, then:
      a) Let (CONVERT sx) be cvtop_u1.
      b) Return [$convert__($size(Inn), $size(Fnn), sx, iN)].
    3) If ((cvtop_u1 = REINTERPRET) /\ ($size(Inn) = $size(Fnn))), then:
      a) Return [$reinterpret__(Inn, Fnn, iN)].
9. Assert: Due to validation, the type of t_u1 is Fnn.
10. Let Fnn be t_u1.
11. Assert: Due to validation, the type of t_u2 is Inn.
12. Let Inn be t_u2.
13. Assert: Due to validation, (cvtop_u1 = REINTERPRET).
14. Assert: Due to validation, ($size(Inn) = $size(Fnn)).
15. Return [$reinterpret__(Fnn, Inn, fN)].

invibytes_ N b*
1. Let n be $ibytes__1^-1(N, b*).
2. Return n.

invfbytes_ N b*
1. Let p be $fbytes__1^-1(N, b*).
2. Return p.

default_ t_u1
1. If (t_u1 = I32), then:
  a. Return (I32.CONST 0).
2. If (t_u1 = I64), then:
  a. Return (I64.CONST 0).
3. If (t_u1 = F32), then:
  a. Return (F32.CONST $fzero(32)).
4. Assert: Due to validation, (t_u1 = F64).
5. Return (F64.CONST $fzero(64)).

funcsxa xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be xv_u1*.
3. If externaddr_0 is of the case FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcsxa(xv*).
4. Let [externaddr] :: xv* be xv_u1*.
5. Return $funcsxa(xv*).

globalsxa xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be xv_u1*.
3. If externaddr_0 is of the case GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globalsxa(xv*).
4. Let [externaddr] :: xv* be xv_u1*.
5. Return $globalsxa(xv*).

tablesxa xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be xv_u1*.
3. If externaddr_0 is of the case TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tablesxa(xv*).
4. Let [externaddr] :: xv* be xv_u1*.
5. Return $tablesxa(xv*).

memsxa xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be xv_u1*.
3. If externaddr_0 is of the case MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $memsxa(xv*).
4. Let [externaddr] :: xv* be xv_u1*.
5. Return $memsxa(xv*).

store z
1. Return.

frame z
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return f.

funcaddr z
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return f.MODULE.FUNCS.

funcinst z
1. Return s.FUNCS.

globalinst z
1. Return s.GLOBALS.

tableinst z
1. Return s.TABLES.

meminst z
1. Return s.MEMS.

moduleinst z
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return f.MODULE.

type z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return f.MODULE.TYPES[x].

func z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return s.FUNCS[f.MODULE.FUNCS[x]].

global z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return s.GLOBALS[f.MODULE.GLOBALS[x]].

table z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return s.TABLES[f.MODULE.TABLES[x]].

mem z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return s.MEMS[f.MODULE.MEMS[x]].

local z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return f.LOCALS[x].

with_local z x v
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace f.LOCALS[x] with v.

with_global z x v
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace s.GLOBALS[f.MODULE.GLOBALS[x]].VALUE with v.

with_table z x i a
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace s.TABLES[f.MODULE.TABLES[x]].REFS[i] with ?(a).

with_tableinst z x ti
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace s.TABLES[f.MODULE.TABLES[x]] with ti.

with_mem z x i j b*
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace s.MEMS[f.MODULE.MEMS[x]].BYTES[i : j] with b*.

with_meminst z x mi
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace s.MEMS[f.MODULE.MEMS[x]] with mi.

growtable ti n
1. Let { TYPE: ([ i .. j ]); REFS: ?(a)*; } be ti.
2. Let i' be (|a*| + n).
3. If (i' <= j), then:
  a. Let ti' be { TYPE: ([ i' .. j ]); REFS: ?(a)* :: ?()^n; }.
  b. Return ti'.

growmemory mi n
1. Let { TYPE: ([ i .. j ]); BYTES: b*; } be mi.
2. Let i' be ((|b*| / (64 * $Ki())) + n).
3. If (i' <= j), then:
  a. Let mi' be { TYPE: ([ i' .. j ]); BYTES: b* :: 0^(n * (64 * $Ki())); }.
  b. Return mi'.

funcs xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be xv_u1*.
3. If externaddr_0 is of the case FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcs(externaddr'*).
4. Let [externaddr] :: externaddr'* be xv_u1*.
5. Return $funcs(externaddr'*).

globals xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be xv_u1*.
3. If externaddr_0 is of the case GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globals(externaddr'*).
4. Let [externaddr] :: externaddr'* be xv_u1*.
5. Return $globals(externaddr'*).

tables xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be xv_u1*.
3. If externaddr_0 is of the case TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tables(externaddr'*).
4. Let [externaddr] :: externaddr'* be xv_u1*.
5. Return $tables(externaddr'*).

mems xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be xv_u1*.
3. If externaddr_0 is of the case MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $mems(externaddr'*).
4. Let [externaddr] :: externaddr'* be xv_u1*.
5. Return $mems(externaddr'*).

allocfunc s moduleinst func
1. Assert: Due to validation, func is of the case FUNC.
2. Let (FUNC x local* expr) be func.
3. Let fi be { TYPE: moduleinst.TYPES[x]; MODULE: moduleinst; CODE: func; }.
4. Let a be |s.FUNCS|.
5. Append fi to the s.FUNCS.
6. Return a.

allocfuncs s moduleinst func_u1*
1. If (func_u1* = []), then:
  a. Return [].
2. Let [func] :: func'* be func_u1*.
3. Let fa be $allocfunc(s, moduleinst, func).
4. Let fa'* be $allocfuncs(s, moduleinst, func'*).
5. Return [fa] :: fa'*.

allocglobal s globaltype val
1. Let gi be { TYPE: globaltype; VALUE: val; }.
2. Let a be |s.GLOBALS|.
3. Append gi to the s.GLOBALS.
4. Return a.

allocglobals s gt_u1* v_u1*
1. If (gt_u1* = []), then:
  a. Assert: Due to validation, (v_u1* = []).
  b. Return [].
2. Else:
  a. Let [globaltype] :: globaltype'* be gt_u1*.
  b. Assert: Due to validation, (|v_u1*| >= 1).
  c. Let [val] :: val'* be v_u1*.
  d. Let ga be $allocglobal(s, globaltype, val).
  e. Let ga'* be $allocglobals(s, globaltype'*, val'*).
  f. Return [ga] :: ga'*.

alloctable s ([ i .. j ])
1. Let ti be { TYPE: ([ i .. j ]); REFS: ?()^i; }.
2. Let a be |s.TABLES|.
3. Append ti to the s.TABLES.
4. Return a.

alloctables s tt_u1*
1. If (tt_u1* = []), then:
  a. Return [].
2. Let [tabletype] :: tabletype'* be tt_u1*.
3. Let ta be $alloctable(s, tabletype).
4. Let ta'* be $alloctables(s, tabletype'*).
5. Return [ta] :: ta'*.

allocmem s ([ i .. j ])
1. Let mi be { TYPE: ([ i .. j ]); BYTES: 0^(i * (64 * $Ki())); }.
2. Let a be |s.MEMS|.
3. Append mi to the s.MEMS.
4. Return a.

allocmems s mt_u1*
1. If (mt_u1* = []), then:
  a. Return [].
2. Let [memtype] :: memtype'* be mt_u1*.
3. Let ma be $allocmem(s, memtype).
4. Let ma'* be $allocmems(s, memtype'*).
5. Return [ma] :: ma'*.

instexport fa* ga* ta* ma* (EXPORT name externidx_u1)
1. If externidx_u1 is of the case FUNC, then:
  a. Let (FUNC x) be externidx_u1.
  b. Return { NAME: name; ADDR: (FUNC fa*[x]); }.
2. If externidx_u1 is of the case GLOBAL, then:
  a. Let (GLOBAL x) be externidx_u1.
  b. Return { NAME: name; ADDR: (GLOBAL ga*[x]); }.
3. If externidx_u1 is of the case TABLE, then:
  a. Let (TABLE x) be externidx_u1.
  b. Return { NAME: name; ADDR: (TABLE ta*[x]); }.
4. Assert: Due to validation, externidx_u1 is of the case MEM.
5. Let (MEM x) be externidx_u1.
6. Return { NAME: name; ADDR: (MEM ma*[x]); }.

allocmodule s module externaddr* val*
1. Assert: Due to validation, module is of the case MODULE.
2. Let (MODULE type_0* import* func^n_func global_1* table_2* mem_3* elem* data* start? export*) be module.
3. Assert: Due to validation, mem_3 is of the case MEMORY*.
4. Let (MEMORY memtype)^n_mem be mem_3*.
5. Assert: Due to validation, table_2 is of the case TABLE*.
6. Let (TABLE tabletype)^n_table be table_2*.
7. Assert: Due to validation, global_1 is of the case GLOBAL*.
8. Let (GLOBAL globaltype expr_1)^n_global be global_1*.
9. Assert: Due to validation, type_0 is of the case TYPE*.
10. Let (TYPE ft)* be type_0*.
11. Let fa_ex* be $funcs(externaddr*).
12. Let ga_ex* be $globals(externaddr*).
13. Let ma_ex* be $mems(externaddr*).
14. Let ta_ex* be $tables(externaddr*).
15. Let fa* be (|s.FUNCS| + i_func)^(i_func<n_func).
16. Let ga* be (|s.GLOBALS| + i_global)^(i_global<n_global).
17. Let ta* be (|s.TABLES| + i_table)^(i_table<n_table).
18. Let ma* be (|s.MEMS| + i_mem)^(i_mem<n_mem).
19. Let xi* be $instexport(fa_ex* :: fa*, ga_ex* :: ga*, ta_ex* :: ta*, ma_ex* :: ma*, export)*.
20. Let moduleinst be { TYPES: ft*; FUNCS: fa_ex* :: fa*; GLOBALS: ga_ex* :: ga*; TABLES: ta_ex* :: ta*; MEMS: ma_ex* :: ma*; EXPORTS: xi*; }.
21. Let funcaddr_0* be $allocfuncs(s, moduleinst, func^n_func).
22. Assert: Due to validation, (funcaddr_0* = fa*).
23. Let globaladdr_0* be $allocglobals(s, globaltype^n_global, val*).
24. Assert: Due to validation, (globaladdr_0* = ga*).
25. Let tableaddr_0* be $alloctables(s, tabletype^n_table).
26. Assert: Due to validation, (tableaddr_0* = ta*).
27. Let memaddr_0* be $allocmems(s, memtype^n_mem).
28. Assert: Due to validation, (memaddr_0* = ma*).
29. Return moduleinst.

initelem s moduleinst i_u1* fa_u1*
1. If ((i_u1* = []) /\ (fa_u1* = [])), then:
  a. Return.
2. Assert: Due to validation, (|fa_u1*| >= 1).
3. Let [a*] :: a'** be fa_u1*.
4. Assert: Due to validation, (|i_u1*| >= 1).
5. Let [i] :: i'* be i_u1*.
6. Replace s.TABLES[moduleinst.TABLES[0]].REFS[i : |a*|] with ?(a)*.
7. Perform $initelem(s, moduleinst, i'*, a'**).
8. Return.

initdata s moduleinst i_u1* b_u1*
1. If ((i_u1* = []) /\ (b_u1* = [])), then:
  a. Return.
2. Assert: Due to validation, (|b_u1*| >= 1).
3. Let [b*] :: b'** be b_u1*.
4. Assert: Due to validation, (|i_u1*| >= 1).
5. Let [i] :: i'* be i_u1*.
6. Replace s.MEMS[moduleinst.MEMS[0]].BYTES[i : |b*|] with b*.
7. Perform $initdata(s, moduleinst, i'*, b'**).
8. Return.

instantiate s module externaddr*
1. Assert: Due to validation, module is of the case MODULE.
2. Let (MODULE type* import* func* global* table* mem* elem* data* start? export*) be module.
3. Assert: Due to validation, type is of the case TYPE*.
4. Let (TYPE functype)* be type*.
5. Let n_F be |func*|.
6. Assert: Due to validation, start is of the case START?.
7. Let (START x')? be start?.
8. Assert: Due to validation, data is of the case DATA*.
9. Let (DATA expr_D b*)* be data*.
10. Assert: Due to validation, elem is of the case ELEM*.
11. Let (ELEM expr_E x*)* be elem*.
12. Assert: Due to validation, global is of the case GLOBAL*.
13. Let (GLOBAL globaltype expr_G)* be global*.
14. Let moduleinst_init be { TYPES: functype*; FUNCS: $funcs(externaddr*) :: (|s.FUNCS| + i_F)^(i_F<n_F); GLOBALS: $globals(externaddr*); TABLES: []; MEMS: []; EXPORTS: []; }.
15. Let f_init be { LOCALS: []; MODULE: moduleinst_init; }.
16. Let z be f_init.
17. Push the evaluation context (FRAME_ 0 { z }) to the stack.
18. Let [(I32.CONST i_D)]* be $eval_expr(expr_D)*.
19. Pop the evaluation context (FRAME_ 0 { _f }) from the stack.
20. Push the evaluation context (FRAME_ 0 { z }) to the stack.
21. Let [(I32.CONST i_E)]* be $eval_expr(expr_E)*.
22. Pop the evaluation context (FRAME_ 0 { _f }) from the stack.
23. Push the evaluation context (FRAME_ 0 { z }) to the stack.
24. Let [val]* be $eval_expr(expr_G)*.
25. Pop the evaluation context (FRAME_ 0 { _f }) from the stack.
26. Let moduleinst be $allocmodule(s, module, externaddr*, val*).
27. Let f be { LOCALS: []; MODULE: moduleinst; }.
28. Perform $initelem(s, moduleinst, i_E*, moduleinst.FUNCS[x]**).
29. Perform $initdata(s, moduleinst, i_D*, b**).
30. Push the evaluation context (FRAME_ 0 { f }) to the stack.
31. Execute the sequence ((CALL x')?).
32. Pop the evaluation context (FRAME_ 0 { f }) from the stack.
33. Return f.MODULE.

invoke s fa val^n
1. Let f be { LOCALS: []; MODULE: { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; EXPORTS: []; }; }.
2. Push the evaluation context (FRAME_ 0 { f }) to the stack.
3. Let t_1^n -> t_2* be $funcinst(z)[fa].TYPE.
4. Pop the evaluation context (FRAME_ 0 { _f }) from the stack.
5. Let k be |t_2*|.
6. Push the evaluation context (FRAME_ k { f }) to the stack.
7. Push the values val^n to the stack.
8. Execute the instruction (CALL_ADDR fa).
9. Pop all values val* from the top of the stack.
10. Pop the evaluation context (FRAME_ k { f }) from the stack.
11. Push the values val* to the stack.
12. Pop the values val^k from the stack.
13. Return val^k.

eval_expr instr*
1. Execute the instruction instr*.
2. Pop the value val from the stack.
3. Return [val].

== Complete.
Generating prose for Wasm 2.0...
watsup 0.4 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...



The limits :math:`({}[~n~..~m~])` is valid with :math:`k` if:


  * :math:`n` is less than or equal to :math:`m`.

  * :math:`m` is less than or equal to :math:`k`.




The function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.




The global type :math:`({\mathsf{mut}^?}, t)` is valid.




The table type :math:`({\mathit{limits}}, {\mathit{reftype}})` is valid if:


  * The limits :math:`{\mathit{limits}}` is valid with :math:`{2^{32}} - 1`.




The memory type :math:`{\mathit{limits}}~\mathsf{page}` is valid if:


  * The limits :math:`{\mathit{limits}}` is valid with :math:`{2^{16}}`.




The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid if:


  * Either:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{functype}})`.

    * The function type :math:`{\mathit{functype}}` is valid.

  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~{\mathit{globaltype}})`.

    * The global type :math:`{\mathit{globaltype}}` is valid.
  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~{\mathit{tabletype}})`.

    * The table type :math:`{\mathit{tabletype}}` is valid.
  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~{\mathit{memtype}})`.

    * The memory type :math:`{\mathit{memtype}}` is valid.




The external type :math:`(\mathsf{func}~{\mathit{functype}})` is valid if:


  * The function type :math:`{\mathit{functype}}` is valid.




The external type :math:`(\mathsf{global}~{\mathit{globaltype}})` is valid if:


  * The global type :math:`{\mathit{globaltype}}` is valid.




The external type :math:`(\mathsf{table}~{\mathit{tabletype}})` is valid if:


  * The table type :math:`{\mathit{tabletype}}` is valid.




The external type :math:`(\mathsf{mem}~{\mathit{memtype}})` is valid if:


  * The memory type :math:`{\mathit{memtype}}` is valid.




The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` matches the value type :math:`t` if:


  * Either:

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`t`.

  * Or:

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{bot}`.




The value type :math:`t` matches itself.




The value type :math:`\mathsf{bot}` matches the value type :math:`t`.




The value type sequence :math:`{t_1^\ast}` matches the value type sequence :math:`{t_2^\ast}` if:


  * :math:`{|t_{\mathit{{\scriptstyle 2}*}}|}` is equal to :math:`{|t_{\mathit{{\scriptstyle 1}*}}|}`.

  * For all :math:`t_1` in :math:`{t_1^\ast}` and :math:`t_2` in :math:`{t_2^\ast}`:

    * The value type :math:`t_1` matches the value type :math:`t_2`.




The limits :math:`({}[~n_{11}~..~n_{12}~])` matches the limits :math:`({}[~n_{21}~..~n_{22}~])` if:


  * :math:`n_{11}` is greater than or equal to :math:`n_{21}`.

  * :math:`n_{12}` is less than or equal to :math:`n_{22}`.




The function type :math:`{\mathit{ft}}` matches itself.




The global type :math:`{\mathit{gt}}` matches itself.




The table type :math:`({\mathit{lim}}_1, {\mathit{rt}})` matches the table type :math:`({\mathit{lim}}_2, {\mathit{rt}})` if:


  * The limits :math:`{\mathit{lim}}_1` matches the limits :math:`{\mathit{lim}}_2`.




The memory type :math:`{\mathit{lim}}_1~\mathsf{page}` matches the memory type :math:`{\mathit{lim}}_2~\mathsf{page}` if:


  * The limits :math:`{\mathit{lim}}_1` matches the limits :math:`{\mathit{lim}}_2`.




The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` matches the external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` if:


  * Either:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{ft}}_1)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{func}~{\mathit{ft}}_2)`.

    * The function type :math:`{\mathit{ft}}_1` matches the function type :math:`{\mathit{ft}}_2`.

  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~{\mathit{gt}}_1)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{global}~{\mathit{gt}}_2)`.

    * The global type :math:`{\mathit{gt}}_1` matches the global type :math:`{\mathit{gt}}_2`.
  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~{\mathit{tt}}_1)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{table}~{\mathit{tt}}_2)`.

    * The table type :math:`{\mathit{tt}}_1` matches the table type :math:`{\mathit{tt}}_2`.
  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~{\mathit{mt}}_1)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{mem}~{\mathit{mt}}_2)`.

    * The memory type :math:`{\mathit{mt}}_1` matches the memory type :math:`{\mathit{mt}}_2`.




The external type :math:`(\mathsf{func}~{\mathit{ft}}_1)` matches the external type :math:`(\mathsf{func}~{\mathit{ft}}_2)` if:


  * The function type :math:`{\mathit{ft}}_1` matches the function type :math:`{\mathit{ft}}_2`.




The external type :math:`(\mathsf{global}~{\mathit{gt}}_1)` matches the external type :math:`(\mathsf{global}~{\mathit{gt}}_2)` if:


  * The global type :math:`{\mathit{gt}}_1` matches the global type :math:`{\mathit{gt}}_2`.




The external type :math:`(\mathsf{table}~{\mathit{tt}}_1)` matches the external type :math:`(\mathsf{table}~{\mathit{tt}}_2)` if:


  * The table type :math:`{\mathit{tt}}_1` matches the table type :math:`{\mathit{tt}}_2`.




The external type :math:`(\mathsf{mem}~{\mathit{mt}}_1)` matches the external type :math:`(\mathsf{mem}~{\mathit{mt}}_2)` if:


  * The memory type :math:`{\mathit{mt}}_1` matches the memory type :math:`{\mathit{mt}}_2`.




The block type :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the function type :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~\rightarrow~{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` if:


  * Either:

    * The block type :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{{\mathit{valtype}}^?}`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`{{\mathit{valtype}}^?}`.

  * Or:

    * The block type :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{typeidx}}`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{t_1^\ast}`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`{t_2^\ast}`.

    * The function type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

    * The function type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is equal to :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The block type :math:`{{\mathit{valtype}}^?}` is valid with the function type :math:`\epsilon~\rightarrow~{{\mathit{valtype}}^?}`.




The block type :math:`{\mathit{typeidx}}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * The function type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

  * The function type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is equal to :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`\mathsf{nop}` is valid with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction :math:`\mathsf{unreachable}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`\mathsf{drop}` is valid with the function type :math:`t~\rightarrow~\epsilon`.




The instruction :math:`(\mathsf{select}~{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?})` is valid with the function type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


  * Either:

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`t`.

  * Or:

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is absent.

    * The value type :math:`t` matches the value type :math:`{t'}`.

    * The value type :math:`{t'}` is equal to :math:`{\mathit{numtype}}` or :math:`{t'}` is equal to :math:`{\mathit{vectype}}`.




The instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * The block type :math:`{\mathit{bt}}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

  * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`(\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * The block type :math:`{\mathit{bt}}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_1^\ast}` prepended to the field :math:`\mathsf{labels}`.

  * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`(\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` is valid with the function type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


  * The block type :math:`{\mathit{bt}}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

  * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_1^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`(\mathsf{br}~l)` is valid with the function type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


  * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

  * The result type :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^\ast}`.




The instruction :math:`(\mathsf{br\_if}~l)` is valid with the function type :math:`{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^\ast}` if:


  * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

  * The result type :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^\ast}`.




The instruction :math:`(\mathsf{br\_table}~{l^\ast}~{l'})` is valid with the function type :math:`{t_1^\ast}~{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


  * For all :math:`l` in :math:`{l^\ast}`:

    * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

  * For all :math:`l` in :math:`{l^\ast}`:

    * The value type sequence :math:`{t^\ast}` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.

  * The result type :math:`C{.}\mathsf{labels}{}[{l'}]` exists.

  * The value type sequence :math:`{t^\ast}` matches the result type :math:`C{.}\mathsf{labels}{}[{l'}]`.




The instruction :math:`(\mathsf{call}~x)` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

  * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`(\mathsf{call\_indirect}~x~y)` is valid with the function type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{lim}}, \mathsf{funcref})`.

  * The function type :math:`C{.}\mathsf{types}{}[y]` exists.

  * The function type :math:`C{.}\mathsf{types}{}[y]` is equal to :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction :math:`\mathsf{return}` is valid with the function type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


  * The result type :math:`C{.}\mathsf{return}` is equal to :math:`{t^\ast}`.




The instruction :math:`({\mathit{nt}}{.}\mathsf{const}~c_{\mathit{nt}})` is valid with the function type :math:`\epsilon~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{unop}}_{\mathit{nt}})` is valid with the function type :math:`{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{binop}}_{\mathit{nt}})` is valid with the function type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{testop}}_{\mathit{nt}})` is valid with the function type :math:`{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{relop}}_{\mathit{nt}})` is valid with the function type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{nt}}_1 {.} {{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is valid with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1` if:


  * Either:

    * :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{reinterpret}`.

    * :math:`{|{\mathit{nt}}_1|}` is equal to :math:`{|{\mathit{nt}}_2|}`.

  * Or:

    * :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{cvtop}}`.




The instruction :math:`(\mathsf{ref{.}null}~{\mathit{rt}})` is valid with the function type :math:`\epsilon~\rightarrow~{\mathit{rt}}`.




The instruction :math:`(\mathsf{ref{.}func}~x)` is valid with the function type :math:`\epsilon~\rightarrow~\mathsf{funcref}` if:


  * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

  * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{\mathit{ft}}`.




The instruction :math:`\mathsf{ref{.}is\_null}` is valid with the function type :math:`{\mathit{rt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` is valid with the function type :math:`\epsilon~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvunop}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvbinop}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvternop}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvtestop}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vunop}}_{\mathit{sh}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vbinop}}_{\mathit{sh}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vtestop}}_{\mathit{sh}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vrelop}}_{\mathit{sh}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vshiftop}}_{\mathit{sh}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{bitmask})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{swizzle})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{shuffle}~{i^\ast})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * For all :math:`i` in :math:`{i^\ast}`:

    * The lane index :math:`i` is less than :math:`2 \cdot {\mathrm{dim}}({\mathit{sh}})`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{splat})` is valid with the function type :math:`t~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * Let :math:`t` be the number type :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({{\mathit{sh}}{.}\mathsf{extract\_lane}}{{{\mathit{sx}}^?}}~i)` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~t` if:


  * The lane index :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.

  * Let :math:`t` be the number type :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{replace\_lane}~i)` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~t~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * The lane index :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.

  * Let :math:`t` be the number type :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`(\mathsf{vextunop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextunop}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{vextbinop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextbinop}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({{\mathit{sh}}_1{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{sh}}_2}{\mathsf{\_}}{{\mathit{sx}}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}_1 {.} {{\mathit{sh}}_2}{\mathsf{\_}}{{\mathit{vcvtop}}}{\mathsf{\_}}{{{\mathit{hf}}^?}}{\mathsf{\_}}{{{\mathit{zero}}^?}})` is valid with the function type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{local{.}get}~x)` is valid with the function type :math:`\epsilon~\rightarrow~t` if:


  * The value type :math:`C{.}\mathsf{locals}{}[x]` exists.

  * The value type :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`t`.




The instruction :math:`(\mathsf{local{.}set}~x)` is valid with the function type :math:`t~\rightarrow~\epsilon` if:


  * The value type :math:`C{.}\mathsf{locals}{}[x]` exists.

  * The value type :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`t`.




The instruction :math:`(\mathsf{local{.}tee}~x)` is valid with the function type :math:`t~\rightarrow~t` if:


  * The value type :math:`C{.}\mathsf{locals}{}[x]` exists.

  * The value type :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`t`.




The instruction :math:`(\mathsf{global{.}get}~x)` is valid with the function type :math:`\epsilon~\rightarrow~t` if:


  * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

  * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`({\mathit{mut}}, t)`.




The instruction :math:`(\mathsf{global{.}set}~x)` is valid with the function type :math:`t~\rightarrow~\epsilon` if:


  * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

  * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`(\mathsf{mut}, t)`.




The instruction :math:`(\mathsf{table{.}get}~x)` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathit{rt}}` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{lim}}, {\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}set}~x)` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{rt}}~\rightarrow~\epsilon` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{lim}}, {\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}size}~x)` is valid with the function type :math:`\epsilon~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{lim}}, {\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}grow}~x)` is valid with the function type :math:`{\mathit{rt}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{lim}}, {\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}fill}~x)` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{rt}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{lim}}, {\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}copy}~x_1~x_2)` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x_1]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x_1]` is equal to :math:`({\mathit{lim}}_1, {\mathit{rt}})`.

  * The table type :math:`C{.}\mathsf{tables}{}[x_2]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x_2]` is equal to :math:`({\mathit{lim}}_2, {\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}init}~x_1~x_2)` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x_1]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x_1]` is equal to :math:`({\mathit{lim}}, {\mathit{rt}})`.

  * The element type :math:`C{.}\mathsf{elems}{}[x_2]` exists.

  * The element type :math:`C{.}\mathsf{elems}{}[x_2]` is equal to :math:`{\mathit{rt}}`.




The instruction :math:`(\mathsf{elem{.}drop}~x)` is valid with the function type :math:`\epsilon~\rightarrow~\epsilon` if:


  * The element type :math:`C{.}\mathsf{elems}{}[x]` exists.

  * The element type :math:`C{.}\mathsf{elems}{}[x]` is equal to :math:`{\mathit{rt}}`.




The instruction :math:`\mathsf{memory{.}size}` is valid with the function type :math:`\epsilon~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.




The instruction :math:`\mathsf{memory{.}grow}` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.




The instruction :math:`\mathsf{memory{.}fill}` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.




The instruction :math:`\mathsf{memory{.}copy}` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.




The instruction :math:`(\mathsf{memory{.}init}~x)` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * The data type :math:`C{.}\mathsf{datas}{}[x]` exists.

  * The data type :math:`C{.}\mathsf{datas}{}[x]` is equal to :math:`\mathsf{ok}`.




The instruction :math:`(\mathsf{data{.}drop}~x)` is valid with the function type :math:`\epsilon~\rightarrow~\epsilon` if:


  * The data type :math:`C{.}\mathsf{datas}{}[x]` exists.

  * The data type :math:`C{.}\mathsf{datas}{}[x]` is equal to :math:`\mathsf{ok}`.




The instruction :math:`({{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{load}}{{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * Either:

    * The number type :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{nt}}`.

    * :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is absent.

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{nt}}`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

  * Or:

    * The number type :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{n}`.

    * :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`(M, {\mathit{sx}})`.

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{n}`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{store}}{{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}~\rightarrow~\epsilon` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * Either:

    * The number type :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{nt}}`.

    * The pack size :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is absent.

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{nt}}`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

  * Or:

    * The number type :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{n}`.

    * The pack size :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`M`.

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{n}`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * Either:

    * :math:`{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`({M}{\mathsf{x}}{\mathsf{x}}{\mathsf{\_}}{N})`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8 \cdot N`.

  * Or:

    * :math:`{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`({n}{\mathsf{\_}}{\mathsf{splat}})`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.
  * Or:

    * :math:`{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`({n}{\mathsf{\_}}{\mathsf{zero}})`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.




The instruction :math:`(\mathsf{vload\_lane}~\mathsf{v{\scriptstyle 128}}~n~{\mathit{memarg}}~{\mathit{laneidx}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.

  * :math:`{\mathit{laneidx}}` is less than :math:`128 / n`.




The instruction :math:`(\mathsf{vstore}~\mathsf{v{\scriptstyle 128}}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|\mathsf{v{\scriptstyle 128}}|} / 8`.




The instruction :math:`(\mathsf{vstore\_lane}~\mathsf{v{\scriptstyle 128}}~n~{\mathit{memarg}}~{\mathit{laneidx}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.

  * :math:`{\mathit{laneidx}}` is less than :math:`128 / n`.




The instruction :math:`(\mathsf{select}~t)` is valid with the function type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t`.




The instruction :math:`(\mathsf{select}~\epsilon)` is valid with the function type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


  * The value type :math:`t` matches the value type :math:`{t'}`.

  * The value type :math:`{t'}` is equal to :math:`{\mathit{numtype}}` or :math:`{t'}` is equal to :math:`{\mathit{vectype}}`.




The instruction :math:`({\mathit{nt}}_1 {.} {\mathsf{reinterpret}}{\mathsf{\_}}{{\mathit{nt}}_2})` is valid with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1` if:


  * :math:`{|{\mathit{nt}}_1|}` is equal to :math:`{|{\mathit{nt}}_2|}`.




The instruction :math:`({\mathit{nt}}_1 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is valid with the function type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1`.




The instruction :math:`({{\mathit{nt}}{.}\mathsf{load}}{\epsilon}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathit{nt}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.




The instruction :math:`({{\mathsf{i}}{n}{.}\mathsf{load}}{(M, {\mathit{sx}})}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~{\mathsf{i}}{n}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({{\mathit{nt}}{.}\mathsf{store}}{\epsilon}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathit{nt}}~\rightarrow~\epsilon` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.




The instruction :math:`({{\mathsf{i}}{n}{.}\mathsf{store}}{M}~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~{\mathsf{i}}{n}~\rightarrow~\epsilon` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~({M}{\mathsf{x}}{\mathsf{x}}{\mathsf{\_}}{N})~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8 \cdot N`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~({n}{\mathsf{\_}}{\mathsf{splat}})~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~({n}{\mathsf{\_}}{\mathsf{zero}})~{\mathit{memarg}})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`n / 8`.




The instruction sequence :math:`{{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is valid with the function type :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~\rightarrow~{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` if:


  * Either:

    * The instruction sequence :math:`{{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`\epsilon`.

  * Or:

    * The instruction sequence :math:`{{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{t_1^\ast}`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`{t_3^\ast}`.

    * The instruction :math:`{\mathit{instr}}_1` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

    * The instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`{t_2^\ast}~\rightarrow~{t_3^\ast}`.
  * Or:

    * The instruction sequence :math:`{{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{{\mathit{instr}}^\ast}`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{{t'}_1^\ast}`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`{{t'}_2^\ast}`.

    * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

    * The value type sequence :math:`{{t'}_1^\ast}` matches the value type sequence :math:`{t_1^\ast}`.

    * The value type sequence :math:`{t_2^\ast}` matches the value type sequence :math:`{{t'}_2^\ast}`.
  * Or:

    * The instruction sequence :math:`{{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{{\mathit{instr}}^\ast}`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{t^\ast}~{t_1^\ast}`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`{t^\ast}~{t_2^\ast}`.

    * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction sequence :math:`\epsilon` is valid with the function type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction sequence :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_3^\ast}` if:


  * The instruction :math:`{\mathit{instr}}_1` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * The instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the function type :math:`{t_2^\ast}~\rightarrow~{t_3^\ast}`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{{t'}_1^\ast}~\rightarrow~{{t'}_2^\ast}` if:


  * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * The value type sequence :math:`{{t'}_1^\ast}` matches the value type sequence :math:`{t_1^\ast}`.

  * The value type sequence :math:`{t_2^\ast}` matches the value type sequence :math:`{{t'}_2^\ast}`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t^\ast}~{t_1^\ast}~\rightarrow~{t^\ast}~{t_2^\ast}` if:


  * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The expression :math:`{{\mathit{instr}}^\ast}` is valid with the result type :math:`{t^\ast}` if:


  * The expression :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`\epsilon~\rightarrow~{t^\ast}`.




:math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is const if:


  * Either:

    * The instruction :math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`({\mathit{nt}}{.}\mathsf{const}~c)`.

  * Or:

    * The instruction :math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`({\mathit{vt}}{.}\mathsf{const}~{\mathit{vc}})`.
  * Or:

    * The instruction :math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref{.}null}~{\mathit{rt}})`.
  * Or:

    * The instruction :math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref{.}func}~x)`.
  * Or:

    * The instruction :math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global{.}get}~x)`.

    * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

    * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`(\epsilon, t)`.




:math:`({\mathit{nt}}{.}\mathsf{const}~c)` is const.




:math:`({\mathit{vt}}{.}\mathsf{const}~{\mathit{vc}})` is const.




:math:`(\mathsf{ref{.}null}~{\mathit{rt}})` is const.




:math:`(\mathsf{ref{.}func}~x)` is const.




:math:`(\mathsf{global{.}get}~x)` is const if:


  * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

  * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`(\epsilon, t)`.




:math:`{{\mathit{instr}}^\ast}` is const if:


  * For all :math:`{\mathit{instr}}` in :math:`{{\mathit{instr}}^\ast}`:

    * :math:`{\mathit{instr}}` is const.




The type :math:`(\mathsf{type}~{\mathit{ft}})` is valid with the function type :math:`{\mathit{ft}}` if:


  * The function type :math:`{\mathit{ft}}` is valid.




The function :math:`(\mathsf{func}~x~{(\mathsf{local}~t)^\ast}~{\mathit{expr}})` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * The function type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The function type :math:`C{.}\mathsf{types}{}[x]` is equal to :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * Under the context :math:`C{}[{.}\mathsf{locals} \mathrel{{=}{\oplus}} {t_1^\ast}~{t^\ast}]{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^\ast}]{}[{.}\mathsf{return} \mathrel{{=}{\oplus}} {t_2^\ast}]`, the expression :math:`{\mathit{expr}}` is valid with the result type :math:`{t_2^\ast}`.




The global :math:`(\mathsf{global}~{\mathit{gt}}~{\mathit{expr}})` is valid with the global type :math:`{\mathit{gt}}` if:


  * The global type :math:`{\mathit{gt}}` is valid.

  * The global type :math:`{\mathit{gt}}` is equal to :math:`({\mathit{mut}}, t)`.

  * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`t`.

  * :math:`{\mathit{expr}}` is const.




The table :math:`(\mathsf{table}~{\mathit{tt}})` is valid with the table type :math:`{\mathit{tt}}` if:


  * The table type :math:`{\mathit{tt}}` is valid.




The memory :math:`(\mathsf{memory}~{\mathit{mt}})` is valid with the memory type :math:`{\mathit{mt}}` if:


  * The memory type :math:`{\mathit{mt}}` is valid.




:math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the reference type :math:`{\mathit{rt}}` if:


  * Either:

    * :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{active}~x~{\mathit{expr}})`.

    * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

    * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{lim}}, {\mathit{rt}})`.

    * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

    * :math:`{\mathit{expr}}` is const.

  * Or:

    * :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{passive}`.
  * Or:

    * :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{declare}`.




:math:`(\mathsf{active}~x~{\mathit{expr}})` is valid with the reference type :math:`{\mathit{rt}}` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{lim}}, {\mathit{rt}})`.

  * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

  * :math:`{\mathit{expr}}` is const.




:math:`\mathsf{passive}` is valid with the reference type :math:`{\mathit{rt}}`.




:math:`\mathsf{declare}` is valid with the reference type :math:`{\mathit{rt}}`.




The table segment :math:`(\mathsf{elem}~{\mathit{rt}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}})` is valid with the reference type :math:`{\mathit{rt}}` if:


  * For all :math:`{\mathit{expr}}` in :math:`{{\mathit{expr}}^\ast}`:

    * The expression :math:`{\mathit{expr}}` is valid with the reference type :math:`{\mathit{rt}}`.

    * :math:`{\mathit{expr}}` is const.

  * :math:`{\mathit{elemmode}}` is valid with the reference type :math:`{\mathit{rt}}`.




:math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid if:


  * Either:

    * :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{active}~0~{\mathit{expr}})`.

    * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

    * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

    * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

    * :math:`{\mathit{expr}}` is const.

  * Or:

    * :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{passive}`.




:math:`(\mathsf{active}~0~{\mathit{expr}})` is valid if:


  * The memory type :math:`C{.}\mathsf{mems}{}[0]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[0]` is equal to :math:`{\mathit{mt}}`.

  * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

  * :math:`{\mathit{expr}}` is const.




:math:`\mathsf{passive}` is valid.




The memory segment :math:`(\mathsf{data}~{b^\ast}~{\mathit{datamode}})` is valid if:


  * :math:`{\mathit{datamode}}` is valid.




The start function :math:`(\mathsf{start}~x)` is valid if:


  * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

  * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`\epsilon~\rightarrow~\epsilon`.




The import :math:`(\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{xt}})` is valid with the external type :math:`{\mathit{xt}}` if:


  * The external type :math:`{\mathit{xt}}` is valid.




The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


  * Either:

    * The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~x)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{ft}})`.

    * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

    * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{\mathit{ft}}`.

  * Or:

    * The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~x)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~{\mathit{gt}})`.

    * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

    * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`{\mathit{gt}}`.
  * Or:

    * The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~x)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~{\mathit{tt}})`.

    * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

    * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`{\mathit{tt}}`.
  * Or:

    * The external index :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~x)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~{\mathit{mt}})`.

    * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

    * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`{\mathit{mt}}`.




The external index :math:`(\mathsf{func}~x)` is valid with the external type :math:`(\mathsf{func}~{\mathit{ft}})` if:


  * The function type :math:`C{.}\mathsf{funcs}{}[x]` exists.

  * The function type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{\mathit{ft}}`.




The external index :math:`(\mathsf{global}~x)` is valid with the external type :math:`(\mathsf{global}~{\mathit{gt}})` if:


  * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

  * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`{\mathit{gt}}`.




The external index :math:`(\mathsf{table}~x)` is valid with the external type :math:`(\mathsf{table}~{\mathit{tt}})` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`{\mathit{tt}}`.




The external index :math:`(\mathsf{mem}~x)` is valid with the external type :math:`(\mathsf{mem}~{\mathit{mt}})` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`{\mathit{mt}}`.




The export :math:`(\mathsf{export}~{\mathit{name}}~{\mathit{externidx}})` is valid with the external type :math:`{\mathit{xt}}` if:


  * The external index :math:`{\mathit{externidx}}` is valid with the external type :math:`{\mathit{xt}}`.




The module :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^{n}}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` is valid if:


  * :math:`{|{\mathit{type*}}|}` is equal to :math:`{|{\mathit{ft'*}}|}`.

  * For all :math:`{\mathit{ft}'}` in :math:`{{\mathit{ft}'}^\ast}` and :math:`{\mathit{type}}` in :math:`{{\mathit{type}}^\ast}`:

    * The type :math:`{\mathit{type}}` is valid with the function type :math:`{\mathit{ft}'}`.

  * :math:`{|{\mathit{ixt*}}|}` is equal to :math:`{|{\mathit{import*}}|}`.

  * For all :math:`{\mathit{import}}` in :math:`{{\mathit{import}}^\ast}` and :math:`{\mathit{ixt}}` in :math:`{{\mathit{ixt}}^\ast}`:

    * Under the context :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon,\; \mathsf{return}~\epsilon \}\end{array}`, the import :math:`{\mathit{import}}` is valid with the external type :math:`{\mathit{ixt}}`.

  * :math:`{|{\mathit{gt*}}|}` is equal to :math:`{|{\mathit{global*}}|}`.

  * For all :math:`{\mathit{global}}` in :math:`{{\mathit{global}}^\ast}` and :math:`{\mathit{gt}}` in :math:`{{\mathit{gt}}^\ast}`:

    * Under the context :math:`{C'}`, the global :math:`{\mathit{global}}` is valid with the global type :math:`{\mathit{gt}}`.

  * :math:`{|{\mathit{tt*}}|}` is equal to :math:`{|{\mathit{table*}}|}`.

  * For all :math:`{\mathit{table}}` in :math:`{{\mathit{table}}^\ast}` and :math:`{\mathit{tt}}` in :math:`{{\mathit{tt}}^\ast}`:

    * Under the context :math:`{C'}`, the table :math:`{\mathit{table}}` is valid with the table type :math:`{\mathit{tt}}`.

  * :math:`{|{\mathit{mt*}}|}` is equal to :math:`{|{\mathit{mem*}}|}`.

  * For all :math:`{\mathit{mem}}` in :math:`{{\mathit{mem}}^\ast}` and :math:`{\mathit{mt}}` in :math:`{{\mathit{mt}}^\ast}`:

    * Under the context :math:`{C'}`, the memory :math:`{\mathit{mem}}` is valid with the memory type :math:`{\mathit{mt}}`.

  * :math:`{|{\mathit{rt*}}|}` is equal to :math:`{|{\mathit{elem*}}|}`.

  * For all :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}` and :math:`{\mathit{rt}}` in :math:`{{\mathit{rt}}^\ast}`:

    * Under the context :math:`{C'}`, the table segment :math:`{\mathit{elem}}` is valid with the reference type :math:`{\mathit{rt}}`.

  * For all :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}`:

    * Under the context :math:`{C'}`, the memory segment :math:`{\mathit{data}}` is valid.

  * :math:`{|{\mathit{func*}}|}` is equal to :math:`{|{\mathit{ft*}}|}`.

  * For all :math:`{\mathit{ft}}` in :math:`{{\mathit{ft}}^\ast}` and :math:`{\mathit{func}}` in :math:`{{\mathit{func}}^\ast}`:

    * The function :math:`{\mathit{func}}` is valid with the function type :math:`{\mathit{ft}}`.

  * If :math:`{\mathit{start}}` is defined, then:

    * The start function :math:`{\mathit{start}}` is valid.

  * :math:`{|{\mathit{xt*}}|}` is equal to :math:`{|{\mathit{export*}}|}`.

  * For all :math:`{\mathit{export}}` in :math:`{{\mathit{export}}^\ast}` and :math:`{\mathit{xt}}` in :math:`{{\mathit{xt}}^\ast}`:

    * The export :math:`{\mathit{export}}` is valid with the external type :math:`{\mathit{xt}}`.

  * :math:`{|{{\mathit{mt}}^\ast}|}` is less than or equal to :math:`1`.

  * The context :math:`C` is equal to :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~{{\mathit{ift}}^\ast}~{{\mathit{ft}}^\ast},\; \mathsf{globals}~{{\mathit{igt}}^\ast}~{{\mathit{gt}}^\ast},\; \mathsf{tables}~{{\mathit{itt}}^\ast}~{{\mathit{tt}}^\ast},\; \mathsf{mems}~{{\mathit{imt}}^\ast}~{{\mathit{mt}}^\ast},\; \mathsf{elems}~{{\mathit{rt}}^\ast},\; \mathsf{datas}~{\mathsf{ok}^{n}},\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon,\; \mathsf{return}~\epsilon \}\end{array}`.

  * The context :math:`{C'}` is equal to :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}'}^\ast},\; \mathsf{funcs}~{{\mathit{ift}}^\ast}~{{\mathit{ft}}^\ast},\; \mathsf{globals}~{{\mathit{igt}}^\ast},\; \mathsf{tables}~{{\mathit{itt}}^\ast}~{{\mathit{tt}}^\ast},\; \mathsf{mems}~{{\mathit{imt}}^\ast}~{{\mathit{mt}}^\ast},\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon,\; \mathsf{return}~\epsilon \}\end{array}`.

  * The function type sequence :math:`{{\mathit{ift}}^\ast}` is equal to :math:`{\mathrm{funcs}}({{\mathit{ixt}}^\ast})`.

  * The global type sequence :math:`{{\mathit{igt}}^\ast}` is equal to :math:`{\mathrm{globals}}({{\mathit{ixt}}^\ast})`.

  * The table type sequence :math:`{{\mathit{itt}}^\ast}` is equal to :math:`{\mathrm{tables}}({{\mathit{ixt}}^\ast})`.

  * The memory type sequence :math:`{{\mathit{imt}}^\ast}` is equal to :math:`{\mathrm{mems}}({{\mathit{ixt}}^\ast})`.


:math:`\mathsf{unreachable}`
............................


1. Trap.


:math:`\mathsf{nop}`
....................


1. Do nothing.


:math:`\mathsf{drop}`
.....................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Do nothing.


:math:`\mathsf{select}~{({t^\ast})^?}`
......................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_2` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_1` from the stack.

#. If :math:`c \neq 0`, then:

  a. Push the value :math:`{\mathit{val}}_1` to the stack.

#. Else:

  a. Push the value :math:`{\mathit{val}}_2` to the stack.


:math:`\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~{{\mathit{instr}}_2^\ast}`
.....................................................................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

  a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast})`.

#. Else:

  a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_2^\ast})`.


:math:`\mathsf{label}`
......................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Pop the current :math:`\mathsf{label}` context from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`\mathsf{br}~n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`
.............................................................


1. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Let :math:`({{\mathsf{label}}_{n}}{\{}~{{\mathit{instr}'}^\ast}~\})` be the current :math:`\mathsf{label}` context.

#. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 0`, then:

  a. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

  #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

  #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

  #. Pop the current :math:`\mathsf{label}` context from the stack.

  #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

  #. Execute the instruction :math:`{{\mathit{instr}'}^\ast}`.

#. Else:

  a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

  #. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}} \geq 1`, then:

    1) Let :math:`l` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}} - 1`.

    #) Pop the current :math:`\mathsf{label}` context from the stack.

    #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

    #) Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{br\_if}~l`
.........................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

  a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

  a. Do nothing.


:math:`\mathsf{br\_table}~{l^\ast}~{l'}`
........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i < {|{l^\ast}|}`, then:

  a. Execute the instruction :math:`(\mathsf{br}~{l^\ast}{}[i])`.

#. Else:

  a. Execute the instruction :math:`(\mathsf{br}~{l'})`.


:math:`\mathsf{frame}`
......................


1. Let :math:`({{\mathsf{frame}}_{n}}{\{}~f~\})` be the current :math:`\mathsf{frame}` context.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{frame}`.

#. Pop the current :math:`\mathsf{frame}` context from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.


:math:`\mathsf{return}`
.......................


1. If the first non-value entry of the stack is a :math:`\mathsf{frame}`, then:

  a. Let :math:`({{\mathsf{frame}}_{n}}{\{}~f~\})` be the current :math:`\mathsf{frame}` context.

  #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

  #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

  #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

  #. Pop the current :math:`\mathsf{frame}` context from the stack.

  #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Else if the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

  a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

  #. Pop the current :math:`\mathsf{label}` context from the stack.

  #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Execute the instruction :math:`\mathsf{return}`.


:math:`{\mathit{nt}} {.} {\mathit{unop}}`
.........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{unop}}}{{}_{{\mathit{nt}}}}{(c_1)}|} \leq 0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{unop}}}{{}_{{\mathit{nt}}}}{(c_1)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{binop}}`
..........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{numtype}}_0` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{binop}}}{{}_{{\mathit{nt}}}}{(c_1, c_2)}|} \leq 0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{binop}}}{{}_{{\mathit{nt}}}}{(c_1, c_2)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{testop}}`
...........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{testop}}}{{}_{{\mathit{nt}}}}{(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{relop}}`
..........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{numtype}}_0` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{relop}}}{{}_{{\mathit{nt}}}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}}_2 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_1}`
............................................................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}_1` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}}{(c_1)}|} \leq 0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}}{(c_1)}`.

#. Push the value :math:`({\mathit{nt}}_2{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{ref{.}is\_null}`
...............................


1. Assert: Due to validation, a :ref:`reference <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. If :math:`{\mathit{ref}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvunop}}`
..........................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vvunop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvbinop}}`
...........................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vvbinop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvternop}}`
............................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_3)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vvternop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2, c_3)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} \mathsf{any\_true}`
...........................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{ine}}}_{{|\mathsf{v{\scriptstyle 128}}|}}(c_1, 0)`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vunop}}`
..........................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{vunop}}}{{}_{{\mathit{sh}}}}{(c_1)}|} \leq 0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vunop}}}{{}_{{\mathit{sh}}}}{(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vbinop}}`
...........................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}}{(c_1, c_2)}|} \leq 0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N} {.} \mathsf{all\_true}`
...............................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c)`.

#. If :math:`{({\mathit{ci}}_1 \neq 0)^\ast}`, then:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vrelop}}`
...........................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vrelop}}}{{}_{{\mathit{sh}}}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N} {.} {\mathit{vshiftop}}`
................................................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`{{c'}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_1)`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{{\mathit{vshiftop}}}{\mathsf{\_}}~{{\mathsf{i}}{n}}{\mathsf{x}}{N}}{({c'}, n)}^\ast})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{bitmask}`
...........................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c)`.

#. Let :math:`{\mathit{ci}}` be the result for which :math:`{{\mathrm{bits}}}_{{\mathsf{i}}{32}}({\mathit{ci}})` :math:`=` :math:`{{{{{\mathrm{ilt}}}_{{|{\mathsf{i}}{n}|}}^{\mathsf{s}}}}{({\mathit{ci}}_1, 0)}^\ast}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{\mathit{ci}})` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{M}{.}\mathsf{swizzle}`
...........................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`{{c'}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c_1)~{0^{256 - M}}`.

#. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c_2)`.

#. Assert: Due to validation, :math:`{({{\mathit{ci}}^\ast}{}[k] < {|{{c'}^\ast}|})^{k<M}}`.

#. Assert: Due to validation, :math:`{(k < {|{{\mathit{ci}}^\ast}|})^{k<M}}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{c'}^\ast}{}[{{\mathit{ci}}^\ast}{}[k]]^{k<M}})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{shuffle}~{i^\ast}`
....................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{(k < {|{i^\ast}|})^{k<N}}`.

#. Let :math:`{{c'}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_1)~{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_2)`.

#. Assert: Due to validation, :math:`{({i^\ast}{}[k] < {|{{c'}^\ast}|})^{k<N}}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{c'}^\ast}{}[{i^\ast}{}[k]]^{k<N}})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{splat}`
.........................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = {\mathrm{unpack}}({\mathsf{i}}{n})`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{\mathrm{pack}}}_{{\mathsf{i}}{n}}(c_1)^{N}})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{N}{.}\mathsf{extract\_lane}}{{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~i`
......................................................................................................................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined and the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

  a. Let :math:`{\mathit{nt}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`i < {|{{\mathrm{lanes}}}_{{{\mathit{nt}}}{\mathsf{x}}{N}}(c_1)|}`, then:

    1) Let :math:`c_2` be :math:`{{\mathrm{lanes}}}_{{{\mathit{nt}}}{\mathsf{x}}{N}}(c_1){}[i]`.

    #) Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c_2)` to the stack.

#. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type, then:

  a. Let :math:`{\mathit{pt}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

    1) Let :math:`{\mathit{sx}}` be :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

    #) If :math:`i < {|{{\mathrm{lanes}}}_{{{\mathit{pt}}}{\mathsf{x}}{N}}(c_1)|}`, then:

      a) Let :math:`c_2` be :math:`{{{{\mathrm{extend}}}_{{|{\mathit{pt}}|}, 32}^{{\mathit{sx}}}}}{({{\mathrm{lanes}}}_{{{\mathit{pt}}}{\mathsf{x}}{N}}(c_1){}[i])}`.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c_2)` to the stack.


:math:`{{\mathsf{i}}{n}}{\mathsf{x}}{N}{.}\mathsf{replace\_lane}~i`
...................................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = {\mathrm{unpack}}({\mathsf{i}}{n})`.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}(c_1){}[{}[i] = {{\mathrm{pack}}}_{{\mathsf{i}}{n}}(c_2)])`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{vextunop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextunop}}`
.............................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{vextunop}}}_{{\mathit{sh}}_1, {\mathit{sh}}_2}({\mathit{vextunop}}, c_1)`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{vextbinop}~{\mathit{sh}}_1~{\mathit{sh}}_2~{\mathit{vextbinop}}`
...............................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{vextbinop}}}_{{\mathit{sh}}_1, {\mathit{sh}}_2}({\mathit{vextbinop}}, c_1, c_2)`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{N_2}{.}\mathsf{narrow}}{\mathsf{\_}}{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{N_1}}{\mathsf{\_}}{{\mathit{sx}}}`
...................................................................................................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{N_1}}(c_1)`.

#. Let :math:`{{\mathit{ci}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{N_1}}(c_2)`.

#. Let :math:`{{\mathit{cj}}_1^\ast}` be :math:`{{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{n}}_1|}, {|{{\mathsf{i}}{n}}_2|}}^{{\mathit{sx}}}}}{{\mathit{ci}}_1}^\ast}`.

#. Let :math:`{{\mathit{cj}}_2^\ast}` be :math:`{{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{n}}_1|}, {|{{\mathsf{i}}{n}}_2|}}^{{\mathit{sx}}}}}{{\mathit{ci}}_2}^\ast}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{N_2}}({{\mathit{cj}}_1^\ast}~{{\mathit{cj}}_2^\ast})`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}} {.} {{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}}{\mathsf{x}}{n_{\mathit{u{\kern-0.1em\scriptstyle 2}}}}}{\mathsf{\_}}{{\mathit{vcvtop}}}{\mathsf{\_}}{{{\mathit{hf}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}{\mathsf{\_}}{{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}`
.............................................................................................................................................................................................................................................................................................................................................................................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{hf}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined and :math:`{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`M` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. If :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = M`, then:

    1) Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M}}(c_1)`.

    #) Let :math:`{{{\mathit{cj}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{vcvtop}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M}, {{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M}}({\mathit{vcvtop}}, {\mathit{ci}})^\ast}`.

    #) If :math:`{|{{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M}}({{\mathit{cj}}^\ast})^\ast}|} > 0`, then:

      a) Let :math:`c` be an element of :math:`{{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M}}({{\mathit{cj}}^\ast})^\ast}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. If :math:`{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`M_1` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. Let :math:`M_2` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{{\mathit{hf}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

    1) Let :math:`{\mathit{half}}` be :math:`{{\mathit{hf}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

    #) Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}}(c_1){}[{\mathrm{half}}({\mathit{half}}, 0, M_2) : M_2]`.

    #) Let :math:`{{{\mathit{cj}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{vcvtop}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}, {\mathit{ci}})^\ast}`.

    #) If :math:`{|{{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}({{\mathit{cj}}^\ast})^\ast}|} > 0`, then:

      a) Let :math:`c` be an element of :math:`{{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}({{\mathit{cj}}^\ast})^\ast}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. If :math:`{{\mathit{hf}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Let :math:`M_1` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. Let :math:`M_2` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is number type, then:

    1) Let :math:`{\mathit{nt}}_1` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

    #) If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

      a) Let :math:`{\mathit{nt}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) If :math:`{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

        1. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathit{nt}}_1}{\mathsf{x}}{M_1}}(c_1)`.

        #. Let :math:`{{{\mathit{cj}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{vcvtop}}}_{{{\mathit{nt}}_1}{\mathsf{x}}{M_1}, {{\mathit{nt}}_2}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}, {\mathit{ci}})^\ast}~{{\mathrm{zero}}({\mathit{nt}}_2)^{M_1}}`.

        #. If :math:`{|{{{\mathrm{invlanes}}}_{{{\mathit{nt}}_2}{\mathsf{x}}{M_2}}({{\mathit{cj}}^\ast})^\ast}|} > 0`, then:

          a. Let :math:`c` be an element of :math:`{{{\mathrm{invlanes}}}_{{{\mathit{nt}}_2}{\mathsf{x}}{M_2}}({{\mathit{cj}}^\ast})^\ast}`.

          #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{local{.}tee}~x`
..............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Execute the instruction :math:`(\mathsf{local{.}set}~x)`.


:math:`\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
............................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{k}}~\rightarrow~{t_2^{n}}` be :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Enter :math:`{{\mathit{val}}^{k}}~{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{n}}{\{}~\epsilon~\})`.


:math:`\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
...........................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{k}}~\rightarrow~{t_2^{n}}` be :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Enter :math:`{{\mathit{val}}^{k}}~{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{k}}{\{}~(\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast})~\})`.


:math:`\mathsf{call}~x`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Execute the instruction :math:`(\mathsf{call}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])`.


:math:`\mathsf{call\_indirect}~x~y`
...................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]` is not of the case :math:`\mathsf{ref{.}func\_addr}`, then:

  a. Trap.

#. Let :math:`(\mathsf{ref{.}func\_addr}~a)` be :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]`.

#. If :math:`a \geq {|z{.}\mathsf{funcs}|}`, then:

  a. Trap.

#. If :math:`z{.}\mathsf{types}{}[y] \neq z{.}\mathsf{funcs}{}[a]{.}\mathsf{type}`, then:

  a. Trap.

#. Execute the instruction :math:`(\mathsf{call}~a)`.


:math:`\mathsf{call}~a`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{funcs}|}`.

#. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{t_1^{k}}~\rightarrow~{t_2^{n}},\; \mathsf{module}~{\mathit{mm}},\; \mathsf{code}~{\mathit{func}} \}\end{array}` be :math:`z{.}\mathsf{funcs}{}[a]`.

#. Assert: Due to validation, :math:`{\mathit{func}}` is of the case :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~x~{{\mathit{local}}_0^\ast}~{{\mathit{instr}}^\ast})` be :math:`{\mathit{func}}`.

#. Assert: Due to validation, for all :math:`{\mathit{local}}_0` in :math:`{{\mathit{local}}_0^\ast}`, :math:`{\mathit{local}}_0` is of the case :math:`\mathsf{local}`.

#. Let :math:`{(\mathsf{local}~t)^\ast}` be :math:`{{\mathit{local}}_0^\ast}`.

#. Assert: Due to validation, there are at least :math:`k` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~{{\mathit{val}}^{k}}~{{{\mathrm{default}}}_{t}^\ast},\; \mathsf{module}~{\mathit{mm}} \}\end{array}`.

#. Push the evaluation context :math:`({{\mathsf{frame}}_{n}}{\{}~f~\})` to the stack.

#. Enter :math:`{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{n}}{\{}~\epsilon~\})`.


:math:`\mathsf{ref{.}func}~x`
.............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])` to the stack.


:math:`\mathsf{local{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{locals}{}[x]` to the stack.


:math:`\mathsf{global{.}get}~x`
...............................


1. Let :math:`z` be the current state.

#. Push the value :math:`z{.}\mathsf{globals}{}[x]{.}\mathsf{value}` to the stack.


:math:`\mathsf{table{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. Push the value :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]` to the stack.


:math:`\mathsf{table{.}size}~x`
...............................


1. Let :math:`z` be the current state.

#. Let :math:`n` be :math:`{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{table{.}fill}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`n = 0`, then:

  a. Do nothing.

#. Else:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

  #. Push the value :math:`{\mathit{val}}` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Push the value :math:`{\mathit{val}}` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}fill}~x)`.


:math:`\mathsf{table{.}copy}~x~y`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{tables}{}[y]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`n = 0`, then:

  a. Do nothing.

#. Else:

  a. If :math:`j \leq i`, then:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

    #) Execute the instruction :math:`(\mathsf{table{.}get}~y)`.

    #) Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Else:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + n - 1)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + n - 1)` to the stack.

    #) Execute the instruction :math:`(\mathsf{table{.}get}~y)`.

    #) Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}copy}~x~y)`.


:math:`\mathsf{table{.}init}~x~y`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`n = 0`, then:

  a. Do nothing.

#. Else if :math:`i < {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

  #. Push the value :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[i]` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}init}~x~y)`.


:math:`{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{load}}{{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}}~{\mathit{ao}}`
..................................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Let :math:`{\mathit{nt}}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

    1) Trap.

  #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathit{nt}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}}|} / 8]`.

  #. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.

#. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. If :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

    1) Let :math:`{\mathit{loadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}`.

    #) Let :math:`(n, {\mathit{sx}})` be :math:`{\mathit{loadop\_{\scriptstyle 0}}}`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      a) Trap.

  #. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

    1) Let :math:`{\mathit{loadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{loadop\_u{\kern-0.1em\scriptstyle 1}}}^?}`.

    #) Let :math:`(n, {\mathit{sx}})` be :math:`{\mathit{loadop\_{\scriptstyle 0}}}`.

    #) Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]`.

    #) Push the value :math:`({\mathsf{i}}{n}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{n, {|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{(c)})` to the stack.


:math:`\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}~{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}~{\mathit{ao}}`
.................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}` and :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Trap.

#. If :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8]`.

  #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. Else:

  a. Let :math:`{\mathit{vloadop}}_0` be :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

  #. If :math:`{\mathit{vloadop}}_0` is of the case :math:`\mathsf{shape}`, then:

    1) Let :math:`({M}{\mathsf{x}}{\mathsf{x}}{\mathsf{\_}}{N})` be :math:`{\mathit{vloadop}}_0`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + M \cdot N / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      a) Trap.

    #) Let :math:`{j^{N}}` be the result for which :math:`{({{\mathrm{bytes}}}_{{\mathsf{i}}{M}}({j^{N}}) = z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} + k \cdot M / 8 : M / 8])^{k<N}}`.

    #) If the type of :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`M \cdot 2` is Jnn, then:

      a) Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`M \cdot 2`.

      #) Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{N}}({{{{{\mathrm{extend}}}_{M, {|{\mathsf{i}}{n}|}}^{{\mathit{sx}}}}}{(j)}^{N}})`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

  #. If :math:`{\mathit{vloadop}}_0` is of the case :math:`\mathsf{splat}`, then:

    1) Let :math:`({N}{\mathsf{\_}}{\mathsf{splat}})` be :math:`{\mathit{vloadop}}_0`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      a) Trap.

    #) Let :math:`M` be :math:`128 / N`.

    #) If the type of :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`N` is Jnn, then:

      a) Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`N`.

      #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

      #) Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({j^{M}})`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

  #. If :math:`{\mathit{vloadop}}_0` is of the case :math:`\mathsf{zero}`, then:

    1) Let :math:`({N}{\mathsf{\_}}{\mathsf{zero}})` be :math:`{\mathit{vloadop}}_0`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      a) Trap.

    #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

    #) Let :math:`c` be :math:`{{{{\mathrm{extend}}}_{N, 128}^{\mathsf{u}}}}{(j)}`.

    #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{vload\_lane}~\mathsf{v{\scriptstyle 128}}~N~{\mathit{ao}}~j`
...........................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. Let :math:`M` be :math:`128 / N`.

#. If the type of :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`N` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`N`.

  #. Let :math:`k` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(k)` :math:`=` :math:`z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

  #. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c_1){}[{}[j] = k])`.

  #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{memory{.}size}`
..............................


1. Let :math:`z` be the current state.

#. Let :math:`n \cdot 64 \cdot {\mathrm{Ki}}` be :math:`{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{memory{.}fill}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`n = 0`, then:

  a. Do nothing.

#. Else:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

  #. Push the value :math:`{\mathit{val}}` to the stack.

  #. Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8})`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Push the value :math:`{\mathit{val}}` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`\mathsf{memory{.}fill}`.


:math:`\mathsf{memory{.}copy}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`n = 0`, then:

  a. Do nothing.

#. Else:

  a. If :math:`j \leq i`, then:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

    #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{(8, \mathsf{u})})`.

    #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8})`.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Else:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + n - 1)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + n - 1)` to the stack.

    #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{(8, \mathsf{u})})`.

    #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8})`.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`\mathsf{memory{.}copy}`.


:math:`\mathsf{memory{.}init}~x`
................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{datas}{}[x]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`n = 0`, then:

  a. Do nothing.

#. Else if :math:`i < {|z{.}\mathsf{datas}{}[x]{.}\mathsf{bytes}|}`, then:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~z{.}\mathsf{datas}{}[x]{.}\mathsf{bytes}{}[i])` to the stack.

  #. Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8})`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{memory{.}init}~x)`.


:math:`\mathsf{local{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{locals}{}[x] = {\mathit{val}}]`.


:math:`\mathsf{global{.}set}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = {\mathit{val}}]`.


:math:`\mathsf{table{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a :ref:`reference <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. Perform :math:`z{}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = {\mathit{ref}}]`.


:math:`\mathsf{table{.}grow}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a :ref:`reference <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Either:

  a. Let :math:`{\mathit{ti}}` be :math:`{\mathrm{growtable}}(z{.}\mathsf{tables}{}[x], n, {\mathit{ref}})`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|})` to the stack.

  #. Perform :math:`z{}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`.

#. Or:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{32}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{elem{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Perform :math:`z{}[{.}\mathsf{elems}{}[x]{.}\mathsf{refs} = \epsilon]`.


:math:`{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{store}}{{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~{\mathit{ao}}`
.........................................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Let :math:`{\mathit{nt}}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}` and :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = {\mathit{nt}}` and :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Trap.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = {\mathit{nt}}` and :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathit{nt}}}(c)`.

  #. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}}|} / 8] = {b^\ast}]`.

#. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = {\mathsf{i}}{n}` and :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

    1) Let :math:`n` be :math:`{{\mathit{sz}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

      a) Trap.

    #) Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}({{\mathrm{wrap}}}_{{|{\mathsf{i}}{n}|}, n}(c))`.

    #) Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8] = {b^\ast}]`.


:math:`\mathsf{vstore}~\mathsf{v{\scriptstyle 128}}~{\mathit{ao}}`
..................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8 > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)`.

#. Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8] = {b^\ast}]`.


:math:`\mathsf{vstore\_lane}~\mathsf{v{\scriptstyle 128}}~N~{\mathit{ao}}~j`
............................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N > {|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. Let :math:`M` be :math:`128 / N`.

#. If the type of :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`N` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`N`.

  #. If :math:`j < {|{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c)|}`, then:

    1) Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}(c){}[j])`.

    #) Perform :math:`z{}[{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8] = {b^\ast}]`.


:math:`\mathsf{memory{.}grow}`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Either:

  a. Let :math:`{\mathit{mi}}` be :math:`{\mathrm{growmemory}}(z{.}\mathsf{mems}{}[0], n)`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{mems}{}[0]{.}\mathsf{bytes}|} / 64 \, {\mathrm{Ki}})` to the stack.

  #. Perform :math:`z{}[{.}\mathsf{mems}{}[0] = {\mathit{mi}}]`.

#. Or:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{32}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{data{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Perform :math:`z{}[{.}\mathsf{datas}{}[x]{.}\mathsf{bytes} = \epsilon]`.


:math:`{\mathrm{Ki}}`
.....................


1. Return :math:`1024`.


:math:`{\mathrm{min}}(i, j)`
............................


1. If :math:`i \leq j`, then:

  a. Return :math:`i`.

#. Return :math:`j`.


:math:`{\mathrm{sum}}({n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................


1. If :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`0`.

#. Let :math:`n~{{n'}^\ast}` be :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`n + {\mathrm{sum}}({{n'}^\ast})`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`
........................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} = 1`.

#. Let :math:`w` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`w`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`
.....................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Return :math:`\epsilon`.

#. Let :math:`w` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

#. Return :math:`w`.


:math:`{\mathrm{concat}}({X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
...........................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{w^\ast}~{{{w'}^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{w^\ast}~{\mathrm{concat}}({{{w'}^\ast}^\ast})`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{{\mathit{TODO}}}(w_1, {X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
...................................................................................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{{w'}^\ast}~{{w^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`w_1~{{w'}^\ast}~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{{\mathit{TODO}}}(w_1, {{w^\ast}^\ast})`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{{\mathit{TODO}}}({X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {{w^\ast}^\ast})`
...............................................................................................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{{\mathit{TODO}}}(w_1, {{w^\ast}^\ast})~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{{\mathit{TODO}}}({{w'}^\ast}, {{w^\ast}^\ast})`.


:math:`\Large\times~{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`
.....................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{w_1^\ast}~{{w^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{{\mathit{TODO}}}({w_1^\ast}, \Large\times~{{w^\ast}^\ast})`.


:math:`{\mathrm{signif}}(N_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
....................................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 32`, then:

  a. Return :math:`23`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 64`.

#. Return :math:`52`.


:math:`{\mathrm{expon}}(N_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
...................................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 32`, then:

  a. Return :math:`8`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 64`.

#. Return :math:`11`.


:math:`M`
.........


1. Return :math:`{\mathrm{signif}}(N)`.


:math:`E`
.........


1. Return :math:`{\mathrm{expon}}(N)`.


:math:`{+0}`
............


1. Return :math:`({+((0 + 0 \cdot {2^{{-M}}}) \cdot {2^{e}})})`.


:math:`{+1}`
............


1. Return :math:`({+((1 + 1 \cdot {2^{{-M}}}) \cdot {2^{0}})})`.


:math:`{{\mathrm{canon}}}_{N}`
..............................


1. Return :math:`{2^{{\mathrm{signif}}(N) - 1}}`.


:math:`{|t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}|}`
.....................................................


1. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 32}}`, then:

  a. Return :math:`32`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 64}}`, then:

  a. Return :math:`64`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 32}}`, then:

  a. Return :math:`32`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 64}}`, then:

  a. Return :math:`64`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{v{\scriptstyle 128}}`, then:

  a. Return :math:`128`.


:math:`{|{\mathsf{i}}{n}|}`
...........................


1. Return :math:`{|{\mathsf{i}}{n}|}`.


:math:`{|{\mathit{pt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}|}`
.................................................................


1. If :math:`{\mathit{pt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 8}}`, then:

  a. Return :math:`8`.

#. Assert: Due to validation, :math:`{\mathit{pt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 16}}`.

#. Return :math:`16`.


:math:`{|{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}|}`
.................................................................


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{|{\mathit{numtype}}|}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{|{\mathit{packtype}}|}`.


:math:`{\mathrm{lanetype}}({{\mathsf{i}}{n}}{\mathsf{x}}{N})`
.............................................................


1. Return :math:`{\mathsf{i}}{n}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`{\mathrm{zero}}({\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
..............................................................................


1. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Return :math:`0`.

#. Assert: Due to validation, the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{+0}`.


:math:`{\mathrm{dim}}({{\mathsf{i}}{n}}{\mathsf{x}}{N})`
........................................................


1. Return :math:`N`.


:math:`{|{{\mathsf{i}}{n}}{\mathsf{x}}{N}|}`
............................................


1. Return :math:`{|{\mathsf{i}}{n}|} \cdot N`.


:math:`{\mathrm{concat}}({b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
...........................................................................


1. If :math:`{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{b^\ast}~{{{b'}^\ast}^\ast}` be :math:`{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{b^\ast}~{\mathrm{concat}}({{{b'}^\ast}^\ast})`.


:math:`{\mathrm{unpack}}({\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
................................................................................


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathit{numtype}}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Return :math:`\mathsf{i{\scriptstyle 32}}`.


:math:`{\mathrm{unpack}}({{\mathsf{i}}{n}}{\mathsf{x}}{N})`
...........................................................


1. Return :math:`{\mathrm{unpack}}({\mathsf{i}}{n})`.


:math:`{\mathrm{funcs}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
......................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{ft}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{ft}}~{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{gt}}~{\mathrm{globals}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{tt}}~{\mathrm{tables}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{mt}}~{\mathrm{mems}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{dataidx}}({\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
.................................................................................


1. If :math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{memory{.}init}`, then:

  a. Let :math:`(\mathsf{memory{.}init}~x)` be :math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`x`.

#. If :math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{data{.}drop}`, then:

  a. Let :math:`(\mathsf{data{.}drop}~x)` be :math:`{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`x`.

#. Return :math:`\epsilon`.


:math:`{\mathrm{dataidx}}({{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{instr}}~{{\mathit{instr}'}^\ast}` be :math:`{{\mathit{in}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{dataidx}}({\mathit{instr}})~{\mathrm{dataidx}}({{\mathit{instr}'}^\ast})`.


:math:`{\mathrm{dataidx}}({{\mathit{in}}^\ast})`
................................................


1. Return :math:`{\mathrm{dataidx}}({{\mathit{in}}^\ast})`.


:math:`{\mathrm{dataidx}}((\mathsf{func}~x~{{\mathit{loc}}^\ast}~e))`
.....................................................................


1. Return :math:`{\mathrm{dataidx}}(e)`.


:math:`{\mathrm{dataidx}}({{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
..........................................................................................


1. If :math:`{{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{func}}~{{\mathit{func}'}^\ast}` be :math:`{{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{dataidx}}({\mathit{func}})~{\mathrm{dataidx}}({{\mathit{func}'}^\ast})`.






1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{align}~0,\; \mathsf{offset}~0 \}\end{array}`.


:math:`{{\mathrm{signed}}}_{N}(i)`
..................................


1. If :math:`i < {2^{N - 1}}`, then:

  a. Return :math:`i`.

#. Assert: Due to validation, :math:`{2^{N - 1}} \leq i`.

#. Assert: Due to validation, :math:`i < {2^{N}}`.

#. Return :math:`i - {2^{N}}`.


:math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{(i)}`
...............................................


1. Let :math:`j` be the result for which :math:`{{\mathrm{signed}}}_{N}(j)` :math:`=` :math:`i`.

#. Return :math:`j`.


:math:`{{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{(i_{\mathit{u{\kern-0.1em\scriptstyle 1}}})}`
..........................................................................................................................................................................


1. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{clz}`, then:

    1) Return :math:`{{\mathrm{iclz}}}_{N}({\mathit{iN}})`.

  #. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ctz}`, then:

    1) Return :math:`{{\mathrm{ictz}}}_{N}({\mathit{iN}})`.

  #. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{popcnt}`, then:

    1) Return :math:`{{\mathrm{ipopcnt}}}_{N}({\mathit{iN}})`.

  #. Assert: Due to validation, :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{extend}`.

  #. Let :math:`(\mathsf{extend}~M)` be :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{{{\mathrm{extend}}}_{M, N}^{\mathsf{s}}}}{({{\mathrm{wrap}}}_{N, M}({\mathit{iN}}))}`.

#. Assert: Due to validation, the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{abs}`, then:

  a. Return :math:`{{\mathrm{fabs}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{neg}`, then:

  a. Return :math:`{{\mathrm{fneg}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sqrt}`, then:

  a. Return :math:`{{\mathrm{fsqrt}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ceil}`, then:

  a. Return :math:`{{\mathrm{fceil}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{floor}`, then:

  a. Return :math:`{{\mathrm{ffloor}}}_{N}({\mathit{fN}})`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{trunc}`, then:

  a. Return :math:`{{\mathrm{ftrunc}}}_{N}({\mathit{fN}})`.

#. Assert: Due to validation, :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{nearest}`.

#. Return :math:`{{\mathrm{fnearest}}}_{N}({\mathit{fN}})`.


:math:`{{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{(i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, i_{\mathit{u{\kern-0.1em\scriptstyle 2}}})}`
......................................................................................................................................................................................................................


1. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

    1) Return :math:`{{\mathrm{iadd}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

    1) Return :math:`{{\mathrm{isub}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

    1) Return :math:`{{\mathrm{imul}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{div}`, then:

    1) Let :math:`({\mathsf{div}}{{\mathit{sx}}})` be :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{idiv}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{rem}`, then:

    1) Let :math:`({\mathsf{rem}}{{\mathit{sx}}})` be :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{irem}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{and}`, then:

    1) Return :math:`{{\mathrm{iand}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{or}`, then:

    1) Return :math:`{{\mathrm{ior}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{xor}`, then:

    1) Return :math:`{{\mathrm{ixor}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{shl}`, then:

    1) Return :math:`{{\mathrm{ishl}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{shr}`, then:

    1) Let :math:`({\mathsf{shr}}{{\mathit{sx}}})` be :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{ishr}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{rotl}`, then:

    1) Return :math:`{{\mathrm{irotl}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{rotr}`, then:

    1) Return :math:`{{\mathrm{irotr}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

#. Assert: Due to validation, the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_2` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

  a. Return :math:`{{\mathrm{fadd}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

  a. Return :math:`{{\mathrm{fsub}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

  a. Return :math:`{{\mathrm{fmul}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{div}`, then:

  a. Return :math:`{{\mathrm{fdiv}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{min}`, then:

  a. Return :math:`{{\mathrm{fmin}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{max}`, then:

  a. Return :math:`{{\mathrm{fmax}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{copysign}`.

#. Return :math:`{{\mathrm{fcopysign}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.


:math:`{\mathsf{eqz}}{{}_{{\mathsf{i}}{n}}}{({\mathit{iN}})}`
.............................................................


1. Return :math:`{{\mathrm{ieqz}}}_{N}({\mathit{iN}})`.


:math:`{{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}{(i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, i_{\mathit{u{\kern-0.1em\scriptstyle 2}}})}`
......................................................................................................................................................................................................................


1. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{\mathit{iN}}_2` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

    1) Return :math:`{{\mathrm{ieq}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

    1) Return :math:`{{\mathrm{ine}}}_{N}({\mathit{iN}}_1, {\mathit{iN}}_2)`.

  #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{lt}`, then:

    1) Let :math:`({\mathsf{lt}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{gt}`, then:

    1) Let :math:`({\mathsf{gt}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{le}`, then:

    1) Let :math:`({\mathsf{le}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

  #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ge}`, then:

    1) Let :math:`({\mathsf{ge}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}}}}{({\mathit{iN}}_1, {\mathit{iN}}_2)}`.

#. Assert: Due to validation, the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_2` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

  a. Return :math:`{{\mathrm{feq}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

  a. Return :math:`{{\mathrm{fne}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{lt}`, then:

  a. Return :math:`{{\mathrm{flt}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{gt}`, then:

  a. Return :math:`{{\mathrm{fgt}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{le}`, then:

  a. Return :math:`{{\mathrm{fle}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ge}`.

#. Return :math:`{{\mathrm{fge}}}_{N}({\mathit{fN}}_1, {\mathit{fN}}_2)`.


:math:`{{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, {\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}}}{(i_{\mathit{u{\kern-0.1em\scriptstyle 1}}})}`
..................................................................................................................................................................................................................................


1. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Inn, then:

    1) Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{extend}`, then:

      a) Let :math:`(\mathsf{extend}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{\mathit{iN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

    #) Let :math:`{\mathit{iN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{wrap}`, then:

      a) Return :math:`{{\mathrm{wrap}}}_{N_1, N_2}({\mathit{iN}}_1)`.

#. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{n}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Inn, then:

    1) Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{trunc}`, then:

      a) Let :math:`(\mathsf{trunc}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{\mathit{fN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{trunc}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{fN}}_1)}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{trunc\_sat}`, then:

      a) Let :math:`(\mathsf{trunc\_sat}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{\mathit{fN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{fN}}_1)}`.

#. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Fnn, then:

    1) Let :math:`{{\mathsf{f}}{n}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{convert}`, then:

      a) Let :math:`(\mathsf{convert}~{\mathit{sx}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{\mathit{iN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

#. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{n}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Fnn, then:

    1) Let :math:`{{\mathsf{f}}{n}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

    #) Let :math:`{\mathit{fN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{promote}`, then:

      a) Return :math:`{{\mathrm{promote}}}_{N_1, N_2}({\mathit{fN}}_1)`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{demote}`, then:

      a) Return :math:`{{\mathrm{demote}}}_{N_1, N_2}({\mathit{fN}}_1)`.

#. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Fnn, then:

    1) Let :math:`{{\mathsf{f}}{n}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

    #) Let :math:`{\mathit{iN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{reinterpret}` and :math:`{|{{\mathsf{i}}{n}}_1|} = {|{{\mathsf{f}}{n}}_2|}`, then:

      a) Return :math:`{{\mathrm{reinterpret}}}_{{{\mathsf{i}}{n}}_1, {{\mathsf{f}}{n}}_2}({\mathit{iN}}_1)`.

#. Assert: Due to validation, the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{{\mathsf{f}}{n}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Inn.

#. Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{reinterpret}`.

#. Assert: Due to validation, :math:`{|{{\mathsf{f}}{n}}_1|} = {|{{\mathsf{i}}{n}}_2|}`.

#. Return :math:`{{\mathrm{reinterpret}}}_{{{\mathsf{f}}{n}}_1, {{\mathsf{i}}{n}}_2}({\mathit{fN}}_1)`.


:math:`{{\mathrm{invibytes}}}_{N}({b^\ast})`
............................................


1. Let :math:`n` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(n)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`n`.


:math:`{{\mathrm{invfbytes}}}_{N}({b^\ast})`
............................................


1. Let :math:`p` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{f}}{N}}(p)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`p`.


:math:`{{\mathrm{pack}}}_{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(c)`
....................................................................................


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

  a. Return :math:`c`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{\mathrm{wrap}}}_{{|{\mathrm{unpack}}({\mathit{packtype}})|}, {|{\mathit{packtype}}|}}(c)`.


:math:`{{\mathrm{unpack}}}_{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(c)`
......................................................................................


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

  a. Return :math:`c`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{{{\mathrm{extend}}}_{{|{\mathit{packtype}}|}, {|{\mathrm{unpack}}({\mathit{packtype}})|}}^{\mathsf{u}}}}{(c)}`.


:math:`{{\mathrm{invlanes}}}_{{\mathit{sh}}}({c^\ast})`
.......................................................


1. Let :math:`{\mathit{vc}}` be the result for which :math:`{{\mathrm{lanes}}}_{{\mathit{sh}}}({\mathit{vc}})` :math:`=` :math:`{c^\ast}`.

#. Return :math:`{\mathit{vc}}`.


:math:`{\mathrm{half}}({\mathit{hf}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, i, j)`
....................................................................................


1. If :math:`{\mathit{hf}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{low}`, then:

  a. Return :math:`i`.

#. Assert: Due to validation, :math:`{\mathit{hf}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{high}`.

#. Return :math:`j`.


:math:`{\mathsf{not}}{{}_{\mathsf{v{\scriptstyle 128}}}({\mathit{v{\kern-0.1em\scriptstyle 128}}})}`
....................................................................................................


1. Return :math:`{{\mathrm{inot}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}})`.


:math:`{{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{\mathsf{v{\scriptstyle 128}}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)}`
.................................................................................................................................................................................................


1. If :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{and}`, then:

  a. Return :math:`{{\mathrm{iand}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. If :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{andnot}`, then:

  a. Return :math:`{{\mathrm{iandnot}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. If :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{or}`, then:

  a. Return :math:`{{\mathrm{ior}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. Assert: Due to validation, :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{xor}`.

#. Return :math:`{{\mathrm{ixor}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.


:math:`{\mathsf{bitselect}}{{}_{\mathsf{v{\scriptstyle 128}}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_3)}`
......................................................................................................................................................................................................


1. Return :math:`{{\mathrm{ibitselect}}}_{{|\mathsf{v{\scriptstyle 128}}|}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_3)`.


:math:`{{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}}{({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)}`
..............................................................................................................................................................................................


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{abs}`, then:

    1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{iabs}}}_{N}({\mathit{lane}}_1)^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{neg}`, then:

    1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{ineg}}}_{N}({\mathit{lane}}_1)^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{popcnt}`, then:

    1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{ipopcnt}}}_{N}({\mathit{lane}}_1)^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{abs}`, then:

  a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fabs}}}_{N}({\mathit{lane}}_1)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{neg}`, then:

  a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fneg}}}_{N}({\mathit{lane}}_1)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sqrt}`, then:

  a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fsqrt}}}_{N}({\mathit{lane}}_1)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ceil}`, then:

  a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fceil}}}_{N}({\mathit{lane}}_1)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{floor}`, then:

  a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{ffloor}}}_{N}({\mathit{lane}}_1)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{trunc}`, then:

  a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{ftrunc}}}_{N}({\mathit{lane}}_1)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{nearest}`.

#. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

#. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fnearest}}}_{N}({\mathit{lane}}_1)^\ast}`.

#. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

#. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.


:math:`{{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}}{({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)}`
............................................................................................................................................................................................................................................


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

    1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{iadd}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

    1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{isub}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{min}`, then:

    1) Let :math:`({\mathsf{min}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{imin}}}_{N}({\mathit{sx}}, {\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{max}`, then:

    1) Let :math:`({\mathsf{max}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{imax}}}_{N}({\mathit{sx}}, {\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{add\_sat}`, then:

    1) Let :math:`({\mathsf{add\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{{{\mathrm{iadd\_sat}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{sub\_sat}`, then:

    1) Let :math:`({\mathsf{sub\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{{{\mathrm{isub\_sat}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

    1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{\mathrm{imul}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = `, then:

    1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{{{\mathrm{iavgr}}}_{N}^{\mathsf{u}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = `, then:

    1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{{{{\mathrm{iq{\kern-0.1em\scriptstyle 15\kern-0.1em}mulr\_sat}}}_{N}^{\mathsf{s}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)}^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

  a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fadd}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

  a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fsub}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

  a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fmul}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{div}`, then:

  a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fdiv}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{min}`, then:

  a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fmin}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{max}`, then:

  a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fmax}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{pmin}`, then:

  a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fpmin}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

  #. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

  #. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{pmax}`.

#. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

#. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. Let :math:`{{{\mathit{lane}}^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{fpmax}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2)^\ast}`.

#. Let :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}` be :math:`{{{\mathrm{invlanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}^\ast})^\ast}`.

#. Return :math:`{{\mathit{v{\kern-0.1em\scriptstyle 128}}}^\ast}`.


:math:`{{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}}{({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1, {\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)}`
............................................................................................................................................................................................................................................


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{n}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

    1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{ieq}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

    1) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{ine}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{lt}`, then:

    1) Let :math:`(\mathsf{lt}~{\mathit{sx}})` be :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}^\ast}`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{gt}`, then:

    1) Let :math:`(\mathsf{gt}~{\mathit{sx}})` be :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}^\ast}`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{le}`, then:

    1) Let :math:`(\mathsf{le}~{\mathit{sx}})` be :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}^\ast}`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

  #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ge}`, then:

    1) Let :math:`(\mathsf{ge}~{\mathit{sx}})` be :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

    #) Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

    #) Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}_1, {\mathit{lane}}_2)})}^\ast}`.

    #) Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

    #) Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{n}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

  a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathsf{f}}{n}|}`.

  #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{feq}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

  a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathsf{f}}{n}|}`.

  #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fne}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{lt}`, then:

  a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathsf{f}}{n}|}`.

  #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{flt}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{gt}`, then:

  a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathsf{f}}{n}|}`.

  #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fgt}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{le}`, then:

  a. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

  #. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

  #. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathsf{f}}{n}|}`.

  #. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fle}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

  #. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

  #. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.

#. Assert: Due to validation, :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ge}`.

#. Let :math:`{{\mathit{lane}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_1)`.

#. Let :math:`{{\mathit{lane}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{n}}{\mathsf{x}}{M}}({\mathit{v{\kern-0.1em\scriptstyle 128}}}_2)`.

#. Let :math:`{\mathsf{i}}{n}` be the result for which :math:`{|{\mathsf{i}}{n}|}` :math:`=` :math:`{|{\mathsf{f}}{n}|}`.

#. Let :math:`{{\mathit{lane}}_3^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{fge}}}_{N}({\mathit{lane}}_1, {\mathit{lane}}_2))}^\ast}`.

#. Let :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}` be :math:`{{\mathrm{invlanes}}}_{{{\mathsf{i}}{n}}{\mathsf{x}}{M}}({{\mathit{lane}}_3^\ast})`.

#. Return :math:`{\mathit{v{\kern-0.1em\scriptstyle 128}}}`.


:math:`{{\mathrm{vcvtop}}}_{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}}{\mathsf{x}}{M_1}, {{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, c_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
......................................................................................................................................................................................................................................................................................


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is Jnn, then:

  a. Let :math:`{{\mathsf{i}}{n}}_1` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

    1) Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{extend}`, then:

      a) Let :math:`(\mathsf{extend}~{\mathit{sx}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{\mathit{iN}}_1` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{\mathit{iN}}_2` be :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

      #) Return :math:`{\mathit{iN}}_2`.

  #. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

    1) Let :math:`{{\mathsf{f}}{n}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{convert}`, then:

      a) Let :math:`(\mathsf{convert}~{\mathit{sx}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{\mathit{iN}}_1` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`{\mathit{fN}}_2` be :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{iN}}_1)}`.

      #) Return :math:`{\mathit{fN}}_2`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is Fnn.

#. Let :math:`{{\mathsf{f}}{n}}_1` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{{\mathsf{i}}{n}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{trunc\_sat}`, then:

    1) Let :math:`(\mathsf{trunc\_sat}~{\mathit{sx}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Let :math:`{\mathit{fN}}_1` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Let :math:`{{\mathit{iN}}_2^?}` be :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{({\mathit{fN}}_1)}`.

    #) Return :math:`{{\mathit{iN}}_2^?}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{{\mathsf{f}}{n}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`{\mathit{fN}}_1` be :math:`c_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{demote}`, then:

  a. Let :math:`{{\mathit{fN}}_2^\ast}` be :math:`{{\mathrm{demote}}}_{N_1, N_2}({\mathit{fN}}_1)`.

  #. Return :math:`{{\mathit{fN}}_2^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{promote}`.

#. Let :math:`{{\mathit{fN}}_2^\ast}` be :math:`{{\mathrm{promote}}}_{N_1, N_2}({\mathit{fN}}_1)`.

#. Return :math:`{{\mathit{fN}}_2^\ast}`.


:math:`{{\mathrm{vextunop}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}((\mathsf{extadd\_pairwise}~{\mathit{sx}}), c_1)`
..............................................................................................................................................................


1. Let :math:`{{\mathit{ci}}^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_1)`.

#. Let :math:`{{\mathit{cj}}_1~{\mathit{cj}}_2^\ast}` be the result for which :math:`{\mathrm{concat}}({{\mathit{cj}}_1~{\mathit{cj}}_2^\ast})` :math:`=` :math:`{{{{{\mathrm{extend}}}_{N_2, N_1}^{{\mathit{sx}}}}}{({\mathit{ci}})}^\ast}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}}({{{\mathrm{iadd}}}_{N_1}({\mathit{cj}}_1, {\mathit{cj}}_2)^\ast})`.

#. Return :math:`c`.


:math:`{{\mathrm{vextbinop}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}({\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, c_1, c_2)`
.......................................................................................................................................................................................


1. If :math:`{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{extmul}`, then:

  a. Let :math:`({\mathsf{extmul}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_1){}[{\mathrm{half}}({\mathit{hf}}, 0, M_1) : M_1]`.

  #. Let :math:`{{\mathit{ci}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_2){}[{\mathrm{half}}({\mathit{hf}}, 0, M_1) : M_1]`.

  #. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}}({{{\mathrm{imul}}}_{N_1}({{{{\mathrm{extend}}}_{N_2, N_1}^{{\mathit{sx}}}}}{({\mathit{ci}}_1)}, {{{{\mathrm{extend}}}_{N_2, N_1}^{{\mathit{sx}}}}}{({\mathit{ci}}_2)})^\ast})`.

  #. Return :math:`c`.

#. Assert: Due to validation, :math:`{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = `.

#. Let :math:`{{\mathit{ci}}_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_1)`.

#. Let :math:`{{\mathit{ci}}_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{n}}_2}{\mathsf{x}}{M_2}}(c_2)`.

#. Let :math:`{{\mathit{cj}}_1~{\mathit{cj}}_2^\ast}` be the result for which :math:`{\mathrm{concat}}({{\mathit{cj}}_1~{\mathit{cj}}_2^\ast})` :math:`=` :math:`{{{\mathrm{imul}}}_{N_1}({{{{\mathrm{extend}}}_{N_2, N_1}^{\mathsf{s}}}}{({\mathit{ci}}_1)}, {{{{\mathrm{extend}}}_{N_2, N_1}^{\mathsf{s}}}}{({\mathit{ci}}_2)})^\ast}`.

#. Let :math:`c` be :math:`{{\mathrm{invlanes}}}_{{{{\mathsf{i}}{n}}_1}{\mathsf{x}}{M_1}}({{{\mathrm{iadd}}}_{N_1}({\mathit{cj}}_1, {\mathit{cj}}_2)^\ast})`.

#. Return :math:`c`.


:math:`{{{\mathit{vshiftop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{\_}}~{{\mathsf{i}}{n}}{\mathsf{x}}{M}}{({\mathit{lane}}, n)}`
...........................................................................................................................................


1. If :math:`{\mathit{vshiftop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{shl}`, then:

  a. Return :math:`{{\mathrm{ishl}}}_{N}({\mathit{lane}}, n)`.

#. Assert: Due to validation, :math:`{\mathit{vshiftop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{shr}`.

#. Let :math:`(\mathsf{shr}~{\mathit{sx}})` be :math:`{\mathit{vshiftop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{{{\mathrm{ishr}}}_{N}^{{\mathit{sx}}}}}{({\mathit{lane}}, n)}`.


:math:`{{\mathrm{default}}}_{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}`
........................................................................


1. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 32}}`, then:

  a. Return :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 64}}`, then:

  a. Return :math:`(\mathsf{i{\scriptstyle 64}}{.}\mathsf{const}~0)`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 32}}`, then:

  a. Return :math:`(\mathsf{f{\scriptstyle 32}}{.}\mathsf{const}~{+0})`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 64}}`, then:

  a. Return :math:`(\mathsf{f{\scriptstyle 64}}{.}\mathsf{const}~{+0})`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{v{\scriptstyle 128}}`, then:

  a. Return :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~0)`.

#. If :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{funcref}`, then:

  a. Return :math:`(\mathsf{ref{.}null}~\mathsf{funcref})`.

#. Assert: Due to validation, :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{externref}`.

#. Return :math:`(\mathsf{ref{.}null}~\mathsf{externref})`.


:math:`{\mathrm{funcs}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
......................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xv}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{xv}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xv}}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xv}}^\ast})`.


:math:`z{.}\mathsf{store}`
..........................


1. Return.


:math:`z{.}\mathsf{frame}`
..........................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`f`.


:math:`z{.}\mathsf{module}{.}\mathsf{funcs}`
............................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`f{.}\mathsf{module}{.}\mathsf{funcs}`.


:math:`z{.}\mathsf{funcs}`
..........................


1. Return :math:`s{.}\mathsf{funcs}`.


:math:`z{.}\mathsf{globals}`
............................


1. Return :math:`s{.}\mathsf{globals}`.


:math:`z{.}\mathsf{tables}`
...........................


1. Return :math:`s{.}\mathsf{tables}`.


:math:`z{.}\mathsf{mems}`
.........................


1. Return :math:`s{.}\mathsf{mems}`.


:math:`z{.}\mathsf{elems}`
..........................


1. Return :math:`s{.}\mathsf{elems}`.


:math:`z{.}\mathsf{datas}`
..........................


1. Return :math:`s{.}\mathsf{datas}`.


:math:`z{.}\mathsf{module}`
...........................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`f{.}\mathsf{module}`.


:math:`z{.}\mathsf{types}{}[x]`
...............................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`f{.}\mathsf{module}{.}\mathsf{types}{}[x]`.


:math:`z{.}\mathsf{funcs}{}[x]`
...............................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`s{.}\mathsf{funcs}{}[f{.}\mathsf{module}{.}\mathsf{funcs}{}[x]]`.


:math:`z{.}\mathsf{globals}{}[x]`
.................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]`.


:math:`z{.}\mathsf{tables}{}[x]`
................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]`.


:math:`z{.}\mathsf{mems}{}[x]`
..............................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]`.


:math:`z{.}\mathsf{elems}{}[x]`
...............................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]`.


:math:`z{.}\mathsf{datas}{}[x]`
...............................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]`.


:math:`z{.}\mathsf{locals}{}[x]`
................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`f{.}\mathsf{locals}{}[x]`.


:math:`z{}[{.}\mathsf{locals}{}[x] = v]`
........................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`f{.}\mathsf{locals}{}[x]` with :math:`v`.


:math:`z{}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = v]`
..........................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]{.}\mathsf{value}` with :math:`v`.


:math:`z{}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = r]`
.............................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]{.}\mathsf{refs}{}[i]` with :math:`r`.


:math:`z{}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`
....................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]` with :math:`{\mathit{ti}}`.


:math:`z{}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i : j] = {b^\ast}]`
.......................................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]{.}\mathsf{bytes}{}[i : j]` with :math:`{b^\ast}`.


:math:`z{}[{.}\mathsf{mems}{}[x] = {\mathit{mi}}]`
..................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]` with :math:`{\mathit{mi}}`.


:math:`z{}[{.}\mathsf{elems}{}[x]{.}\mathsf{refs} = {r^\ast}]`
..............................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]{.}\mathsf{refs}` with :math:`{r^\ast}`.


:math:`z{}[{.}\mathsf{datas}{}[x]{.}\mathsf{bytes} = {b^\ast}]`
...............................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]{.}\mathsf{bytes}` with :math:`{b^\ast}`.


:math:`{\mathrm{growtable}}({\mathit{ti}}, n, r)`
.................................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~(({}[~i~..~j~]), {\mathit{rt}}),\; \mathsf{refs}~{{r'}^\ast} \}\end{array}` be :math:`{\mathit{ti}}`.

#. Let :math:`{i'}` be :math:`{|{{r'}^\ast}|} + n`.

#. If :math:`{i'} \leq j`, then:

  a. Let :math:`{\mathit{ti}'}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~(({}[~{i'}~..~j~]), {\mathit{rt}}),\; \mathsf{refs}~{{r'}^\ast}~{r^{n}} \}\end{array}`.

  #. Return :math:`{\mathit{ti}'}`.


:math:`{\mathrm{growmemory}}({\mathit{mi}}, n)`
...............................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({}[~i~..~j~])~\mathsf{page},\; \mathsf{bytes}~{b^\ast} \}\end{array}` be :math:`{\mathit{mi}}`.

#. Let :math:`{i'}` be :math:`{|{b^\ast}|} / 64 \, {\mathrm{Ki}} + n`.

#. If :math:`{i'} \leq j`, then:

  a. Let :math:`{\mathit{mi}'}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({}[~{i'}~..~j~])~\mathsf{page},\; \mathsf{bytes}~{b^\ast}~{\mathtt{0x00}^{n \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

  #. Return :math:`{\mathit{mi}'}`.


:math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
.........................................................................................


1. If :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \epsilon`, then:

  a. Return :math:`\epsilon~\rightarrow~\epsilon`.

#. If :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case , then:

  a. Let :math:`{{\mathit{valtype}}_0^?}` be :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{{\mathit{valtype}}_0^?}` is defined, then:

    1) Let :math:`t` be :math:`{{\mathit{valtype}}_0^?}`.

    #) Return :math:`\epsilon~\rightarrow~t`.

#. Assert: Due to validation, :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case .

#. Let :math:`x` be :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`z{.}\mathsf{types}{}[x]`.


:math:`{\mathrm{funcs}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
......................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{fa}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{fa}}~{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{ga}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ga}}~{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{ta}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ta}}~{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~{\mathit{ma}})` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`{\mathit{ma}}~{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{externaddr}'}^\ast}` be :math:`{{\mathit{xv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{externaddr}'}^\ast})`.


:math:`{\mathrm{allocfunc}}(s, {\mathit{moduleinst}}, {\mathit{func}})`
.......................................................................


1. Assert: Due to validation, :math:`{\mathit{func}}` is of the case :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}})` be :math:`{\mathit{func}}`.

#. Let :math:`{\mathit{fi}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{moduleinst}}{.}\mathsf{types}{}[x],\; \mathsf{module}~{\mathit{moduleinst}},\; \mathsf{code}~{\mathit{func}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{funcs}|}`.

#. Append :math:`{\mathit{fi}}` to :math:`s{.}\mathsf{funcs}`.

#. Return :math:`a`.


:math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................................................


1. If :math:`{{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{func}}~{{\mathit{func}'}^\ast}` be :math:`{{\mathit{func}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{fa}}` be :math:`{\mathrm{allocfunc}}(s, {\mathit{moduleinst}}, {\mathit{func}})`.

#. Let :math:`{{\mathit{fa}'}^\ast}` be :math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}'}^\ast})`.

#. Return :math:`{\mathit{fa}}~{{\mathit{fa}'}^\ast}`.


:math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`
........................................................................


1. Let :math:`{\mathit{gi}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{globaltype}},\; \mathsf{value}~{\mathit{val}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{globals}|}`.

#. Append :math:`{\mathit{gi}}` to :math:`s{.}\mathsf{globals}`.

#. Return :math:`a`.


:math:`{\mathrm{allocglobals}}(s, {{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
..................................................................................................................................................


1. If :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Assert: Due to validation, :math:`{v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`.

  #. Return :math:`\epsilon`.

#. Else:

  a. Let :math:`{\mathit{globaltype}}~{{\mathit{globaltype}'}^\ast}` be :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

  #. Assert: Due to validation, :math:`{|{v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

  #. Let :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}` be :math:`{v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

  #. Let :math:`{\mathit{ga}}` be :math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`.

  #. Let :math:`{{\mathit{ga}'}^\ast}` be :math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}'}^\ast}, {{\mathit{val}'}^\ast})`.

  #. Return :math:`{\mathit{ga}}~{{\mathit{ga}'}^\ast}`.


:math:`{\mathrm{alloctable}}(s, (({}[~i~..~j~]), {\mathit{rt}}))`
.................................................................


1. Let :math:`{\mathit{ti}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~(({}[~i~..~j~]), {\mathit{rt}}),\; \mathsf{refs}~{(\mathsf{ref{.}null}~{\mathit{rt}})^{i}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{tables}|}`.

#. Append :math:`{\mathit{ti}}` to :math:`s{.}\mathsf{tables}`.

#. Return :math:`a`.


:math:`{\mathrm{alloctables}}(s, {{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
...............................................................................................


1. If :math:`{{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{tabletype}}~{{\mathit{tabletype}'}^\ast}` be :math:`{{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{ta}}` be :math:`{\mathrm{alloctable}}(s, {\mathit{tabletype}})`.

#. Let :math:`{{\mathit{ta}'}^\ast}` be :math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}'}^\ast})`.

#. Return :math:`{\mathit{ta}}~{{\mathit{ta}'}^\ast}`.


:math:`{\mathrm{allocmem}}(s, ({}[~i~..~j~])~\mathsf{page})`
............................................................


1. Let :math:`{\mathit{mi}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({}[~i~..~j~])~\mathsf{page},\; \mathsf{bytes}~{\mathtt{0x00}^{i \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{mems}|}`.

#. Append :math:`{\mathit{mi}}` to :math:`s{.}\mathsf{mems}`.

#. Return :math:`a`.


:math:`{\mathrm{allocmems}}(s, {{\mathit{mt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.............................................................................................


1. If :math:`{{\mathit{mt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{memtype}}~{{\mathit{memtype}'}^\ast}` be :math:`{{\mathit{mt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{ma}}` be :math:`{\mathrm{allocmem}}(s, {\mathit{memtype}})`.

#. Let :math:`{{\mathit{ma}'}^\ast}` be :math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}'}^\ast})`.

#. Return :math:`{\mathit{ma}}~{{\mathit{ma}'}^\ast}`.


:math:`{\mathrm{allocelem}}(s, {\mathit{rt}}, {{\mathit{ref}}^\ast})`
.....................................................................


1. Let :math:`{\mathit{ei}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{rt}},\; \mathsf{refs}~{{\mathit{ref}}^\ast} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{elems}|}`.

#. Append :math:`{\mathit{ei}}` to :math:`s{.}\mathsf{elems}`.

#. Return :math:`a`.


:math:`{\mathrm{allocelems}}(s, {{\mathit{rt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
................................................................................................................................................


1. If :math:`{{\mathit{rt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon` and :math:`{r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{{\mathit{ref}}^\ast}~{{{\mathit{ref}'}^\ast}^\ast}` be :math:`{r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{rt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{rt}}~{{\mathit{rt}'}^\ast}` be :math:`{{\mathit{rt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{ea}}` be :math:`{\mathrm{allocelem}}(s, {\mathit{rt}}, {{\mathit{ref}}^\ast})`.

#. Let :math:`{{\mathit{ea}'}^\ast}` be :math:`{\mathrm{allocelems}}(s, {{\mathit{rt}'}^\ast}, {{{\mathit{ref}'}^\ast}^\ast})`.

#. Return :math:`{\mathit{ea}}~{{\mathit{ea}'}^\ast}`.


:math:`{\mathrm{allocdata}}(s, {{\mathit{byte}}^\ast})`
.......................................................


1. Let :math:`{\mathit{di}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{bytes}~{{\mathit{byte}}^\ast} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{datas}|}`.

#. Append :math:`{\mathit{di}}` to :math:`s{.}\mathsf{datas}`.

#. Return :math:`a`.


:math:`{\mathrm{allocdatas}}(s, {b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
..................................................................................


1. If :math:`{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{{\mathit{byte}}^\ast}~{{{\mathit{byte}'}^\ast}^\ast}` be :math:`{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{da}}` be :math:`{\mathrm{allocdata}}(s, {{\mathit{byte}}^\ast})`.

#. Let :math:`{{\mathit{da}'}^\ast}` be :math:`{\mathrm{allocdatas}}(s, {{{\mathit{byte}'}^\ast}^\ast})`.

#. Return :math:`{\mathit{da}}~{{\mathit{da}'}^\ast}`.


:math:`{\mathrm{instexport}}({{\mathit{fa}}^\ast}, {{\mathit{ga}}^\ast}, {{\mathit{ta}}^\ast}, {{\mathit{ma}}^\ast}, (\mathsf{export}~{\mathit{name}}~{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}))`
.....................................................................................................................................................................................................................


1. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{func}~{{\mathit{fa}}^\ast}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{global}~{{\mathit{ga}}^\ast}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{table}~{{\mathit{ta}}^\ast}{}[x]) \}\end{array}`.

#. Assert: Due to validation, :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{mem}`.

#. Let :math:`(\mathsf{mem}~x)` be :math:`{\mathit{externidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{mem}~{{\mathit{ma}}^\ast}{}[x]) \}\end{array}`.


:math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast}, {{{\mathit{ref}}^\ast}^\ast})`
.......................................................................................................................................


1. Assert: Due to validation, :math:`{\mathit{module}}` is of the case :math:`\mathsf{module}`.

#. Let :math:`(\mathsf{module}~{{\mathit{type}}_0^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^{n_{\mathit{func}}}}~{{\mathit{global}}_1^\ast}~{{\mathit{table}}_2^\ast}~{{\mathit{mem}}_3^\ast}~{{\mathit{elem}}_4^\ast}~{{\mathit{data}}_5^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be :math:`{\mathit{module}}`.

#. Assert: Due to validation, for all :math:`{\mathit{data}}_5` in :math:`{{\mathit{data}}_5^\ast}`, :math:`{\mathit{data}}_5` is of the case :math:`\mathsf{data}`.

#. Let :math:`{(\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}})^{n_{\mathit{data}}}}` be :math:`{{\mathit{data}}_5^\ast}`.

#. Assert: Due to validation, for all :math:`{\mathit{elem}}_4` in :math:`{{\mathit{elem}}_4^\ast}`, :math:`{\mathit{elem}}_4` is of the case :math:`\mathsf{elem}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{rt}}~{{\mathit{expr}}_2^\ast}~{\mathit{elemmode}})^{n_{\mathit{elem}}}}` be :math:`{{\mathit{elem}}_4^\ast}`.

#. Assert: Due to validation, for all :math:`{\mathit{mem}}_3` in :math:`{{\mathit{mem}}_3^\ast}`, :math:`{\mathit{mem}}_3` is of the case :math:`\mathsf{memory}`.

#. Let :math:`{(\mathsf{memory}~{\mathit{memtype}})^{n_{\mathit{mem}}}}` be :math:`{{\mathit{mem}}_3^\ast}`.

#. Assert: Due to validation, for all :math:`{\mathit{table}}_2` in :math:`{{\mathit{table}}_2^\ast}`, :math:`{\mathit{table}}_2` is of the case :math:`\mathsf{table}`.

#. Let :math:`{(\mathsf{table}~{\mathit{tabletype}})^{n_{\mathit{table}}}}` be :math:`{{\mathit{table}}_2^\ast}`.

#. Assert: Due to validation, for all :math:`{\mathit{global}}_1` in :math:`{{\mathit{global}}_1^\ast}`, :math:`{\mathit{global}}_1` is of the case :math:`\mathsf{global}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_1)^{n_{\mathit{global}}}}` be :math:`{{\mathit{global}}_1^\ast}`.

#. Assert: Due to validation, for all :math:`{\mathit{type}}_0` in :math:`{{\mathit{type}}_0^\ast}`, :math:`{\mathit{type}}_0` is of the case :math:`\mathsf{type}`.

#. Let :math:`{(\mathsf{type}~{\mathit{ft}})^\ast}` be :math:`{{\mathit{type}}_0^\ast}`.

#. Let :math:`{{\mathit{fa}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ga}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{globals}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ma}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{mems}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ta}}_{\mathit{ex}}^\ast}` be :math:`{\mathrm{tables}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{fa}}^\ast}` be :math:`{({|s{.}\mathsf{funcs}|} + i_{\mathit{func}})^{i_{\mathit{func}}<n_{\mathit{func}}}}`.

#. Let :math:`{{\mathit{ga}}^\ast}` be :math:`{({|s{.}\mathsf{globals}|} + i_{\mathit{global}})^{i_{\mathit{global}}<n_{\mathit{global}}}}`.

#. Let :math:`{{\mathit{ta}}^\ast}` be :math:`{({|s{.}\mathsf{tables}|} + i_{\mathit{table}})^{i_{\mathit{table}}<n_{\mathit{table}}}}`.

#. Let :math:`{{\mathit{ma}}^\ast}` be :math:`{({|s{.}\mathsf{mems}|} + i_{\mathit{mem}})^{i_{\mathit{mem}}<n_{\mathit{mem}}}}`.

#. Let :math:`{{\mathit{ea}}^\ast}` be :math:`{({|s{.}\mathsf{elems}|} + i_{\mathit{elem}})^{i_{\mathit{elem}}<n_{\mathit{elem}}}}`.

#. Let :math:`{{\mathit{da}}^\ast}` be :math:`{({|s{.}\mathsf{datas}|} + i_{\mathit{data}})^{i_{\mathit{data}}<n_{\mathit{data}}}}`.

#. Let :math:`{{\mathit{xi}}^\ast}` be :math:`{{\mathrm{instexport}}({{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast}, {{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast}, {{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast}, {{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast}, {\mathit{export}})^\ast}`.

#. Let :math:`{\mathit{moduleinst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{ft}}^\ast},\; \mathsf{funcs}~{{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast},\; \mathsf{globals}~{{\mathit{ga}}_{\mathit{ex}}^\ast}~{{\mathit{ga}}^\ast},\; \mathsf{tables}~{{\mathit{ta}}_{\mathit{ex}}^\ast}~{{\mathit{ta}}^\ast},\; \mathsf{mems}~{{\mathit{ma}}_{\mathit{ex}}^\ast}~{{\mathit{ma}}^\ast},\; \mathsf{elems}~{{\mathit{ea}}^\ast},\; \mathsf{datas}~{{\mathit{da}}^\ast},\; \mathsf{exports}~{{\mathit{xi}}^\ast} \}\end{array}`.

#. Let :math:`{{\mathit{funcaddr}}_0^\ast}` be :math:`{\mathrm{allocfuncs}}(s, {\mathit{moduleinst}}, {{\mathit{func}}^{n_{\mathit{func}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{funcaddr}}_0^\ast} = {{\mathit{fa}}^\ast}`.

#. Let :math:`{{\mathit{globaladdr}}_0^\ast}` be :math:`{\mathrm{allocglobals}}(s, {{\mathit{globaltype}}^{n_{\mathit{global}}}}, {{\mathit{val}}^\ast})`.

#. Assert: Due to validation, :math:`{{\mathit{globaladdr}}_0^\ast} = {{\mathit{ga}}^\ast}`.

#. Let :math:`{{\mathit{tableaddr}}_0^\ast}` be :math:`{\mathrm{alloctables}}(s, {{\mathit{tabletype}}^{n_{\mathit{table}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{tableaddr}}_0^\ast} = {{\mathit{ta}}^\ast}`.

#. Let :math:`{{\mathit{memaddr}}_0^\ast}` be :math:`{\mathrm{allocmems}}(s, {{\mathit{memtype}}^{n_{\mathit{mem}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{memaddr}}_0^\ast} = {{\mathit{ma}}^\ast}`.

#. Let :math:`{{\mathit{elemaddr}}_0^\ast}` be :math:`{\mathrm{allocelems}}(s, {{\mathit{rt}}^{n_{\mathit{elem}}}}, {{{\mathit{ref}}^\ast}^\ast})`.

#. Assert: Due to validation, :math:`{{\mathit{elemaddr}}_0^\ast} = {{\mathit{ea}}^\ast}`.

#. Let :math:`{{\mathit{dataaddr}}_0^\ast}` be :math:`{\mathrm{allocdatas}}(s, {({{\mathit{byte}}^\ast})^{n_{\mathit{data}}}})`.

#. Assert: Due to validation, :math:`{{\mathit{dataaddr}}_0^\ast} = {{\mathit{da}}^\ast}`.

#. Return :math:`{\mathit{moduleinst}}`.


:math:`{\mathrm{runelem}}((\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}), i)`
....................................................................................................................................................


1. If :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{passive}`, then:

  a. Return :math:`\epsilon`.

#. If :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{declare}`, then:

  a. Return :math:`(\mathsf{elem{.}drop}~i)`.

#. Assert: Due to validation, :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{active}`.

#. Let :math:`(\mathsf{active}~x~{{\mathit{instr}}^\ast})` be :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`n` be :math:`{|{{\mathit{expr}}^\ast}|}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{table{.}init}~x~i)~(\mathsf{elem{.}drop}~i)`.


:math:`{\mathrm{rundata}}((\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}), i)`
.................................................................................................................................


1. If :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{passive}`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{active}`.

#. Let :math:`(\mathsf{active}~{\mathit{memidx}}_0~{{\mathit{instr}}^\ast})` be :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, :math:`{\mathit{memidx}}_0 = 0`.

#. Let :math:`n` be :math:`{|{{\mathit{byte}}^\ast}|}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{memory{.}init}~i)~(\mathsf{data{.}drop}~i)`.


:math:`{\mathrm{instantiate}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast})`
..................................................................................


1. Assert: Due to validation, :math:`{\mathit{module}}` is of the case :math:`\mathsf{module}`.

#. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be :math:`{\mathit{module}}`.

#. Assert: Due to validation, for all :math:`{\mathit{type}}` in :math:`{{\mathit{type}}^\ast}`, :math:`{\mathit{type}}` is of the case :math:`\mathsf{type}`.

#. Let :math:`{(\mathsf{type}~{\mathit{functype}})^\ast}` be :math:`{{\mathit{type}}^\ast}`.

#. Let :math:`n_{\mathsf{d}}` be :math:`{|{{\mathit{data}}^\ast}|}`.

#. Let :math:`n_{\mathsf{e}}` be :math:`{|{{\mathit{elem}}^\ast}|}`.

#. Let :math:`n_{\mathsf{f}}` be :math:`{|{{\mathit{func}}^\ast}|}`.

#. Assert: Due to validation, for all :math:`{\mathit{start}}` in :math:`{{\mathit{start}}^?}`, :math:`{\mathit{start}}` is of the case :math:`\mathsf{start}`.

#. Let :math:`{(\mathsf{start}~x)^?}` be :math:`{{\mathit{start}}^?}`.

#. Assert: Due to validation, for all :math:`{\mathit{global}}` in :math:`{{\mathit{global}}^\ast}`, :math:`{\mathit{global}}` is of the case :math:`\mathsf{global}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})^\ast}` be :math:`{{\mathit{global}}^\ast}`.

#. Assert: Due to validation, for all :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}`, :math:`{\mathit{elem}}` is of the case :math:`\mathsf{elem}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}_{\mathsf{e}}^\ast}~{\mathit{elemmode}})^\ast}` be :math:`{{\mathit{elem}}^\ast}`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}` be :math:`{\mathrm{concat}}({{\mathrm{rundata}}({{\mathit{data}}^\ast}{}[j], j)^{j<n_{\mathsf{d}}}})`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}` be :math:`{\mathrm{concat}}({{\mathrm{runelem}}({{\mathit{elem}}^\ast}{}[i], i)^{i<n_{\mathsf{e}}}})`.

#. Let :math:`{\mathit{moduleinst}}_{\mathit{init}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{functype}}^\ast},\; \mathsf{funcs}~{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})~{({|s{.}\mathsf{funcs}|} + i_{\mathsf{f}})^{i_{\mathsf{f}}<n_{\mathsf{f}}}},\; \mathsf{globals}~{\mathrm{globals}}({{\mathit{externaddr}}^\ast}),\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{exports}~\epsilon \}\end{array}`.

#. Let :math:`f_{\mathit{init}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~\epsilon,\; \mathsf{module}~{\mathit{moduleinst}}_{\mathit{init}} \}\end{array}`.

#. Let :math:`z` be :math:`f_{\mathit{init}}`.

#. Push the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~z~\})` to the stack.

#. Let :math:`{{\mathit{val}}^\ast}` be :math:`{{\mathrm{eval}}_{\mathit{expr}}({\mathit{expr}}_{\mathsf{g}})^\ast}`.

#. Pop the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Push the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~z~\})` to the stack.

#. Let :math:`{{{\mathit{ref}}^\ast}^\ast}` be :math:`{{{\mathrm{eval}}_{\mathit{expr}}({\mathit{expr}}_{\mathsf{e}})^\ast}^\ast}`.

#. Pop the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Let :math:`{\mathit{moduleinst}}` be :math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}^\ast}, {{{\mathit{ref}}^\ast}^\ast})`.

#. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~\epsilon,\; \mathsf{module}~{\mathit{moduleinst}} \}\end{array}`.

#. Push the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~f~\})` to the stack.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}`.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}`.

#. Execute the sequence :math:`{(\mathsf{call}~x)^?}`.

#. Pop the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Return :math:`f{.}\mathsf{module}`.


:math:`{\mathrm{invoke}}(s, {\mathit{fa}}, {{\mathit{val}}^{n}})`
.................................................................


1. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~\epsilon,\; \mathsf{module}~\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{exports}~\epsilon \}\end{array} \}\end{array}`.

#. Push the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~f~\})` to the stack.

#. Let :math:`{t_1^{n}}~\rightarrow~{t_2^\ast}` be :math:`z{.}\mathsf{funcs}{}[{\mathit{fa}}]{.}\mathsf{type}`.

#. Pop the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Let :math:`k` be :math:`{|{t_2^\ast}|}`.

#. Push the evaluation context :math:`({\mathsf{frame}}_{k}\,\{~f~\})` to the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{call}~{\mathit{fa}})`.

#. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Pop the evaluation context :math:`({\mathsf{frame}}_{k}\,\{~f~\})` from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Return :math:`{{\mathit{val}}^{k}}`.


:math:`{\mathrm{eval}}_{\mathit{expr}}({{\mathit{instr}}^\ast})`
................................................................


1. Execute the instruction :math:`{{\mathit{instr}}^\ast}`.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Return :math:`{\mathit{val}}`.


== Complete.
watsup 0.4 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...
Limits_ok
- the limits ([ n .. m ]) is valid with k if:
  - n is less than or equal to m.
  - m is less than or equal to k.

Functype_ok
- the function type t_1* -> t_2* is valid.

Globaltype_ok
- the global type (MUT?, t) is valid.

Tabletype_ok
- the table type (limits, reftype) is valid if:
  - the limits limits is valid with ((2 ^ 32) - 1).

Memtype_ok
- the memory type limits PAGE is valid if:
  - the limits limits is valid with (2 ^ 16).

Externtype_ok
- the external type xt_u1 is valid if:
  - Either:
    - xt_u1 is (FUNC functype).
    - the function type functype is valid.
  - Or:
    - xt_u1 is (GLOBAL globaltype).
    - the global type globaltype is valid.
  - Or:
    - xt_u1 is (TABLE tabletype).
    - the table type tabletype is valid.
  - Or:
    - xt_u1 is (MEM memtype).
    - the memory type memtype is valid.

Externtype_ok/func
- the external type (FUNC functype) is valid if:
  - the function type functype is valid.

Externtype_ok/global
- the external type (GLOBAL globaltype) is valid if:
  - the global type globaltype is valid.

Externtype_ok/table
- the external type (TABLE tabletype) is valid if:
  - the table type tabletype is valid.

Externtype_ok/mem
- the external type (MEM memtype) is valid if:
  - the memory type memtype is valid.

Valtype_sub
- the value type t_u1 matches the value type t if:
  - Either:
    - t_u1 is t.
  - Or:
    - t_u1 is BOT.

Valtype_sub/refl
- t matches itself.

Valtype_sub/bot
- the value type BOT matches t.

Resulttype_sub
- the value type sequence t_1* matches the value type sequence t_2* if:
  - |t_2*| is |t_1*|.
  - For all t_1 in t_1* and t_2 in t_2*:
    - the value type t_1 matches the value type t_2.

Limits_sub
- the limits ([ n_11 .. n_12 ]) matches the limits ([ n_21 .. n_22 ]) if:
  - n_11 is greater than or equal to n_21.
  - n_12 is less than or equal to n_22.

Functype_sub
- the function type ft matches itself.

Globaltype_sub
- the global type gt matches itself.

Tabletype_sub
- the table type (lim_1, rt) matches the table type (lim_2, rt) if:
  - the limits lim_1 matches the limits lim_2.

Memtype_sub
- the memory type lim_1 PAGE matches the memory type lim_2 PAGE if:
  - the limits lim_1 matches the limits lim_2.

Externtype_sub
- the external type xt_u1 matches the external type xt_u2 if:
  - Either:
    - xt_u1 is (FUNC ft_1).
    - xt_u2 is (FUNC ft_2).
    - the function type ft_1 matches the function type ft_2.
  - Or:
    - xt_u1 is (GLOBAL gt_1).
    - xt_u2 is (GLOBAL gt_2).
    - the global type gt_1 matches the global type gt_2.
  - Or:
    - xt_u1 is (TABLE tt_1).
    - xt_u2 is (TABLE tt_2).
    - the table type tt_1 matches the table type tt_2.
  - Or:
    - xt_u1 is (MEM mt_1).
    - xt_u2 is (MEM mt_2).
    - the memory type mt_1 matches the memory type mt_2.

Externtype_sub/func
- the external type (FUNC ft_1) matches the external type (FUNC ft_2) if:
  - the function type ft_1 matches the function type ft_2.

Externtype_sub/global
- the external type (GLOBAL gt_1) matches the external type (GLOBAL gt_2) if:
  - the global type gt_1 matches the global type gt_2.

Externtype_sub/table
- the external type (TABLE tt_1) matches the external type (TABLE tt_2) if:
  - the table type tt_1 matches the table type tt_2.

Externtype_sub/mem
- the external type (MEM mt_1) matches the external type (MEM mt_2) if:
  - the memory type mt_1 matches the memory type mt_2.

Blocktype_ok
- the block type bt_u1 is valid with the function type t_u1* -> t_u2* if:
  - Either:
    - bt_u1 is (_RESULT valtype?).
    - the value type sequence t_u1* is [].
    - the value type sequence t_u2* is valtype?.
  - Or:
    - bt_u1 is (_IDX typeidx).
    - t_u1* is t_1*.
    - t_u2* is t_2*.
    - the function type C.TYPES[typeidx] exists.
    - C.TYPES[typeidx] is t_1* -> t_2*.

Blocktype_ok/valtype
- the block type (_RESULT valtype?) is valid with the function type [] -> valtype?.

Blocktype_ok/typeidx
- the block type (_IDX typeidx) is valid with the function type t_1* -> t_2* if:
  - the function type C.TYPES[typeidx] exists.
  - C.TYPES[typeidx] is t_1* -> t_2*.

Instr_ok/nop
- the instruction NOP is valid with the function type [] -> [].

Instr_ok/unreachable
- the instruction UNREACHABLE is valid with t_1* -> t_2*.

Instr_ok/drop
- the instruction DROP is valid with the function type [t] -> [].

Instr_ok/select
- the instruction (SELECT t_u1?) is valid with the function type [t, t, I32] -> [t] if:
  - Either:
    - the value type sequence t_u1? is ?([t]).
  - Or:
    - t_u1? is ?().
    - the value type t matches the value type t'.
    - t' is numtype or t' is vectype.

Instr_ok/block
- the instruction (BLOCK bt instr*) is valid with the function type t_1* -> t_2* if:
  - the block type bt is valid with t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr* is valid with t_1* -> t_2*.

Instr_ok/loop
- the instruction (LOOP bt instr*) is valid with the function type t_1* -> t_2* if:
  - the block type bt is valid with t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_1*].
  - Under the context C', the instruction sequence instr* is valid with t_1* -> t_2*.

Instr_ok/if
- the instruction (IF bt instr_1* ELSE instr_2*) is valid with the function type t_1* :: [I32] -> t_2* if:
  - the block type bt is valid with the function type t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr_1* is valid with t_1* -> t_2*.
  - Under the context C', the instruction sequence instr_2* is valid with t_1* -> t_2*.

Instr_ok/br
- the instruction (BR l) is valid with the function type t_1* :: t* -> t_2* if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t*.

Instr_ok/br_if
- the instruction (BR_IF l) is valid with the function type t* :: [I32] -> t* if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t*.

Instr_ok/br_table
- the instruction (BR_TABLE l* l') is valid with the function type t_1* :: t* :: [I32] -> t_2* if:
  - For all l in l*:
    - the result type C.LABELS[l] exists.
  - For all l in l*:
    - the value type sequence t* matches C.LABELS[l].
  - the result type C.LABELS[l'] exists.
  - t* matches C.LABELS[l'].

Instr_ok/call
- the instruction (CALL x) is valid with the function type t_1* -> t_2* if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is t_1* -> t_2*.

Instr_ok/call_indirect
- the instruction (CALL_INDIRECT x y) is valid with the function type t_1* :: [I32] -> t_2* if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim, FUNCREF).
  - the function type C.TYPES[y] exists.
  - C.TYPES[y] is t_1* -> t_2*.

Instr_ok/return
- the instruction RETURN is valid with the function type t_1* :: t* -> t_2* if:
  - the result type C.RETURN is ?(t*).

Instr_ok/const
- the instruction (nt.CONST c_nt) is valid with the function type [] -> [nt].

Instr_ok/unop
- the instruction (UNOP nt unop_nt) is valid with the function type [nt] -> [nt].

Instr_ok/binop
- the instruction (BINOP nt binop_nt) is valid with the function type [nt, nt] -> [nt].

Instr_ok/testop
- the instruction (TESTOP nt testop_nt) is valid with the function type [nt] -> [I32].

Instr_ok/relop
- the instruction (RELOP nt relop_nt) is valid with the function type [nt, nt] -> [I32].

Instr_ok/cvtop
- the instruction (CVTOP nt_1 nt_2 cvtop_u1) is valid with the function type [nt_2] -> [nt_1] if:
  - Either:
    - cvtop_u1 is REINTERPRET.
    - $size(nt_1) is $size(nt_2).
  - Or:
    - cvtop_u1 is cvtop.

Instr_ok/ref.null
- the instruction (REF.NULL rt) is valid with the function type [] -> [rt].

Instr_ok/ref.func
- the instruction (REF.FUNC x) is valid with the function type [] -> [FUNCREF] if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is ft.

Instr_ok/ref.is_null
- the instruction REF.IS_NULL is valid with the function type [rt] -> [I32].

Instr_ok/vconst
- the instruction (V128.CONST c) is valid with the function type [] -> [V128].

Instr_ok/vvunop
- the instruction (VVUNOP V128 vvunop) is valid with the function type [V128] -> [V128].

Instr_ok/vvbinop
- the instruction (VVBINOP V128 vvbinop) is valid with the function type [V128, V128] -> [V128].

Instr_ok/vvternop
- the instruction (VVTERNOP V128 vvternop) is valid with the function type [V128, V128, V128] -> [V128].

Instr_ok/vvtestop
- the instruction (VVTESTOP V128 vvtestop) is valid with the function type [V128] -> [I32].

Instr_ok/vunop
- the instruction (VUNOP sh vunop_sh) is valid with [V128] -> [V128].

Instr_ok/vbinop
- the instruction (VBINOP sh vbinop_sh) is valid with [V128, V128] -> [V128].

Instr_ok/vtestop
- the instruction (VTESTOP sh vtestop_sh) is valid with [V128] -> [I32].

Instr_ok/vrelop
- the instruction (VRELOP sh vrelop_sh) is valid with [V128, V128] -> [V128].

Instr_ok/vshiftop
- the instruction (VSHIFTOP sh vshiftop_sh) is valid with the function type [V128, I32] -> [V128].

Instr_ok/vbitmask
- the instruction (VBITMASK sh) is valid with [V128] -> [I32].

Instr_ok/vswizzle
- the instruction (VSWIZZLE sh) is valid with [V128, V128] -> [V128].

Instr_ok/vshuffle
- the instruction (VSHUFFLE sh i*) is valid with the function type [V128, V128] -> [V128] if:
  - For all i in i*:
    - the lane index i is less than (2 * $dim(sh)).

Instr_ok/vsplat
- the instruction (VSPLAT sh) is valid with the function type [t] -> [V128] if:
  - Let t be the number type $shunpack(sh).

Instr_ok/vextract_lane
- the instruction (VEXTRACT_LANE sh sx? i) is valid with the function type [V128] -> [t] if:
  - the lane index i is less than $dim(sh).
  - Let t be the number type $shunpack(sh).

Instr_ok/vreplace_lane
- the instruction (VREPLACE_LANE sh i) is valid with the function type [V128, t] -> [V128] if:
  - the lane index i is less than $dim(sh).
  - Let t be the number type $shunpack(sh).

Instr_ok/vextunop
- the instruction (VEXTUNOP sh_1 sh_2 vextunop) is valid with the function type [V128] -> [V128].

Instr_ok/vextbinop
- the instruction (VEXTBINOP sh_1 sh_2 vextbinop) is valid with the function type [V128, V128] -> [V128].

Instr_ok/vnarrow
- the instruction (VNARROW sh_1 sh_2 sx) is valid with [V128, V128] -> [V128].

Instr_ok/vcvtop
- the instruction (VCVTOP sh_1 sh_2 vcvtop hf? zero?) is valid with [V128] -> [V128].

Instr_ok/local.get
- the instruction (LOCAL.GET x) is valid with the function type [] -> [t] if:
  - the value type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/local.set
- the instruction (LOCAL.SET x) is valid with the function type [t] -> [] if:
  - the value type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/local.tee
- the instruction (LOCAL.TEE x) is valid with the function type [t] -> [t] if:
  - the value type C.LOCALS[x] exists.
  - C.LOCALS[x] is t.

Instr_ok/global.get
- the instruction (GLOBAL.GET x) is valid with the function type [] -> [t] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (mut, t).

Instr_ok/global.set
- the instruction (GLOBAL.SET x) is valid with the function type [t] -> [] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?(MUT), t).

Instr_ok/table.get
- the instruction (TABLE.GET x) is valid with the function type [I32] -> [rt] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim, rt).

Instr_ok/table.set
- the instruction (TABLE.SET x) is valid with the function type [I32, rt] -> [] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim, rt).

Instr_ok/table.size
- the instruction (TABLE.SIZE x) is valid with the function type [] -> [I32] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim, rt).

Instr_ok/table.grow
- the instruction (TABLE.GROW x) is valid with the function type [rt, I32] -> [I32] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim, rt).

Instr_ok/table.fill
- the instruction (TABLE.FILL x) is valid with the function type [I32, rt, I32] -> [] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim, rt).

Instr_ok/table.copy
- the instruction (TABLE.COPY x_1 x_2) is valid with the function type [I32, I32, I32] -> [] if:
  - the table type C.TABLES[x_1] exists.
  - C.TABLES[x_1] is (lim_1, rt).
  - the table type C.TABLES[x_2] exists.
  - C.TABLES[x_2] is (lim_2, rt).

Instr_ok/table.init
- the instruction (TABLE.INIT x_1 x_2) is valid with the function type [I32, I32, I32] -> [] if:
  - the table type C.TABLES[x_1] exists.
  - C.TABLES[x_1] is (lim, rt).
  - the element type C.ELEMS[x_2] exists.
  - C.ELEMS[x_2] is rt.

Instr_ok/elem.drop
- the instruction (ELEM.DROP x) is valid with the function type [] -> [] if:
  - the element type C.ELEMS[x] exists.
  - C.ELEMS[x] is rt.

Instr_ok/memory.size
- the instruction MEMORY.SIZE is valid with the function type [] -> [I32] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.

Instr_ok/memory.grow
- the instruction MEMORY.GROW is valid with the function type [I32] -> [I32] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.

Instr_ok/memory.fill
- the instruction MEMORY.FILL is valid with the function type [I32, I32, I32] -> [] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.

Instr_ok/memory.copy
- the instruction MEMORY.COPY is valid with the function type [I32, I32, I32] -> [] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.

Instr_ok/memory.init
- the instruction (MEMORY.INIT x) is valid with the function type [I32, I32, I32] -> [] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - the data type C.DATAS[x] exists.
  - C.DATAS[x] is OK.

Instr_ok/data.drop
- the instruction (DATA.DROP x) is valid with the function type [] -> [] if:
  - the data type C.DATAS[x] exists.
  - C.DATAS[x] is OK.

Instr_ok/load
- the instruction (LOAD nt_u1 loadop__u1? memarg) is valid with the function type [I32] -> [t_u1] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - Either:
    - the number type nt_u1 is nt.
    - loadop__u1? is ?().
    - the value type t_u1 is nt.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - Or:
    - nt_u1 is Inn.
    - loadop__u1? is ?((M, sx)).
    - t_u1 is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store
- the instruction (STORE nt_u1 sz_u1? memarg) is valid with the function type [I32, t_u1] -> [] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - Either:
    - the number type nt_u1 is nt.
    - the pack size sz_u1? is ?().
    - the value type t_u1 is nt.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - Or:
    - nt_u1 is Inn.
    - sz_u1? is ?(M).
    - t_u1 is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/vload
- the instruction (VLOAD V128 ?(vloadop_u1) memarg) is valid with the function type [I32] -> [V128] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - Either:
    - vloadop_u1 is (SHAPE M X N sx).
    - (2 ^ memarg.ALIGN) is less than or equal to ((M / 8) * N).
  - Or:
    - vloadop_u1 is (SPLAT n).
    - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).
  - Or:
    - vloadop_u1 is (ZERO n).
    - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).

Instr_ok/vload_lane
- the instruction (VLOAD_LANE V128 n memarg laneidx) is valid with the function type [I32, V128] -> [V128] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).
  - laneidx is less than (128 / n).

Instr_ok/vstore
- the instruction (VSTORE V128 memarg) is valid with the function type [I32, V128] -> [] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(V128) / 8).

Instr_ok/vstore_lane
- the instruction (VSTORE_LANE V128 n memarg laneidx) is valid with the function type [I32, V128] -> [] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).
  - laneidx is less than (128 / n).

Instr_ok/select-expl
- the instruction (SELECT ?([t])) is valid with the function type [t, t, I32] -> [t].

Instr_ok/select-impl
- the instruction (SELECT ?()) is valid with the function type [t, t, I32] -> [t] if:
  - the value type t matches the value type t'.
  - t' is numtype or t' is vectype.

Instr_ok/cvtop-reinterpret
- the instruction (CVTOP nt_1 nt_2 REINTERPRET) is valid with the function type [nt_2] -> [nt_1] if:
  - $size(nt_1) is $size(nt_2).

Instr_ok/cvtop-convert
- the instruction (CVTOP nt_1 nt_2 cvtop) is valid with [nt_2] -> [nt_1].

Instr_ok/load-val
- the instruction (LOAD nt ?() memarg) is valid with the function type [I32] -> [nt] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).

Instr_ok/load-pack
- the instruction (LOAD Inn ?((M, sx)) memarg) is valid with the function type [I32] -> [Inn] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store-val
- the instruction (STORE nt ?() memarg) is valid with the function type [I32, nt] -> [] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).

Instr_ok/store-pack
- the instruction (STORE Inn ?(M) memarg) is valid with the function type [I32, Inn] -> [] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/vload
- the instruction (VLOAD V128 ?((SHAPE M X N sx)) memarg) is valid with the function type [I32] -> [V128] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to ((M / 8) * N).

Instr_ok/vload-splat
- the instruction (VLOAD V128 ?((SPLAT n)) memarg) is valid with the function type [I32] -> [V128] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).

Instr_ok/vload-zero
- the instruction (VLOAD V128 ?((ZERO n)) memarg) is valid with the function type [I32] -> [V128] if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - (2 ^ memarg.ALIGN) is less than or equal to (n / 8).

Instrs_ok
- the instruction sequence in_u1* is valid with the function type t_u1* -> t_u2* if:
  - Either:
    - in_u1* is [].
    - the value type sequence t_u1* is [].
    - the value type sequence t_u2* is [].
  - Or:
    - in_u1* is [instr_1] :: instr_2*.
    - t_u1* is t_1*.
    - t_u2* is t_3*.
    - the instruction instr_1 is valid with the function type t_1* -> t_2*.
    - the instruction sequence instr_2* is valid with the function type t_2* -> t_3*.
  - Or:
    - in_u1* is instr*.
    - t_u1* is t'_1*.
    - t_u2* is t'_2*.
    - the instruction sequence instr* is valid with t_1* -> t_2*.
    - the value type sequence t'_1* matches the value type sequence t_1*.
    - the value type sequence t_2* matches the value type sequence t'_2*.
  - Or:
    - in_u1* is instr*.
    - t_u1* is t* :: t_1*.
    - t_u2* is t* :: t_2*.
    - instr* is valid with t_1* -> t_2*.

Instrs_ok/empty
- the instruction sequence [] is valid with the function type [] -> [].

Instrs_ok/seq
- the instruction sequence [instr_1] :: instr_2* is valid with the function type t_1* -> t_3* if:
  - the instruction instr_1 is valid with the function type t_1* -> t_2*.
  - the instruction sequence instr_2* is valid with the function type t_2* -> t_3*.

Instrs_ok/sub
- the instruction sequence instr* is valid with the function type t'_1* -> t'_2* if:
  - instr* is valid with the function type t_1* -> t_2*.
  - the value type sequence t'_1* matches the value type sequence t_1*.
  - the value type sequence t_2* matches the value type sequence t'_2*.

Instrs_ok/frame
- the instruction sequence instr* is valid with the function type t* :: t_1* -> t* :: t_2* if:
  - instr* is valid with the function type t_1* -> t_2*.

Expr_ok
- the expression instr* is valid with the result type t* if:
  - instr* is valid with the function type [] -> t*.

Instr_const
- the instruction in_u1 is constant if:
  - Either:
    - in_u1 is (nt.CONST c).
  - Or:
    - in_u1 is (vt.CONST vc).
  - Or:
    - in_u1 is (REF.NULL rt).
  - Or:
    - in_u1 is (REF.FUNC x).
  - Or:
    - in_u1 is (GLOBAL.GET x).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is (?(), t).

Instr_const/const
- the instruction (nt.CONST c) is constant.

Instr_const/vconst
- the instruction (vt.CONST vc) is constant.

Instr_const/ref.null
- the instruction (REF.NULL rt) is constant.

Instr_const/ref.func
- the instruction (REF.FUNC x) is constant.

Instr_const/global.get
- the instruction (GLOBAL.GET x) is constant if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?(), t).

Expr_const
- the expression instr* is constant if:
  - For all instr in instr*:
    - the instruction instr is constant.

Type_ok
- the type (TYPE ft) is valid with the function type ft if:
  - ft is valid.

Func_ok
- the function (FUNC x (LOCAL t)* expr) is valid with the function type t_1* -> t_2* if:
  - the function type C.TYPES[x] exists.
  - C.TYPES[x] is t_1* -> t_2*.
  - Under the context C with .LOCALS appended by t_1* :: t* with .LABELS appended by [t_2*] with .RETURN appended by ?(t_2*), the expression expr is valid with the result type t_2*.

Global_ok
- the global (GLOBAL gt expr) is valid with the global type gt if:
  - gt is valid.
  - gt is (mut, t).
  - the expression expr is valid with the value type t.
  - expr is constant.

Table_ok
- the table (TABLE tt) is valid with the table type tt if:
  - tt is valid.

Mem_ok
- the memory (MEMORY mt) is valid with the memory type mt if:
  - mt is valid.

Elemmode_ok
- elemmode_u1 is valid with the reference type rt if:
  - Either:
    - elemmode_u1 is (ACTIVE x expr).
    - the table type C.TABLES[x] exists.
    - C.TABLES[x] is (lim, rt).
    - the expression expr is valid with the value type I32.
    - expr is constant.
  - Or:
    - elemmode_u1 is PASSIVE.
  - Or:
    - elemmode_u1 is DECLARE.

Elemmode_ok/active
- (ACTIVE x expr) is valid with the reference type rt if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (lim, rt).
  - the expression expr is valid with the value type I32.
  - expr is constant.

Elemmode_ok/passive
- PASSIVE is valid with rt.

Elemmode_ok/declare
- DECLARE is valid with rt.

Elem_ok
- the table segment (ELEM rt expr* elemmode) is valid with the reference type rt if:
  - For all expr in expr*:
    - the expression expr is valid with rt.
    - expr is constant.
  - elemmode is valid with rt.

Datamode_ok
- datamode_u1 is valid if:
  - Either:
    - datamode_u1 is (ACTIVE 0 expr).
    - the memory type C.MEMS[0] exists.
    - C.MEMS[0] is mt.
    - the expression expr is valid with the value type I32.
    - expr is constant.
  - Or:
    - datamode_u1 is PASSIVE.

Datamode_ok/active
- (ACTIVE 0 expr) is valid if:
  - the memory type C.MEMS[0] exists.
  - C.MEMS[0] is mt.
  - the expression expr is valid with the value type I32.
  - expr is constant.

Datamode_ok/passive
- PASSIVE is valid.

Data_ok
- the memory segment (DATA b* datamode) is valid if:
  - datamode is valid.

Start_ok
- the start function (START x) is valid if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is [] -> [].

Import_ok
- the import (IMPORT name_1 name_2 xt) is valid with the external type xt if:
  - xt is valid.

Externidx_ok
- the external index externidx_u1 is valid with the external type xt_u1 if:
  - Either:
    - externidx_u1 is (FUNC x).
    - xt_u1 is (FUNC ft).
    - the function type C.FUNCS[x] exists.
    - C.FUNCS[x] is ft.
  - Or:
    - externidx_u1 is (GLOBAL x).
    - xt_u1 is (GLOBAL gt).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is gt.
  - Or:
    - externidx_u1 is (TABLE x).
    - xt_u1 is (TABLE tt).
    - the table type C.TABLES[x] exists.
    - C.TABLES[x] is tt.
  - Or:
    - externidx_u1 is (MEM x).
    - xt_u1 is (MEM mt).
    - the memory type C.MEMS[x] exists.
    - C.MEMS[x] is mt.

Externidx_ok/func
- the external index (FUNC x) is valid with the external type (FUNC ft) if:
  - the function type C.FUNCS[x] exists.
  - C.FUNCS[x] is ft.

Externidx_ok/global
- the external index (GLOBAL x) is valid with the external type (GLOBAL gt) if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is gt.

Externidx_ok/table
- the external index (TABLE x) is valid with the external type (TABLE tt) if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is tt.

Externidx_ok/mem
- the external index (MEM x) is valid with the external type (MEM mt) if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is mt.

Export_ok
- the export (EXPORT name externidx) is valid with the external type xt if:
  - the external index externidx is valid with xt.

Module_ok
- the module (MODULE type* import* func* global* table* mem* elem* data^n start? export*) is valid if:
  - |type*| is |ft'*|.
  - For all ft' in ft'* and type in type*:
    - the type type is valid with the function type ft'.
  - |ixt*| is |import*|.
  - For all import in import* and ixt in ixt*:
    - Under the context { TYPES: ft'*; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; RETURN: ?(); }, the import import is valid with the external type ixt.
  - |gt*| is |global*|.
  - For all global in global* and gt in gt*:
    - Under the context C', the global global is valid with the global type gt.
  - |tt*| is |table*|.
  - For all table in table* and tt in tt*:
    - Under the context C', the table table is valid with the table type tt.
  - |mt*| is |mem*|.
  - For all mem in mem* and mt in mt*:
    - Under the context C', the memory mem is valid with the memory type mt.
  - |rt*| is |elem*|.
  - For all elem in elem* and rt in rt*:
    - Under the context C', the table segment elem is valid with the reference type rt.
  - For all data in data*:
    - Under the context C', the memory segment data is valid.
  - |func*| is |ft*|.
  - For all ft in ft* and func in func*:
    - the function func is valid with the function type ft.
  - If start is defined, then:
    - the start function start is valid.
  - |xt*| is |export*|.
  - For all export in export* and xt in xt*:
    - the export export is valid with the external type xt.
  - |mt*| is less than or equal to 1.
  - the context C is { TYPES: ft'*; FUNCS: ift* :: ft*; GLOBALS: igt* :: gt*; TABLES: itt* :: tt*; MEMS: imt* :: mt*; ELEMS: rt*; DATAS: OK^n; LOCALS: []; LABELS: []; RETURN: ?(); }.
  - the context C' is { TYPES: ft'*; FUNCS: ift* :: ft*; GLOBALS: igt*; TABLES: itt* :: tt*; MEMS: imt* :: mt*; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; RETURN: ?(); }.
  - the function type sequence ift* is $funcsxt(ixt*).
  - the global type sequence igt* is $globalsxt(ixt*).
  - the table type sequence itt* is $tablesxt(ixt*).
  - the memory type sequence imt* is $memsxt(ixt*).

Step_pure/unreachable
1. Trap.

Step_pure/nop
1. Do nothing.

Step_pure/drop
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Do nothing.

Step_pure/select t*?
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val_2 from the stack.
5. Assert: Due to validation, a value is on the top of the stack.
6. Pop the value val_1 from the stack.
7. If (c =/= 0), then:
  a. Push the value val_1 to the stack.
8. Else:
  a. Push the value val_2 to the stack.

Step_pure/if bt instr_1* instr_2*
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BLOCK bt instr_1*).
4. Else:
  a. Execute the instruction (BLOCK bt instr_2*).

Step_pure/label
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
3. Pop the current LABEL_ context from the stack.
4. Push the values val* to the stack.

Step_pure/br n_u1
1. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
2. Let (LABEL_ n { instr'* }) be the current LABEL_ context.
3. If (n_u1 = 0), then:
  a. Assert: Due to validation, there are at least n values on the top of the stack.
  b. Pop the values val^n from the stack.
  c. Pop all values val'* from the top of the stack.
  d. Pop the current LABEL_ context from the stack.
  e. Push the values val^n to the stack.
  f. Execute the instruction instr'*.
4. Else:
  a. Pop all values val* from the top of the stack.
  b. If (n_u1 >= 1), then:
    1) Let l be (n_u1 - 1).
    2) Pop the current LABEL_ context from the stack.
    3) Push the values val* to the stack.
    4) Execute the instruction (BR l).

Step_pure/br_if l
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BR l).
4. Else:
  a. Do nothing.

Step_pure/br_table l* l'
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. If (i < |l*|), then:
  a. Execute the instruction (BR l*[i]).
4. Else:
  a. Execute the instruction (BR l').

Step_pure/frame
1. Let (FRAME_ n { f }) be the current FRAME_ context.
2. Assert: Due to validation, there are at least n values on the top of the stack.
3. Assert: Due to validation, there are at least n values on the top of the stack.
4. Pop the values val^n from the stack.
5. Assert: Due to validation, the first non-value entry of the stack is a FRAME_.
6. Pop the current FRAME_ context from the stack.
7. Push the values val^n to the stack.

Step_pure/return
1. If the first non-value entry of the stack is a FRAME_, then:
  a. Let (FRAME_ n { f }) be the current FRAME_ context.
  b. Assert: Due to validation, there are at least n values on the top of the stack.
  c. Pop the values val^n from the stack.
  d. Pop all values val'* from the top of the stack.
  e. Pop the current FRAME_ context from the stack.
  f. Push the values val^n to the stack.
2. Else if the first non-value entry of the stack is a LABEL_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the current LABEL_ context from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction RETURN.

Step_pure/unop nt unop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. If (|$unop_(nt, unop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $unop_(nt, unop, c_1).
5. Push the value (nt.CONST c) to the stack.

Step_pure/binop nt binop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type numtype_0 is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. If (|$binop_(nt, binop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $binop_(nt, binop, c_1, c_2).
7. Push the value (nt.CONST c) to the stack.

Step_pure/testop nt testop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. Let c be $testop_(nt, testop, c_1).
4. Push the value (I32.CONST c) to the stack.

Step_pure/relop nt relop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type numtype_0 is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. Let c be $relop_(nt, relop, c_1, c_2).
6. Push the value (I32.CONST c) to the stack.

Step_pure/cvtop nt_2 nt_1 cvtop
1. Assert: Due to validation, a value of value type nt_1 is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. If (|$cvtop__(nt_1, nt_2, cvtop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $cvtop__(nt_1, nt_2, cvtop, c_1).
5. Push the value (nt_2.CONST c) to the stack.

Step_pure/ref.is_null
1. Assert: Due to validation, a value of value type ref is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is of the case REF.NULL, then:
  a. Push the value (I32.CONST 1) to the stack.
4. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/vvunop V128 vvunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vvunop_(V128, vvunop, c_1).
4. Push the value (V128.CONST c) to the stack.

Step_pure/vvbinop V128 vvbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vvbinop_(V128, vvbinop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vvternop V128 vvternop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_3) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_2) from the stack.
5. Assert: Due to validation, a value of value type V128 is on the top of the stack.
6. Pop the value (V128.CONST c_1) from the stack.
7. Let c be $vvternop_(V128, vvternop, c_1, c_2, c_3).
8. Push the value (V128.CONST c) to the stack.

Step_pure/vvtestop V128 ANY_TRUE
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $ine_($size(V128), c_1, 0).
4. Push the value (I32.CONST c) to the stack.

Step_pure/vunop sh vunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (|$vunop_(sh, vunop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $vunop_(sh, vunop, c_1).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vbinop sh vbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. If (|$vbinop_(sh, vbinop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $vbinop_(sh, vbinop, c_1, c_2).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vtestop Jnn X N ALL_TRUE
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c) from the stack.
3. Let ci_1* be $lanes_(Jnn X N, c).
4. If (ci_1 =/= 0)*, then:
  a. Push the value (I32.CONST 1) to the stack.
5. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/vrelop sh vrelop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vrelop_(sh, vrelop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vshiftop Jnn X N vshiftop
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST n) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c'* be $lanes_(Jnn X N, c_1).
6. Let c be $invlanes_(Jnn X N, $vshiftop_(Jnn X N, vshiftop, c', n)*).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vbitmask Jnn X N
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c) from the stack.
3. Let ci_1* be $lanes_(Jnn X N, c).
4. Let ci be $ibits__1^-1(32, $ilt_($lsize(Jnn), S, ci_1, 0)*).
5. Push the value (I32.CONST ci) to the stack.

Step_pure/vswizzle Pnn X M
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c'* be $lanes_(Pnn X M, c_1) :: 0^(256 - M).
6. Let ci* be $lanes_(Pnn X M, c_2).
7. Assert: Due to validation, (ci*[k] < |c'*|)^(k<M).
8. Assert: Due to validation, (k < |ci*|)^(k<M).
9. Let c be $invlanes_(Pnn X M, c'*[ci*[k]]^(k<M)).
10. Push the value (V128.CONST c) to the stack.

Step_pure/vshuffle Pnn X N i*
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Assert: Due to validation, (k < |i*|)^(k<N).
6. Let c'* be $lanes_(Pnn X N, c_1) :: $lanes_(Pnn X N, c_2).
7. Assert: Due to validation, (i*[k] < |c'*|)^(k<N).
8. Let c be $invlanes_(Pnn X N, c'*[i*[k]]^(k<N)).
9. Push the value (V128.CONST c) to the stack.

Step_pure/vsplat Lnn X N
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. Assert: Due to validation, (numtype_0 = $unpack(Lnn)).
4. Let c be $invlanes_(Lnn X N, $packnum_(Lnn, c_1)^N).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vextract_lane lt_u1 X N sx_u1? i
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (sx_u1? is not defined /\ the type of lt_u1 is numtype), then:
  a. Let nt be lt_u1.
  b. If (i < |$lanes_(nt X N, c_1)|), then:
    1) Let c_2 be $lanes_(nt X N, c_1)[i].
    2) Push the value (nt.CONST c_2) to the stack.
4. If the type of lt_u1 is packtype, then:
  a. Let pt be lt_u1.
  b. If sx_u1? is defined, then:
    1) Let ?(sx) be sx_u1?.
    2) If (i < |$lanes_(pt X N, c_1)|), then:
      a) Let c_2 be $extend__($psize(pt), 32, sx, $lanes_(pt X N, c_1)[i]).
      b) Push the value (I32.CONST c_2) to the stack.

Step_pure/vreplace_lane Lnn X N i
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, (numtype_0 = $unpack(Lnn)).
4. Assert: Due to validation, a value of value type V128 is on the top of the stack.
5. Pop the value (V128.CONST c_1) from the stack.
6. Let c be $invlanes_(Lnn X N, $lanes_(Lnn X N, c_1) with [i] replaced by $packnum_(Lnn, c_2)).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vextunop sh_1 sh_2 vextunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vextunop__(sh_1, sh_2, vextunop, c_1).
4. Push the value (V128.CONST c) to the stack.

Step_pure/vextbinop sh_1 sh_2 vextbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vextbinop__(sh_1, sh_2, vextbinop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vnarrow Jnn_2 X N_2 Jnn_1 X N_1 sx
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let ci_1* be $lanes_(Jnn_1 X N_1, c_1).
6. Let ci_2* be $lanes_(Jnn_1 X N_1, c_2).
7. Let cj_1* be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, ci_1)*.
8. Let cj_2* be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, ci_2)*.
9. Let c be $invlanes_(Jnn_2 X N_2, cj_1* :: cj_2*).
10. Push the value (V128.CONST c) to the stack.

Step_pure/vcvtop lt_u1 X n_u1 lt_u2 X n_u2 vcvtop hf_u1? zero_u1?
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (hf_u1? is not defined /\ zero_u1? is not defined), then:
  a. Let Lnn_1 be lt_u2.
  b. Let Lnn_2 be lt_u1.
  c. Let M be n_u2.
  d. If (n_u1 = M), then:
    1) Let ci* be $lanes_(Lnn_1 X M, c_1).
    2) Let cj** be $setproduct_(lane_(Lnn_2), $vcvtop__(Lnn_1 X M, Lnn_2 X M, vcvtop, ci)*).
    3) If (|$invlanes_(Lnn_2 X M, cj*)*| > 0), then:
      a) Let c be an element of $invlanes_(Lnn_2 X M, cj*)*.
      b) Push the value (V128.CONST c) to the stack.
4. If zero_u1? is not defined, then:
  a. Let Lnn_1 be lt_u2.
  b. Let Lnn_2 be lt_u1.
  c. Let M_1 be n_u2.
  d. Let M_2 be n_u1.
  e. If hf_u1? is defined, then:
    1) Let ?(half) be hf_u1?.
    2) Let ci* be $lanes_(Lnn_1 X M_1, c_1)[$half(half, 0, M_2) : M_2].
    3) Let cj** be $setproduct_(lane_(Lnn_2), $vcvtop__(Lnn_1 X M_1, Lnn_2 X M_2, vcvtop, ci)*).
    4) If (|$invlanes_(Lnn_2 X M_2, cj*)*| > 0), then:
      a) Let c be an element of $invlanes_(Lnn_2 X M_2, cj*)*.
      b) Push the value (V128.CONST c) to the stack.
5. If hf_u1? is not defined, then:
  a. Let M_1 be n_u2.
  b. Let M_2 be n_u1.
  c. If the type of lt_u2 is numtype, then:
    1) Let nt_1 be lt_u2.
    2) If the type of lt_u1 is numtype, then:
      a) Let nt_2 be lt_u1.
      b) If zero_u1? is defined, then:
        1. Let ci* be $lanes_(nt_1 X M_1, c_1).
        2. Let cj** be $setproduct_(lane_((nt_2 : numtype <: lanetype)), $vcvtop__(nt_1 X M_1, nt_2 X M_2, vcvtop, ci)* :: [$zero(nt_2)]^M_1).
        3. If (|$invlanes_(nt_2 X M_2, cj*)*| > 0), then:
          a. Let c be an element of $invlanes_(nt_2 X M_2, cj*)*.
          b. Push the value (V128.CONST c) to the stack.

Step_pure/local.tee x
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Push the value val to the stack.
4. Push the value val to the stack.
5. Execute the instruction (LOCAL.SET x).

Step_read/block bt instr*
1. Let z be the current state.
2. Let t_1^k -> t_2^n be $blocktype(z, bt).
3. Assert: Due to validation, there are at least k values on the top of the stack.
4. Pop the values val^k from the stack.
5. Enter val^k :: instr* with label (LABEL_ n { [] }).

Step_read/loop bt instr*
1. Let z be the current state.
2. Let t_1^k -> t_2^n be $blocktype(z, bt).
3. Assert: Due to validation, there are at least k values on the top of the stack.
4. Pop the values val^k from the stack.
5. Enter val^k :: instr* with label (LABEL_ k { [(LOOP bt instr*)] }).

Step_read/call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$funcaddr(z)|).
3. Execute the instruction (CALL_ADDR $funcaddr(z)[x]).

Step_read/call_indirect x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
5. If $table(z, x).REFS[i] is not of the case REF.FUNC_ADDR, then:
  a. Trap.
6. Let (REF.FUNC_ADDR a) be $table(z, x).REFS[i].
7. If (a >= |$funcinst(z)|), then:
  a. Trap.
8. If ($type(z, y) =/= $funcinst(z)[a].TYPE), then:
  a. Trap.
9. Execute the instruction (CALL_ADDR a).

Step_read/call_addr a
1. Let z be the current state.
2. Assert: Due to validation, (a < |$funcinst(z)|).
3. Let { TYPE: t_1^k -> t_2^n; MODULE: mm; CODE: func; } be $funcinst(z)[a].
4. Assert: Due to validation, func is of the case FUNC.
5. Let (FUNC x local_0* instr*) be func.
6. Assert: Due to validation, local_0 is of the case LOCAL*.
7. Let (LOCAL t)* be local_0*.
8. Assert: Due to validation, there are at least k values on the top of the stack.
9. Pop the values val^k from the stack.
10. Let f be { LOCALS: val^k :: $default_(t)*; MODULE: mm; }.
11. Push the evaluation context (FRAME_ n { f }) to the stack.
12. Enter instr* with label (LABEL_ n { [] }).

Step_read/ref.func x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$funcaddr(z)|).
3. Push the value (REF.FUNC_ADDR $funcaddr(z)[x]) to the stack.

Step_read/local.get x
1. Let z be the current state.
2. Push the value $local(z, x) to the stack.

Step_read/global.get x
1. Let z be the current state.
2. Push the value $global(z, x).VALUE to the stack.

Step_read/table.get x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
5. Push the value $table(z, x).REFS[i] to the stack.

Step_read/table.size x
1. Let z be the current state.
2. Let n be |$table(z, x).REFS|.
3. Push the value (I32.CONST n) to the stack.

Step_read/table.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. If ((i + n) > |$table(z, x).REFS|), then:
  a. Trap.
9. If (n = 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (I32.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (TABLE.SET x).
  d. Push the value (I32.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (TABLE.FILL x).

Step_read/table.copy x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$table(z, y).REFS|), then:
  a. Trap.
9. If ((j + n) > |$table(z, x).REFS|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. If (j <= i), then:
    1) Push the value (I32.CONST j) to the stack.
    2) Push the value (I32.CONST i) to the stack.
    3) Execute the instruction (TABLE.GET y).
    4) Execute the instruction (TABLE.SET x).
    5) Push the value (I32.CONST (j + 1)) to the stack.
    6) Push the value (I32.CONST (i + 1)) to the stack.
  b. Else:
    1) Push the value (I32.CONST ((j + n) - 1)) to the stack.
    2) Push the value (I32.CONST ((i + n) - 1)) to the stack.
    3) Execute the instruction (TABLE.GET y).
    4) Execute the instruction (TABLE.SET x).
    5) Push the value (I32.CONST j) to the stack.
    6) Push the value (I32.CONST i) to the stack.
  c. Push the value (I32.CONST (n - 1)) to the stack.
  d. Execute the instruction (TABLE.COPY x y).

Step_read/table.init x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$elem(z, y).REFS|), then:
  a. Trap.
9. If ((j + n) > |$table(z, x).REFS|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else if (i < |$elem(z, y).REFS|), then:
  a. Push the value (I32.CONST j) to the stack.
  b. Push the value $elem(z, y).REFS[i] to the stack.
  c. Execute the instruction (TABLE.SET x).
  d. Push the value (I32.CONST (j + 1)) to the stack.
  e. Push the value (I32.CONST (i + 1)) to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (TABLE.INIT x y).

Step_read/load nt_u1 loadop__u1? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If loadop__u1? is not defined, then:
  a. Let nt be nt_u1.
  b. If (((i + ao.OFFSET) + ($size(nt) / 8)) > |$mem(z, 0).BYTES|), then:
    1) Trap.
  c. Let c be $nbytes__1^-1(nt, $mem(z, 0).BYTES[(i + ao.OFFSET) : ($size(nt) / 8)]).
  d. Push the value (nt.CONST c) to the stack.
5. If the type of nt_u1 is Inn, then:
  a. If loadop__u1? is defined, then:
    1) Let ?(loadop__0) be loadop__u1?.
    2) Let (n, sx) be loadop__0.
    3) If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
  b. Let Inn be nt_u1.
  c. If loadop__u1? is defined, then:
    1) Let ?(loadop__0) be loadop__u1?.
    2) Let (n, sx) be loadop__0.
    3) Let c be $ibytes__1^-1(n, $mem(z, 0).BYTES[(i + ao.OFFSET) : (n / 8)]).
    4) Push the value (Inn.CONST $extend__(n, $size(Inn), sx, c)) to the stack.

Step_read/vload V128 vloadop_u1? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. If ((((i + ao.OFFSET) + ($size(V128) / 8)) > |$mem(z, 0).BYTES|) /\ vloadop_u1? is not defined), then:
  a. Trap.
5. If vloadop_u1? is not defined, then:
  a. Let c be $vbytes__1^-1(V128, $mem(z, 0).BYTES[(i + ao.OFFSET) : ($size(V128) / 8)]).
  b. Push the value (V128.CONST c) to the stack.
6. Else:
  a. Let ?(vloadop_0) be vloadop_u1?.
  b. If vloadop_0 is of the case SHAPE, then:
    1) Let (SHAPE M X N sx) be vloadop_0.
    2) If (((i + ao.OFFSET) + ((M * N) / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let j^N be $ibytes__1^-1(M, $mem(z, 0).BYTES[((i + ao.OFFSET) + ((k * M) / 8)) : (M / 8)])^(k<N).
    4) If the type of $lsize^-1((M * 2)) is Jnn, then:
      a) Let Jnn be $lsize^-1((M * 2)).
      b) Let c be $invlanes_(Jnn X N, $extend__(M, $lsize(Jnn), sx, j)^N).
      c) Push the value (V128.CONST c) to the stack.
  c. If vloadop_0 is of the case SPLAT, then:
    1) Let (SPLAT N) be vloadop_0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let M be (128 / N).
    4) If the type of $lsize^-1(N) is Jnn, then:
      a) Let Jnn be $lsize^-1(N).
      b) Let j be $ibytes__1^-1(N, $mem(z, 0).BYTES[(i + ao.OFFSET) : (N / 8)]).
      c) Let c be $invlanes_(Jnn X M, j^M).
      d) Push the value (V128.CONST c) to the stack.
  d. If vloadop_0 is of the case ZERO, then:
    1) Let (ZERO N) be vloadop_0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let j be $ibytes__1^-1(N, $mem(z, 0).BYTES[(i + ao.OFFSET) : (N / 8)]).
    4) Let c be $extend__(N, 128, U, j).
    5) Push the value (V128.CONST c) to the stack.

Step_read/vload_lane V128 N ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c_1) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
7. Let M be (128 / N).
8. If the type of $lsize^-1(N) is Jnn, then:
  a. Let Jnn be $lsize^-1(N).
  b. Let k be $ibytes__1^-1(N, $mem(z, 0).BYTES[(i + ao.OFFSET) : (N / 8)]).
  c. Let c be $invlanes_(Jnn X M, $lanes_(Jnn X M, c_1) with [j] replaced by k).
  d. Push the value (V128.CONST c) to the stack.

Step_read/memory.size
1. Let z be the current state.
2. Let ((n * 64) * $Ki()) be |$mem(z, 0).BYTES|.
3. Push the value (I32.CONST n) to the stack.

Step_read/memory.fill
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. If ((i + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
9. If (n = 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (I32.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (STORE I32 ?(8) $memarg0()).
  d. Push the value (I32.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction MEMORY.FILL.

Step_read/memory.copy
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
9. If ((j + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. If (j <= i), then:
    1) Push the value (I32.CONST j) to the stack.
    2) Push the value (I32.CONST i) to the stack.
    3) Execute the instruction (LOAD I32 ?((8, U)) $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) $memarg0()).
    5) Push the value (I32.CONST (j + 1)) to the stack.
    6) Push the value (I32.CONST (i + 1)) to the stack.
  b. Else:
    1) Push the value (I32.CONST ((j + n) - 1)) to the stack.
    2) Push the value (I32.CONST ((i + n) - 1)) to the stack.
    3) Execute the instruction (LOAD I32 ?((8, U)) $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) $memarg0()).
    5) Push the value (I32.CONST j) to the stack.
    6) Push the value (I32.CONST i) to the stack.
  c. Push the value (I32.CONST (n - 1)) to the stack.
  d. Execute the instruction MEMORY.COPY.

Step_read/memory.init x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST j) from the stack.
8. If ((i + n) > |$data(z, x).BYTES|), then:
  a. Trap.
9. If ((j + n) > |$mem(z, 0).BYTES|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else if (i < |$data(z, x).BYTES|), then:
  a. Push the value (I32.CONST j) to the stack.
  b. Push the value (I32.CONST $data(z, x).BYTES[i]) to the stack.
  c. Execute the instruction (STORE I32 ?(8) $memarg0()).
  d. Push the value (I32.CONST (j + 1)) to the stack.
  e. Push the value (I32.CONST (i + 1)) to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (MEMORY.INIT x).

Step/local.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_local(z, x, val).

Step/global.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_global(z, x, val).

Step/table.set x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
7. Perform $with_table(z, x, i, ref).

Step/table.grow x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type ref is on the top of the stack.
5. Pop the value ref from the stack.
6. Either:
  a. Let ti be $growtable($table(z, x), n, ref).
  b. Push the value (I32.CONST |$table(z, x).REFS|) to the stack.
  c. Perform $with_tableinst(z, x, ti).
7. Or:
  a. Push the value (I32.CONST $invsigned_(32, (- 1))) to the stack.

Step/elem.drop x
1. Let z be the current state.
2. Perform $with_elem(z, x, []).

Step/store nt_u1 sz_u1? ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type nt_u2 is on the top of the stack.
3. Pop the value (nt_u2.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Let nt be nt_u2.
7. If ((((i + ao.OFFSET) + ($size(nt) / 8)) > |$mem(z, 0).BYTES|) /\ ((nt_u1 = nt) /\ sz_u1? is not defined)), then:
  a. Trap.
8. If ((nt_u1 = nt) /\ sz_u1? is not defined), then:
  a. Let b* be $nbytes_(nt, c).
  b. Perform $with_mem(z, 0, (i + ao.OFFSET), ($size(nt) / 8), b*).
9. If the type of nt_u2 is Inn, then:
  a. Let Inn be nt_u2.
  b. If ((nt_u1 = Inn) /\ sz_u1? is defined), then:
    1) Let ?(n) be sz_u1?.
    2) If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, 0).BYTES|), then:
      a) Trap.
    3) Let b* be $ibytes_(n, $wrap__($size(Inn), n, c)).
    4) Perform $with_mem(z, 0, (i + ao.OFFSET), (n / 8), b*).

Step/vstore V128 ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + ($size(V128) / 8)) > |$mem(z, 0).BYTES|), then:
  a. Trap.
7. Let b* be $vbytes_(V128, c).
8. Perform $with_mem(z, 0, (i + ao.OFFSET), ($size(V128) / 8), b*).

Step/vstore_lane V128 N ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If (((i + ao.OFFSET) + N) > |$mem(z, 0).BYTES|), then:
  a. Trap.
7. Let M be (128 / N).
8. If the type of $lsize^-1(N) is Jnn, then:
  a. Let Jnn be $lsize^-1(N).
  b. If (j < |$lanes_(Jnn X M, c)|), then:
    1) Let b* be $ibytes_(N, $lanes_(Jnn X M, c)[j]).
    2) Perform $with_mem(z, 0, (i + ao.OFFSET), (N / 8), b*).

Step/memory.grow
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Either:
  a. Let mi be $growmemory($mem(z, 0), n).
  b. Push the value (I32.CONST (|$mem(z, 0).BYTES| / (64 * $Ki()))) to the stack.
  c. Perform $with_meminst(z, 0, mi).
5. Or:
  a. Push the value (I32.CONST $invsigned_(32, (- 1))) to the stack.

Step/data.drop x
1. Let z be the current state.
2. Perform $with_data(z, x, []).

Ki
1. Return 1024.

min i j
1. If (i <= j), then:
  a. Return i.
2. Return j.

sum n_u1*
1. If (n_u1* = []), then:
  a. Return 0.
2. Let [n] :: n'* be n_u1*.
3. Return (n + $sum(n'*)).

opt_ X X_u1*
1. If (X_u1* = []), then:
  a. Return ?().
2. Assert: Due to validation, (|X_u1*| = 1).
3. Let [w] be X_u1*.
4. Return ?(w).

list_ X X_u1?
1. If X_u1? is not defined, then:
  a. Return [].
2. Let ?(w) be X_u1?.
3. Return [w].

concat_ X X_u1*
1. If (X_u1* = []), then:
  a. Return [].
2. Let [w*] :: w'** be X_u1*.
3. Return w* :: $concat_(X, w'**).

setproduct2_ X w_1 X_u1*
1. If (X_u1* = []), then:
  a. Return [].
2. Let [w'*] :: w** be X_u1*.
3. Return [[w_1] :: w'*] :: $setproduct2_(X, w_1, w**).

setproduct1_ X X_u1* w**
1. If (X_u1* = []), then:
  a. Return [].
2. Let [w_1] :: w'* be X_u1*.
3. Return $setproduct2_(X, w_1, w**) :: $setproduct1_(X, w'*, w**).

setproduct_ X X_u1*
1. If (X_u1* = []), then:
  a. Return [[]].
2. Let [w_1*] :: w** be X_u1*.
3. Return $setproduct1_(X, w_1*, $setproduct_(X, w**)).

signif N_u1
1. If (N_u1 = 32), then:
  a. Return 23.
2. Assert: Due to validation, (N_u1 = 64).
3. Return 52.

expon N_u1
1. If (N_u1 = 32), then:
  a. Return 8.
2. Assert: Due to validation, (N_u1 = 64).
3. Return 11.

M N
1. Return $signif(N).

E N
1. Return $expon(N).

fzero N
1. Return (POS (SUBNORM 0)).

fone N
1. Return (POS (NORM 1 0)).

canon_ N
1. Return (2 ^ ($signif(N) - 1)).

size t_u1
1. If (t_u1 = I32), then:
  a. Return 32.
2. If (t_u1 = I64), then:
  a. Return 64.
3. If (t_u1 = F32), then:
  a. Return 32.
4. If (t_u1 = F64), then:
  a. Return 64.
5. If (t_u1 = V128), then:
  a. Return 128.

isize Inn
1. Return $size(Inn).

psize pt_u1
1. If (pt_u1 = I8), then:
  a. Return 8.
2. Assert: Due to validation, (pt_u1 = I16).
3. Return 16.

lsize lt_u1
1. If the type of lt_u1 is numtype, then:
  a. Let numtype be lt_u1.
  b. Return $size(numtype).
2. Assert: Due to validation, the type of lt_u1 is packtype.
3. Let packtype be lt_u1.
4. Return $psize(packtype).

lanetype Lnn X N
1. Return Lnn.

sizenn nt
1. Return $size(nt).

sizenn1 nt
1. Return $size(nt).

sizenn2 nt
1. Return $size(nt).

lsizenn lt
1. Return $lsize(lt).

lsizenn1 lt
1. Return $lsize(lt).

lsizenn2 lt
1. Return $lsize(lt).

zero nt_u1
1. If the type of nt_u1 is Inn, then:
  a. Return 0.
2. Assert: Due to validation, the type of nt_u1 is Fnn.
3. Let Fnn be nt_u1.
4. Return $fzero($size(Fnn)).

dim Lnn X N
1. Return N.

shsize Lnn X N
1. Return ($lsize(Lnn) * N).

concat_bytes b_u1*
1. If (b_u1* = []), then:
  a. Return [].
2. Let [b*] :: b'** be b_u1*.
3. Return b* :: $concat_bytes(b'**).

unpack lt_u1
1. If the type of lt_u1 is numtype, then:
  a. Let numtype be lt_u1.
  b. Return numtype.
2. Assert: Due to validation, the type of lt_u1 is packtype.
3. Return I32.

shunpack Lnn X N
1. Return $unpack(Lnn).

funcsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is of the case FUNC, then:
  a. Let (FUNC ft) be externtype_0.
  b. Return [ft] :: $funcsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $funcsxt(xt*).

globalsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is of the case GLOBAL, then:
  a. Let (GLOBAL gt) be externtype_0.
  b. Return [gt] :: $globalsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $globalsxt(xt*).

tablesxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is of the case TABLE, then:
  a. Let (TABLE tt) be externtype_0.
  b. Return [tt] :: $tablesxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $tablesxt(xt*).

memsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is of the case MEM, then:
  a. Let (MEM mt) be externtype_0.
  b. Return [mt] :: $memsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $memsxt(xt*).

dataidx_instr in_u1
1. If in_u1 is of the case MEMORY.INIT, then:
  a. Let (MEMORY.INIT x) be in_u1.
  b. Return [x].
2. If in_u1 is of the case DATA.DROP, then:
  a. Let (DATA.DROP x) be in_u1.
  b. Return [x].
3. Return [].

dataidx_instrs in_u1*
1. If (in_u1* = []), then:
  a. Return [].
2. Let [instr] :: instr'* be in_u1*.
3. Return $dataidx_instr(instr) :: $dataidx_instrs(instr'*).

dataidx_expr in*
1. Return $dataidx_instrs(in*).

dataidx_func (FUNC x loc* e)
1. Return $dataidx_expr(e).

dataidx_funcs func_u1*
1. If (func_u1* = []), then:
  a. Return [].
2. Let [func] :: func'* be func_u1*.
3. Return $dataidx_func(func) :: $dataidx_funcs(func'*).

memarg0
1. Return { ALIGN: 0; OFFSET: 0; }.

signed_ N i
1. If (i < (2 ^ (N - 1))), then:
  a. Return i.
2. Assert: Due to validation, ((2 ^ (N - 1)) <= i).
3. Assert: Due to validation, (i < (2 ^ N)).
4. Return (i - (2 ^ N)).

invsigned_ N i
1. Let j be $signed__1^-1(N, i).
2. Return j.

unop_ nt_u1 unop_u1 i_u1
1. If the type of nt_u1 is Inn, then:
  a. Let Inn be nt_u1.
  b. Let iN be i_u1.
  c. If (unop_u1 = CLZ), then:
    1) Return [$iclz_($sizenn(Inn), iN)].
  d. If (unop_u1 = CTZ), then:
    1) Return [$ictz_($sizenn(Inn), iN)].
  e. If (unop_u1 = POPCNT), then:
    1) Return [$ipopcnt_($sizenn(Inn), iN)].
  f. Assert: Due to validation, unop_u1 is of the case EXTEND.
  g. Let (EXTEND M) be unop_u1.
  h. Return [$extend__(M, $sizenn(Inn), S, $wrap__($sizenn(Inn), M, iN))].
2. Assert: Due to validation, the type of nt_u1 is Fnn.
3. Let Fnn be nt_u1.
4. Let fN be i_u1.
5. If (unop_u1 = ABS), then:
  a. Return $fabs_($sizenn(Fnn), fN).
6. If (unop_u1 = NEG), then:
  a. Return $fneg_($sizenn(Fnn), fN).
7. If (unop_u1 = SQRT), then:
  a. Return $fsqrt_($sizenn(Fnn), fN).
8. If (unop_u1 = CEIL), then:
  a. Return $fceil_($sizenn(Fnn), fN).
9. If (unop_u1 = FLOOR), then:
  a. Return $ffloor_($sizenn(Fnn), fN).
10. If (unop_u1 = TRUNC), then:
  a. Return $ftrunc_($sizenn(Fnn), fN).
11. Assert: Due to validation, (unop_u1 = NEAREST).
12. Return $fnearest_($sizenn(Fnn), fN).

binop_ nt_u1 binop_u1 i_u1 i_u2
1. If the type of nt_u1 is Inn, then:
  a. Let Inn be nt_u1.
  b. Let iN_1 be i_u1.
  c. Let iN_2 be i_u2.
  d. If (binop_u1 = ADD), then:
    1) Return [$iadd_($sizenn(Inn), iN_1, iN_2)].
  e. If (binop_u1 = SUB), then:
    1) Return [$isub_($sizenn(Inn), iN_1, iN_2)].
  f. If (binop_u1 = MUL), then:
    1) Return [$imul_($sizenn(Inn), iN_1, iN_2)].
  g. If binop_u1 is of the case DIV, then:
    1) Let (DIV sx) be binop_u1.
    2) Return $list_(num_((Inn : Inn <: numtype)), $idiv_($sizenn(Inn), sx, iN_1, iN_2)).
  h. If binop_u1 is of the case REM, then:
    1) Let (REM sx) be binop_u1.
    2) Return $list_(num_((Inn : Inn <: numtype)), $irem_($sizenn(Inn), sx, iN_1, iN_2)).
  i. If (binop_u1 = AND), then:
    1) Return [$iand_($sizenn(Inn), iN_1, iN_2)].
  j. If (binop_u1 = OR), then:
    1) Return [$ior_($sizenn(Inn), iN_1, iN_2)].
  k. If (binop_u1 = XOR), then:
    1) Return [$ixor_($sizenn(Inn), iN_1, iN_2)].
  l. If (binop_u1 = SHL), then:
    1) Return [$ishl_($sizenn(Inn), iN_1, iN_2)].
  m. If binop_u1 is of the case SHR, then:
    1) Let (SHR sx) be binop_u1.
    2) Return [$ishr_($sizenn(Inn), sx, iN_1, iN_2)].
  n. If (binop_u1 = ROTL), then:
    1) Return [$irotl_($sizenn(Inn), iN_1, iN_2)].
  o. If (binop_u1 = ROTR), then:
    1) Return [$irotr_($sizenn(Inn), iN_1, iN_2)].
2. Assert: Due to validation, the type of nt_u1 is Fnn.
3. Let Fnn be nt_u1.
4. Let fN_1 be i_u1.
5. Let fN_2 be i_u2.
6. If (binop_u1 = ADD), then:
  a. Return $fadd_($sizenn(Fnn), fN_1, fN_2).
7. If (binop_u1 = SUB), then:
  a. Return $fsub_($sizenn(Fnn), fN_1, fN_2).
8. If (binop_u1 = MUL), then:
  a. Return $fmul_($sizenn(Fnn), fN_1, fN_2).
9. If (binop_u1 = DIV), then:
  a. Return $fdiv_($sizenn(Fnn), fN_1, fN_2).
10. If (binop_u1 = MIN), then:
  a. Return $fmin_($sizenn(Fnn), fN_1, fN_2).
11. If (binop_u1 = MAX), then:
  a. Return $fmax_($sizenn(Fnn), fN_1, fN_2).
12. Assert: Due to validation, (binop_u1 = COPYSIGN).
13. Return $fcopysign_($sizenn(Fnn), fN_1, fN_2).

testop_ Inn EQZ iN
1. Return $ieqz_($sizenn(Inn), iN).

relop_ nt_u1 relop_u1 i_u1 i_u2
1. If the type of nt_u1 is Inn, then:
  a. Let Inn be nt_u1.
  b. Let iN_1 be i_u1.
  c. Let iN_2 be i_u2.
  d. If (relop_u1 = EQ), then:
    1) Return $ieq_($sizenn(Inn), iN_1, iN_2).
  e. If (relop_u1 = NE), then:
    1) Return $ine_($sizenn(Inn), iN_1, iN_2).
  f. If relop_u1 is of the case LT, then:
    1) Let (LT sx) be relop_u1.
    2) Return $ilt_($sizenn(Inn), sx, iN_1, iN_2).
  g. If relop_u1 is of the case GT, then:
    1) Let (GT sx) be relop_u1.
    2) Return $igt_($sizenn(Inn), sx, iN_1, iN_2).
  h. If relop_u1 is of the case LE, then:
    1) Let (LE sx) be relop_u1.
    2) Return $ile_($sizenn(Inn), sx, iN_1, iN_2).
  i. If relop_u1 is of the case GE, then:
    1) Let (GE sx) be relop_u1.
    2) Return $ige_($sizenn(Inn), sx, iN_1, iN_2).
2. Assert: Due to validation, the type of nt_u1 is Fnn.
3. Let Fnn be nt_u1.
4. Let fN_1 be i_u1.
5. Let fN_2 be i_u2.
6. If (relop_u1 = EQ), then:
  a. Return $feq_($sizenn(Fnn), fN_1, fN_2).
7. If (relop_u1 = NE), then:
  a. Return $fne_($sizenn(Fnn), fN_1, fN_2).
8. If (relop_u1 = LT), then:
  a. Return $flt_($sizenn(Fnn), fN_1, fN_2).
9. If (relop_u1 = GT), then:
  a. Return $fgt_($sizenn(Fnn), fN_1, fN_2).
10. If (relop_u1 = LE), then:
  a. Return $fle_($sizenn(Fnn), fN_1, fN_2).
11. Assert: Due to validation, (relop_u1 = GE).
12. Return $fge_($sizenn(Fnn), fN_1, fN_2).

cvtop__ nt_u1 nt_u3 cvtop_u1 i_u1
1. If the type of nt_u1 is Inn, then:
  a. Let Inn_1 be nt_u1.
  b. If the type of nt_u3 is Inn, then:
    1) Let Inn_2 be nt_u3.
    2) If cvtop_u1 is of the case EXTEND, then:
      a) Let (EXTEND sx) be cvtop_u1.
      b) Let iN_1 be i_u1.
      c) Return [$extend__($sizenn1(Inn_1), $sizenn2(Inn_2), sx, iN_1)].
    3) Let iN_1 be i_u1.
    4) If (cvtop_u1 = WRAP), then:
      a) Return [$wrap__($sizenn1(Inn_1), $sizenn2(Inn_2), iN_1)].
2. If the type of nt_u1 is Fnn, then:
  a. Let Fnn_1 be nt_u1.
  b. If the type of nt_u3 is Inn, then:
    1) Let Inn_2 be nt_u3.
    2) If cvtop_u1 is of the case TRUNC, then:
      a) Let (TRUNC sx) be cvtop_u1.
      b) Let fN_1 be i_u1.
      c) Return $list_(num_((Inn_2 : Inn <: numtype)), $trunc__($sizenn1(Fnn_1), $sizenn2(Inn_2), sx, fN_1)).
    3) If cvtop_u1 is of the case TRUNC_SAT, then:
      a) Let (TRUNC_SAT sx) be cvtop_u1.
      b) Let fN_1 be i_u1.
      c) Return $list_(num_((Inn_2 : Inn <: numtype)), $trunc_sat__($sizenn1(Fnn_1), $sizenn2(Inn_2), sx, fN_1)).
3. If the type of nt_u1 is Inn, then:
  a. Let Inn_1 be nt_u1.
  b. If the type of nt_u3 is Fnn, then:
    1) Let Fnn_2 be nt_u3.
    2) If cvtop_u1 is of the case CONVERT, then:
      a) Let (CONVERT sx) be cvtop_u1.
      b) Let iN_1 be i_u1.
      c) Return [$convert__($sizenn1(Inn_1), $sizenn2(Fnn_2), sx, iN_1)].
4. If the type of nt_u1 is Fnn, then:
  a. Let Fnn_1 be nt_u1.
  b. If the type of nt_u3 is Fnn, then:
    1) Let Fnn_2 be nt_u3.
    2) Let fN_1 be i_u1.
    3) If (cvtop_u1 = PROMOTE), then:
      a) Return $promote__($sizenn1(Fnn_1), $sizenn2(Fnn_2), fN_1).
    4) If (cvtop_u1 = DEMOTE), then:
      a) Return $demote__($sizenn1(Fnn_1), $sizenn2(Fnn_2), fN_1).
5. If the type of nt_u1 is Inn, then:
  a. Let Inn_1 be nt_u1.
  b. If the type of nt_u3 is Fnn, then:
    1) Let Fnn_2 be nt_u3.
    2) Let iN_1 be i_u1.
    3) If ((cvtop_u1 = REINTERPRET) /\ ($size(Inn_1) = $size(Fnn_2))), then:
      a) Return [$reinterpret__(Inn_1, Fnn_2, iN_1)].
6. Assert: Due to validation, the type of nt_u1 is Fnn.
7. Let Fnn_1 be nt_u1.
8. Assert: Due to validation, the type of nt_u3 is Inn.
9. Let Inn_2 be nt_u3.
10. Let fN_1 be i_u1.
11. Assert: Due to validation, (cvtop_u1 = REINTERPRET).
12. Assert: Due to validation, ($size(Fnn_1) = $size(Inn_2)).
13. Return [$reinterpret__(Fnn_1, Inn_2, fN_1)].

invibytes_ N b*
1. Let n be $ibytes__1^-1(N, b*).
2. Return n.

invfbytes_ N b*
1. Let p be $fbytes__1^-1(N, b*).
2. Return p.

packnum_ lt_u1 c
1. If the type of lt_u1 is numtype, then:
  a. Return c.
2. Assert: Due to validation, the type of lt_u1 is packtype.
3. Let packtype be lt_u1.
4. Return $wrap__($size($unpack(packtype)), $psize(packtype), c).

unpacknum_ lt_u1 c
1. If the type of lt_u1 is numtype, then:
  a. Return c.
2. Assert: Due to validation, the type of lt_u1 is packtype.
3. Let packtype be lt_u1.
4. Return $extend__($psize(packtype), $size($unpack(packtype)), U, c).

invlanes_ sh c*
1. Let vc be $lanes__1^-1(sh, c*).
2. Return vc.

half hf_u1 i j
1. If (hf_u1 = LOW), then:
  a. Return i.
2. Assert: Due to validation, (hf_u1 = HIGH).
3. Return j.

vvunop_ V128 NOT v128
1. Return $inot_($size(V128), v128).

vvbinop_ V128 vvbinop_u1 v128_1 v128_2
1. If (vvbinop_u1 = AND), then:
  a. Return $iand_($size(V128), v128_1, v128_2).
2. If (vvbinop_u1 = ANDNOT), then:
  a. Return $iandnot_($size(V128), v128_1, v128_2).
3. If (vvbinop_u1 = OR), then:
  a. Return $ior_($size(V128), v128_1, v128_2).
4. Assert: Due to validation, (vvbinop_u1 = XOR).
5. Return $ixor_($size(V128), v128_1, v128_2).

vvternop_ V128 BITSELECT v128_1 v128_2 v128_3
1. Return $ibitselect_($size(V128), v128_1, v128_2, v128_3).

vunop_ lt_u1 X M vunop_u1 v128_1
1. If the type of lt_u1 is Jnn, then:
  a. Let Jnn be lt_u1.
  b. If (vunop_u1 = ABS), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let v128 be $invlanes_(Jnn X M, $iabs_($lsizenn(Jnn), lane_1)*).
    3) Return [v128].
  c. If (vunop_u1 = NEG), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let v128 be $invlanes_(Jnn X M, $ineg_($lsizenn(Jnn), lane_1)*).
    3) Return [v128].
  d. If (vunop_u1 = POPCNT), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let v128 be $invlanes_(Jnn X M, $ipopcnt_($lsizenn(Jnn), lane_1)*).
    3) Return [v128].
2. Assert: Due to validation, the type of lt_u1 is Fnn.
3. Let Fnn be lt_u1.
4. If (vunop_u1 = ABS), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fabs_($sizenn(Fnn), lane_1)*).
  c. Let v128* be $invlanes_(Fnn X M, lane*)*.
  d. Return v128*.
5. If (vunop_u1 = NEG), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fneg_($sizenn(Fnn), lane_1)*).
  c. Let v128* be $invlanes_(Fnn X M, lane*)*.
  d. Return v128*.
6. If (vunop_u1 = SQRT), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fsqrt_($sizenn(Fnn), lane_1)*).
  c. Let v128* be $invlanes_(Fnn X M, lane*)*.
  d. Return v128*.
7. If (vunop_u1 = CEIL), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fceil_($sizenn(Fnn), lane_1)*).
  c. Let v128* be $invlanes_(Fnn X M, lane*)*.
  d. Return v128*.
8. If (vunop_u1 = FLOOR), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $ffloor_($sizenn(Fnn), lane_1)*).
  c. Let v128* be $invlanes_(Fnn X M, lane*)*.
  d. Return v128*.
9. If (vunop_u1 = TRUNC), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $ftrunc_($sizenn(Fnn), lane_1)*).
  c. Let v128* be $invlanes_(Fnn X M, lane*)*.
  d. Return v128*.
10. Assert: Due to validation, (vunop_u1 = NEAREST).
11. Let lane_1* be $lanes_(Fnn X M, v128_1).
12. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fnearest_($sizenn(Fnn), lane_1)*).
13. Let v128* be $invlanes_(Fnn X M, lane*)*.
14. Return v128*.

vbinop_ lt_u1 X M vbinop_u1 v128_1 v128_2
1. If the type of lt_u1 is Jnn, then:
  a. Let Jnn be lt_u1.
  b. If (vbinop_u1 = ADD), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let lane_2* be $lanes_(Jnn X M, v128_2).
    3) Let v128 be $invlanes_(Jnn X M, $iadd_($lsizenn(Jnn), lane_1, lane_2)*).
    4) Return [v128].
  c. If (vbinop_u1 = SUB), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let lane_2* be $lanes_(Jnn X M, v128_2).
    3) Let v128 be $invlanes_(Jnn X M, $isub_($lsizenn(Jnn), lane_1, lane_2)*).
    4) Return [v128].
  d. If vbinop_u1 is of the case MIN, then:
    1) Let (MIN sx) be vbinop_u1.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let v128 be $invlanes_(Jnn X M, $imin_($lsizenn(Jnn), sx, lane_1, lane_2)*).
    5) Return [v128].
  e. If vbinop_u1 is of the case MAX, then:
    1) Let (MAX sx) be vbinop_u1.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let v128 be $invlanes_(Jnn X M, $imax_($lsizenn(Jnn), sx, lane_1, lane_2)*).
    5) Return [v128].
  f. If vbinop_u1 is of the case ADD_SAT, then:
    1) Let (ADD_SAT sx) be vbinop_u1.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let v128 be $invlanes_(Jnn X M, $iadd_sat_($lsizenn(Jnn), sx, lane_1, lane_2)*).
    5) Return [v128].
  g. If vbinop_u1 is of the case SUB_SAT, then:
    1) Let (SUB_SAT sx) be vbinop_u1.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let v128 be $invlanes_(Jnn X M, $isub_sat_($lsizenn(Jnn), sx, lane_1, lane_2)*).
    5) Return [v128].
  h. If (vbinop_u1 = MUL), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let lane_2* be $lanes_(Jnn X M, v128_2).
    3) Let v128 be $invlanes_(Jnn X M, $imul_($lsizenn(Jnn), lane_1, lane_2)*).
    4) Return [v128].
  i. If (vbinop_u1 = AVGRU), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let lane_2* be $lanes_(Jnn X M, v128_2).
    3) Let v128 be $invlanes_(Jnn X M, $iavgr_($lsizenn(Jnn), U, lane_1, lane_2)*).
    4) Return [v128].
  j. If (vbinop_u1 = Q15MULR_SATS), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let lane_2* be $lanes_(Jnn X M, v128_2).
    3) Let v128 be $invlanes_(Jnn X M, $iq15mulr_sat_($lsizenn(Jnn), S, lane_1, lane_2)*).
    4) Return [v128].
2. Assert: Due to validation, the type of lt_u1 is Fnn.
3. Let Fnn be lt_u1.
4. If (vbinop_u1 = ADD), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fadd_($sizenn(Fnn), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
5. If (vbinop_u1 = SUB), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fsub_($sizenn(Fnn), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
6. If (vbinop_u1 = MUL), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fmul_($sizenn(Fnn), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
7. If (vbinop_u1 = DIV), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fdiv_($sizenn(Fnn), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
8. If (vbinop_u1 = MIN), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fmin_($sizenn(Fnn), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
9. If (vbinop_u1 = MAX), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fmax_($sizenn(Fnn), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
10. If (vbinop_u1 = PMIN), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fpmin_($sizenn(Fnn), lane_1, lane_2)*).
  d. Let v128* be $invlanes_(Fnn X M, lane*)*.
  e. Return v128*.
11. Assert: Due to validation, (vbinop_u1 = PMAX).
12. Let lane_1* be $lanes_(Fnn X M, v128_1).
13. Let lane_2* be $lanes_(Fnn X M, v128_2).
14. Let lane** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $fpmax_($sizenn(Fnn), lane_1, lane_2)*).
15. Let v128* be $invlanes_(Fnn X M, lane*)*.
16. Return v128*.

vrelop_ lt_u1 X M vrelop_u1 v128_1 v128_2
1. If the type of lt_u1 is Jnn, then:
  a. Let Jnn be lt_u1.
  b. If (vrelop_u1 = EQ), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let lane_2* be $lanes_(Jnn X M, v128_2).
    3) Let lane_3* be $extend__(1, $lsizenn(Jnn), S, $ieq_($lsizenn(Jnn), lane_1, lane_2))*.
    4) Let v128 be $invlanes_(Jnn X M, lane_3*).
    5) Return v128.
  c. If (vrelop_u1 = NE), then:
    1) Let lane_1* be $lanes_(Jnn X M, v128_1).
    2) Let lane_2* be $lanes_(Jnn X M, v128_2).
    3) Let lane_3* be $extend__(1, $lsizenn(Jnn), S, $ine_($lsizenn(Jnn), lane_1, lane_2))*.
    4) Let v128 be $invlanes_(Jnn X M, lane_3*).
    5) Return v128.
  d. If vrelop_u1 is of the case LT, then:
    1) Let (LT sx) be vrelop_u1.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let lane_3* be $extend__(1, $lsizenn(Jnn), S, $ilt_($lsizenn(Jnn), sx, lane_1, lane_2))*.
    5) Let v128 be $invlanes_(Jnn X M, lane_3*).
    6) Return v128.
  e. If vrelop_u1 is of the case GT, then:
    1) Let (GT sx) be vrelop_u1.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let lane_3* be $extend__(1, $lsizenn(Jnn), S, $igt_($lsizenn(Jnn), sx, lane_1, lane_2))*.
    5) Let v128 be $invlanes_(Jnn X M, lane_3*).
    6) Return v128.
  f. If vrelop_u1 is of the case LE, then:
    1) Let (LE sx) be vrelop_u1.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let lane_3* be $extend__(1, $lsizenn(Jnn), S, $ile_($lsizenn(Jnn), sx, lane_1, lane_2))*.
    5) Let v128 be $invlanes_(Jnn X M, lane_3*).
    6) Return v128.
  g. If vrelop_u1 is of the case GE, then:
    1) Let (GE sx) be vrelop_u1.
    2) Let lane_1* be $lanes_(Jnn X M, v128_1).
    3) Let lane_2* be $lanes_(Jnn X M, v128_2).
    4) Let lane_3* be $extend__(1, $lsizenn(Jnn), S, $ige_($lsizenn(Jnn), sx, lane_1, lane_2))*.
    5) Let v128 be $invlanes_(Jnn X M, lane_3*).
    6) Return v128.
2. Assert: Due to validation, the type of lt_u1 is Fnn.
3. Let Fnn be lt_u1.
4. If (vrelop_u1 = EQ), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let Inn be $isize^-1($size(Fnn)).
  d. Let lane_3* be $extend__(1, $sizenn(Fnn), S, $feq_($sizenn(Fnn), lane_1, lane_2))*.
  e. Let v128 be $invlanes_(Inn X M, lane_3*).
  f. Return v128.
5. If (vrelop_u1 = NE), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let Inn be $isize^-1($size(Fnn)).
  d. Let lane_3* be $extend__(1, $sizenn(Fnn), S, $fne_($sizenn(Fnn), lane_1, lane_2))*.
  e. Let v128 be $invlanes_(Inn X M, lane_3*).
  f. Return v128.
6. If (vrelop_u1 = LT), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let Inn be $isize^-1($size(Fnn)).
  d. Let lane_3* be $extend__(1, $sizenn(Fnn), S, $flt_($sizenn(Fnn), lane_1, lane_2))*.
  e. Let v128 be $invlanes_(Inn X M, lane_3*).
  f. Return v128.
7. If (vrelop_u1 = GT), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let Inn be $isize^-1($size(Fnn)).
  d. Let lane_3* be $extend__(1, $sizenn(Fnn), S, $fgt_($sizenn(Fnn), lane_1, lane_2))*.
  e. Let v128 be $invlanes_(Inn X M, lane_3*).
  f. Return v128.
8. If (vrelop_u1 = LE), then:
  a. Let lane_1* be $lanes_(Fnn X M, v128_1).
  b. Let lane_2* be $lanes_(Fnn X M, v128_2).
  c. Let Inn be $isize^-1($size(Fnn)).
  d. Let lane_3* be $extend__(1, $sizenn(Fnn), S, $fle_($sizenn(Fnn), lane_1, lane_2))*.
  e. Let v128 be $invlanes_(Inn X M, lane_3*).
  f. Return v128.
9. Assert: Due to validation, (vrelop_u1 = GE).
10. Let lane_1* be $lanes_(Fnn X M, v128_1).
11. Let lane_2* be $lanes_(Fnn X M, v128_2).
12. Let Inn be $isize^-1($size(Fnn)).
13. Let lane_3* be $extend__(1, $sizenn(Fnn), S, $fge_($sizenn(Fnn), lane_1, lane_2))*.
14. Let v128 be $invlanes_(Inn X M, lane_3*).
15. Return v128.

vcvtop__ lt_u2 X M_1 lt_u1 X M_2 vcvtop_u1 c_u1
1. If the type of lt_u2 is Jnn, then:
  a. Let Jnn_1 be lt_u2.
  b. If the type of lt_u1 is Jnn, then:
    1) Let Jnn_2 be lt_u1.
    2) If vcvtop_u1 is of the case EXTEND, then:
      a) Let (EXTEND sx) be vcvtop_u1.
      b) Let iN_1 be c_u1.
      c) Let iN_2 be $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx, iN_1).
      d) Return [iN_2].
  c. If the type of lt_u1 is Fnn, then:
    1) Let Fnn_2 be lt_u1.
    2) If vcvtop_u1 is of the case CONVERT, then:
      a) Let (CONVERT sx) be vcvtop_u1.
      b) Let iN_1 be c_u1.
      c) Let fN_2 be $convert__($lsizenn1(Jnn_1), $lsizenn2(Fnn_2), sx, iN_1).
      d) Return [fN_2].
2. Assert: Due to validation, the type of lt_u2 is Fnn.
3. Let Fnn_1 be lt_u2.
4. If the type of lt_u1 is Inn, then:
  a. Let Inn_2 be lt_u1.
  b. If vcvtop_u1 is of the case TRUNC_SAT, then:
    1) Let (TRUNC_SAT sx) be vcvtop_u1.
    2) Let fN_1 be c_u1.
    3) Let iN_2? be $trunc_sat__($lsizenn1(Fnn_1), $lsizenn2(Inn_2), sx, fN_1).
    4) Return $list_(lane_((Inn_2 : Inn <: lanetype)), iN_2?).
5. Assert: Due to validation, the type of lt_u1 is Fnn.
6. Let Fnn_2 be lt_u1.
7. Let fN_1 be c_u1.
8. If (vcvtop_u1 = DEMOTE), then:
  a. Let fN_2* be $demote__($lsizenn1(Fnn_1), $lsizenn2(Fnn_2), fN_1).
  b. Return fN_2*.
9. Assert: Due to validation, (vcvtop_u1 = PROMOTE).
10. Let fN_2* be $promote__($lsizenn1(Fnn_1), $lsizenn2(Fnn_2), fN_1).
11. Return fN_2*.

vextunop__ Inn_1 X M_1 Inn_2 X M_2 (EXTADD_PAIRWISE sx) c_1
1. Let ci* be $lanes_(Inn_2 X M_2, c_1).
2. Let [cj_1, cj_2]* be $concat__1^-1(iN($lsizenn1((Inn_1 : Inn <: lanetype))), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), sx, ci)*).
3. Let c be $invlanes_(Inn_1 X M_1, $iadd_($lsizenn1(Inn_1), cj_1, cj_2)*).
4. Return c.

vextbinop__ Inn_1 X M_1 Inn_2 X M_2 vextbinop_u1 c_1 c_2
1. If vextbinop_u1 is of the case EXTMUL, then:
  a. Let (EXTMUL sx hf) be vextbinop_u1.
  b. Let ci_1* be $lanes_(Inn_2 X M_2, c_1)[$half(hf, 0, M_1) : M_1].
  c. Let ci_2* be $lanes_(Inn_2 X M_2, c_2)[$half(hf, 0, M_1) : M_1].
  d. Let c be $invlanes_(Inn_1 X M_1, $imul_($lsizenn1(Inn_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), sx, ci_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), sx, ci_2))*).
  e. Return c.
2. Assert: Due to validation, (vextbinop_u1 = DOTS).
3. Let ci_1* be $lanes_(Inn_2 X M_2, c_1).
4. Let ci_2* be $lanes_(Inn_2 X M_2, c_2).
5. Let [cj_1, cj_2]* be $concat__1^-1(iN($lsizenn1((Inn_1 : Inn <: lanetype))), $imul_($lsizenn1(Inn_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), S, ci_1), $extend__($lsizenn2(Inn_2), $lsizenn1(Inn_1), S, ci_2))*).
6. Let c be $invlanes_(Inn_1 X M_1, $iadd_($lsizenn1(Inn_1), cj_1, cj_2)*).
7. Return c.

vshiftop_ Jnn X M vshiftop_u1 lane n
1. If (vshiftop_u1 = SHL), then:
  a. Return $ishl_($lsizenn(Jnn), lane, n).
2. Assert: Due to validation, vshiftop_u1 is of the case SHR.
3. Let (SHR sx) be vshiftop_u1.
4. Return $ishr_($lsizenn(Jnn), sx, lane, n).

default_ t_u1
1. If (t_u1 = I32), then:
  a. Return (I32.CONST 0).
2. If (t_u1 = I64), then:
  a. Return (I64.CONST 0).
3. If (t_u1 = F32), then:
  a. Return (F32.CONST $fzero(32)).
4. If (t_u1 = F64), then:
  a. Return (F64.CONST $fzero(64)).
5. If (t_u1 = V128), then:
  a. Return (V128.CONST 0).
6. If (t_u1 = FUNCREF), then:
  a. Return (REF.NULL FUNCREF).
7. Assert: Due to validation, (t_u1 = EXTERNREF).
8. Return (REF.NULL EXTERNREF).

funcsxa xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be xv_u1*.
3. If externaddr_0 is of the case FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcsxa(xv*).
4. Let [externaddr] :: xv* be xv_u1*.
5. Return $funcsxa(xv*).

globalsxa xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be xv_u1*.
3. If externaddr_0 is of the case GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globalsxa(xv*).
4. Let [externaddr] :: xv* be xv_u1*.
5. Return $globalsxa(xv*).

tablesxa xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be xv_u1*.
3. If externaddr_0 is of the case TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tablesxa(xv*).
4. Let [externaddr] :: xv* be xv_u1*.
5. Return $tablesxa(xv*).

memsxa xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xv* be xv_u1*.
3. If externaddr_0 is of the case MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $memsxa(xv*).
4. Let [externaddr] :: xv* be xv_u1*.
5. Return $memsxa(xv*).

store z
1. Return.

frame z
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return f.

funcaddr z
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return f.MODULE.FUNCS.

funcinst z
1. Return s.FUNCS.

globalinst z
1. Return s.GLOBALS.

tableinst z
1. Return s.TABLES.

meminst z
1. Return s.MEMS.

eleminst z
1. Return s.ELEMS.

datainst z
1. Return s.DATAS.

moduleinst z
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return f.MODULE.

type z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return f.MODULE.TYPES[x].

func z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return s.FUNCS[f.MODULE.FUNCS[x]].

global z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return s.GLOBALS[f.MODULE.GLOBALS[x]].

table z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return s.TABLES[f.MODULE.TABLES[x]].

mem z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return s.MEMS[f.MODULE.MEMS[x]].

elem z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return s.ELEMS[f.MODULE.ELEMS[x]].

data z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return s.DATAS[f.MODULE.DATAS[x]].

local z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return f.LOCALS[x].

with_local z x v
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace f.LOCALS[x] with v.

with_global z x v
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace s.GLOBALS[f.MODULE.GLOBALS[x]].VALUE with v.

with_table z x i r
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace s.TABLES[f.MODULE.TABLES[x]].REFS[i] with r.

with_tableinst z x ti
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace s.TABLES[f.MODULE.TABLES[x]] with ti.

with_mem z x i j b*
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace s.MEMS[f.MODULE.MEMS[x]].BYTES[i : j] with b*.

with_meminst z x mi
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace s.MEMS[f.MODULE.MEMS[x]] with mi.

with_elem z x r*
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace s.ELEMS[f.MODULE.ELEMS[x]].REFS with r*.

with_data z x b*
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace s.DATAS[f.MODULE.DATAS[x]].BYTES with b*.

growtable ti n r
1. Let { TYPE: (([ i .. j ]), rt); REFS: r'*; } be ti.
2. Let i' be (|r'*| + n).
3. If (i' <= j), then:
  a. Let ti' be { TYPE: (([ i' .. j ]), rt); REFS: r'* :: r^n; }.
  b. Return ti'.

growmemory mi n
1. Let { TYPE: ([ i .. j ]) PAGE; BYTES: b*; } be mi.
2. Let i' be ((|b*| / (64 * $Ki())) + n).
3. If (i' <= j), then:
  a. Let mi' be { TYPE: ([ i' .. j ]) PAGE; BYTES: b* :: 0^(n * (64 * $Ki())); }.
  b. Return mi'.

blocktype z bt_u1
1. If (bt_u1 = (_RESULT ?())), then:
  a. Return [] -> [].
2. If bt_u1 is of the case _RESULT, then:
  a. Let (_RESULT valtype_0?) be bt_u1.
  b. If valtype_0? is defined, then:
    1) Let ?(t) be valtype_0?.
    2) Return [] -> [t].
3. Assert: Due to validation, bt_u1 is of the case _IDX.
4. Let (_IDX x) be bt_u1.
5. Return $type(z, x).

funcs xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be xv_u1*.
3. If externaddr_0 is of the case FUNC, then:
  a. Let (FUNC fa) be externaddr_0.
  b. Return [fa] :: $funcs(externaddr'*).
4. Let [externaddr] :: externaddr'* be xv_u1*.
5. Return $funcs(externaddr'*).

globals xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be xv_u1*.
3. If externaddr_0 is of the case GLOBAL, then:
  a. Let (GLOBAL ga) be externaddr_0.
  b. Return [ga] :: $globals(externaddr'*).
4. Let [externaddr] :: externaddr'* be xv_u1*.
5. Return $globals(externaddr'*).

tables xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be xv_u1*.
3. If externaddr_0 is of the case TABLE, then:
  a. Let (TABLE ta) be externaddr_0.
  b. Return [ta] :: $tables(externaddr'*).
4. Let [externaddr] :: externaddr'* be xv_u1*.
5. Return $tables(externaddr'*).

mems xv_u1*
1. If (xv_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: externaddr'* be xv_u1*.
3. If externaddr_0 is of the case MEM, then:
  a. Let (MEM ma) be externaddr_0.
  b. Return [ma] :: $mems(externaddr'*).
4. Let [externaddr] :: externaddr'* be xv_u1*.
5. Return $mems(externaddr'*).

allocfunc s moduleinst func
1. Assert: Due to validation, func is of the case FUNC.
2. Let (FUNC x local* expr) be func.
3. Let fi be { TYPE: moduleinst.TYPES[x]; MODULE: moduleinst; CODE: func; }.
4. Let a be |s.FUNCS|.
5. Append fi to the s.FUNCS.
6. Return a.

allocfuncs s moduleinst func_u1*
1. If (func_u1* = []), then:
  a. Return [].
2. Let [func] :: func'* be func_u1*.
3. Let fa be $allocfunc(s, moduleinst, func).
4. Let fa'* be $allocfuncs(s, moduleinst, func'*).
5. Return [fa] :: fa'*.

allocglobal s globaltype val
1. Let gi be { TYPE: globaltype; VALUE: val; }.
2. Let a be |s.GLOBALS|.
3. Append gi to the s.GLOBALS.
4. Return a.

allocglobals s gt_u1* v_u1*
1. If (gt_u1* = []), then:
  a. Assert: Due to validation, (v_u1* = []).
  b. Return [].
2. Else:
  a. Let [globaltype] :: globaltype'* be gt_u1*.
  b. Assert: Due to validation, (|v_u1*| >= 1).
  c. Let [val] :: val'* be v_u1*.
  d. Let ga be $allocglobal(s, globaltype, val).
  e. Let ga'* be $allocglobals(s, globaltype'*, val'*).
  f. Return [ga] :: ga'*.

alloctable s (([ i .. j ]), rt)
1. Let ti be { TYPE: (([ i .. j ]), rt); REFS: (REF.NULL rt)^i; }.
2. Let a be |s.TABLES|.
3. Append ti to the s.TABLES.
4. Return a.

alloctables s tt_u1*
1. If (tt_u1* = []), then:
  a. Return [].
2. Let [tabletype] :: tabletype'* be tt_u1*.
3. Let ta be $alloctable(s, tabletype).
4. Let ta'* be $alloctables(s, tabletype'*).
5. Return [ta] :: ta'*.

allocmem s ([ i .. j ]) PAGE
1. Let mi be { TYPE: ([ i .. j ]) PAGE; BYTES: 0^(i * (64 * $Ki())); }.
2. Let a be |s.MEMS|.
3. Append mi to the s.MEMS.
4. Return a.

allocmems s mt_u1*
1. If (mt_u1* = []), then:
  a. Return [].
2. Let [memtype] :: memtype'* be mt_u1*.
3. Let ma be $allocmem(s, memtype).
4. Let ma'* be $allocmems(s, memtype'*).
5. Return [ma] :: ma'*.

allocelem s rt ref*
1. Let ei be { TYPE: rt; REFS: ref*; }.
2. Let a be |s.ELEMS|.
3. Append ei to the s.ELEMS.
4. Return a.

allocelems s rt_u1* r_u1*
1. If ((rt_u1* = []) /\ (r_u1* = [])), then:
  a. Return [].
2. Assert: Due to validation, (|r_u1*| >= 1).
3. Let [ref*] :: ref'** be r_u1*.
4. Assert: Due to validation, (|rt_u1*| >= 1).
5. Let [rt] :: rt'* be rt_u1*.
6. Let ea be $allocelem(s, rt, ref*).
7. Let ea'* be $allocelems(s, rt'*, ref'**).
8. Return [ea] :: ea'*.

allocdata s byte*
1. Let di be { BYTES: byte*; }.
2. Let a be |s.DATAS|.
3. Append di to the s.DATAS.
4. Return a.

allocdatas s b_u1*
1. If (b_u1* = []), then:
  a. Return [].
2. Let [byte*] :: byte'** be b_u1*.
3. Let da be $allocdata(s, byte*).
4. Let da'* be $allocdatas(s, byte'**).
5. Return [da] :: da'*.

instexport fa* ga* ta* ma* (EXPORT name externidx_u1)
1. If externidx_u1 is of the case FUNC, then:
  a. Let (FUNC x) be externidx_u1.
  b. Return { NAME: name; ADDR: (FUNC fa*[x]); }.
2. If externidx_u1 is of the case GLOBAL, then:
  a. Let (GLOBAL x) be externidx_u1.
  b. Return { NAME: name; ADDR: (GLOBAL ga*[x]); }.
3. If externidx_u1 is of the case TABLE, then:
  a. Let (TABLE x) be externidx_u1.
  b. Return { NAME: name; ADDR: (TABLE ta*[x]); }.
4. Assert: Due to validation, externidx_u1 is of the case MEM.
5. Let (MEM x) be externidx_u1.
6. Return { NAME: name; ADDR: (MEM ma*[x]); }.

allocmodule s module externaddr* val* ref**
1. Assert: Due to validation, module is of the case MODULE.
2. Let (MODULE type_0* import* func^n_func global_1* table_2* mem_3* elem_4* data_5* start? export*) be module.
3. Assert: Due to validation, data_5 is of the case DATA*.
4. Let (DATA byte* datamode)^n_data be data_5*.
5. Assert: Due to validation, elem_4 is of the case ELEM*.
6. Let (ELEM rt expr_2* elemmode)^n_elem be elem_4*.
7. Assert: Due to validation, mem_3 is of the case MEMORY*.
8. Let (MEMORY memtype)^n_mem be mem_3*.
9. Assert: Due to validation, table_2 is of the case TABLE*.
10. Let (TABLE tabletype)^n_table be table_2*.
11. Assert: Due to validation, global_1 is of the case GLOBAL*.
12. Let (GLOBAL globaltype expr_1)^n_global be global_1*.
13. Assert: Due to validation, type_0 is of the case TYPE*.
14. Let (TYPE ft)* be type_0*.
15. Let fa_ex* be $funcs(externaddr*).
16. Let ga_ex* be $globals(externaddr*).
17. Let ma_ex* be $mems(externaddr*).
18. Let ta_ex* be $tables(externaddr*).
19. Let fa* be (|s.FUNCS| + i_func)^(i_func<n_func).
20. Let ga* be (|s.GLOBALS| + i_global)^(i_global<n_global).
21. Let ta* be (|s.TABLES| + i_table)^(i_table<n_table).
22. Let ma* be (|s.MEMS| + i_mem)^(i_mem<n_mem).
23. Let ea* be (|s.ELEMS| + i_elem)^(i_elem<n_elem).
24. Let da* be (|s.DATAS| + i_data)^(i_data<n_data).
25. Let xi* be $instexport(fa_ex* :: fa*, ga_ex* :: ga*, ta_ex* :: ta*, ma_ex* :: ma*, export)*.
26. Let moduleinst be { TYPES: ft*; FUNCS: fa_ex* :: fa*; GLOBALS: ga_ex* :: ga*; TABLES: ta_ex* :: ta*; MEMS: ma_ex* :: ma*; ELEMS: ea*; DATAS: da*; EXPORTS: xi*; }.
27. Let funcaddr_0* be $allocfuncs(s, moduleinst, func^n_func).
28. Assert: Due to validation, (funcaddr_0* = fa*).
29. Let globaladdr_0* be $allocglobals(s, globaltype^n_global, val*).
30. Assert: Due to validation, (globaladdr_0* = ga*).
31. Let tableaddr_0* be $alloctables(s, tabletype^n_table).
32. Assert: Due to validation, (tableaddr_0* = ta*).
33. Let memaddr_0* be $allocmems(s, memtype^n_mem).
34. Assert: Due to validation, (memaddr_0* = ma*).
35. Let elemaddr_0* be $allocelems(s, rt^n_elem, ref**).
36. Assert: Due to validation, (elemaddr_0* = ea*).
37. Let dataaddr_0* be $allocdatas(s, byte*^n_data).
38. Assert: Due to validation, (dataaddr_0* = da*).
39. Return moduleinst.

runelem (ELEM reftype expr* elemmode_u1) i
1. If (elemmode_u1 = PASSIVE), then:
  a. Return [].
2. If (elemmode_u1 = DECLARE), then:
  a. Return [(ELEM.DROP i)].
3. Assert: Due to validation, elemmode_u1 is of the case ACTIVE.
4. Let (ACTIVE x instr*) be elemmode_u1.
5. Let n be |expr*|.
6. Return instr* :: [(I32.CONST 0), (I32.CONST n), (TABLE.INIT x i), (ELEM.DROP i)].

rundata (DATA byte* datamode_u1) i
1. If (datamode_u1 = PASSIVE), then:
  a. Return [].
2. Assert: Due to validation, datamode_u1 is of the case ACTIVE.
3. Let (ACTIVE memidx_0 instr*) be datamode_u1.
4. Assert: Due to validation, (memidx_0 = 0).
5. Let n be |byte*|.
6. Return instr* :: [(I32.CONST 0), (I32.CONST n), (MEMORY.INIT i), (DATA.DROP i)].

instantiate s module externaddr*
1. Assert: Due to validation, module is of the case MODULE.
2. Let (MODULE type* import* func* global* table* mem* elem* data* start? export*) be module.
3. Assert: Due to validation, type is of the case TYPE*.
4. Let (TYPE functype)* be type*.
5. Let n_D be |data*|.
6. Let n_E be |elem*|.
7. Let n_F be |func*|.
8. Assert: Due to validation, start is of the case START?.
9. Let (START x)? be start?.
10. Assert: Due to validation, global is of the case GLOBAL*.
11. Let (GLOBAL globaltype expr_G)* be global*.
12. Assert: Due to validation, elem is of the case ELEM*.
13. Let (ELEM reftype expr_E* elemmode)* be elem*.
14. Let instr_D* be $concat_(instr, $rundata(data*[j], j)^(j<n_D)).
15. Let instr_E* be $concat_(instr, $runelem(elem*[i], i)^(i<n_E)).
16. Let moduleinst_init be { TYPES: functype*; FUNCS: $funcs(externaddr*) :: (|s.FUNCS| + i_F)^(i_F<n_F); GLOBALS: $globals(externaddr*); TABLES: []; MEMS: []; ELEMS: []; DATAS: []; EXPORTS: []; }.
17. Let f_init be { LOCALS: []; MODULE: moduleinst_init; }.
18. Let z be f_init.
19. Push the evaluation context (FRAME_ 0 { z }) to the stack.
20. Let [val]* be $eval_expr(expr_G)*.
21. Pop the evaluation context (FRAME_ 0 { _f }) from the stack.
22. Push the evaluation context (FRAME_ 0 { z }) to the stack.
23. Let [ref]** be $eval_expr(expr_E)**.
24. Pop the evaluation context (FRAME_ 0 { _f }) from the stack.
25. Let moduleinst be $allocmodule(s, module, externaddr*, val*, ref**).
26. Let f be { LOCALS: []; MODULE: moduleinst; }.
27. Push the evaluation context (FRAME_ 0 { f }) to the stack.
28. Execute the sequence (instr_E*).
29. Execute the sequence (instr_D*).
30. Execute the sequence ((CALL x)?).
31. Pop the evaluation context (FRAME_ 0 { f }) from the stack.
32. Return f.MODULE.

invoke s fa val^n
1. Let f be { LOCALS: []; MODULE: { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; EXPORTS: []; }; }.
2. Push the evaluation context (FRAME_ 0 { f }) to the stack.
3. Let t_1^n -> t_2* be $funcinst(z)[fa].TYPE.
4. Pop the evaluation context (FRAME_ 0 { _f }) from the stack.
5. Let k be |t_2*|.
6. Push the evaluation context (FRAME_ k { f }) to the stack.
7. Push the values val^n to the stack.
8. Execute the instruction (CALL_ADDR fa).
9. Pop all values val* from the top of the stack.
10. Pop the evaluation context (FRAME_ k { f }) from the stack.
11. Push the values val* to the stack.
12. Pop the values val^k from the stack.
13. Return val^k.

eval_expr instr*
1. Execute the instruction instr*.
2. Pop the value val from the stack.
3. Return [val].

== Complete.
Generating prose for Wasm 3.0...
watsup 0.4 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...
Untranslated relation Expand: `%~~%`(deftype, comptype)
Untranslated relation Nondefaultable: `|-%NONDEFAULTABLE`valtype



The number type :math:`{\mathit{numtype}}` is valid.




The vector type :math:`{\mathit{vectype}}` is valid.




The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid if:


  * Either:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{absheaptype}}`.

  * Or:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{typeidx}}`.

    * The defined type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

    * The defined type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is equal to :math:`{\mathit{dt}}`.
  * Or:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{rec}~i)`.

    * The sub type :math:`C{.}\mathsf{recs}{}[i]` exists.

    * The sub type :math:`C{.}\mathsf{recs}{}[i]` is equal to :math:`{\mathit{st}}`.




The heap type :math:`{\mathit{absheaptype}}` is valid.




The heap type :math:`{\mathit{typeidx}}` is valid if:


  * The defined type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

  * The defined type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is equal to :math:`{\mathit{dt}}`.




The heap type :math:`(\mathsf{rec}~i)` is valid if:


  * The sub type :math:`C{.}\mathsf{recs}{}[i]` exists.

  * The sub type :math:`C{.}\mathsf{recs}{}[i]` is equal to :math:`{\mathit{st}}`.




The reference type :math:`(\mathsf{ref}~{\mathsf{null}^?}~{\mathit{heaptype}})` is valid if:


  * The heap type :math:`{\mathit{heaptype}}` is valid.




The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid if:


  * Either:

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{numtype}}`.

    * The number type :math:`{\mathit{numtype}}` is valid.

  * Or:

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{vectype}}`.

    * The vector type :math:`{\mathit{vectype}}` is valid.
  * Or:

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{reftype}}`.

    * The reference type :math:`{\mathit{reftype}}` is valid.
  * Or:

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{bot}`.




The value type :math:`{\mathit{numtype}}` is valid if:


  * The value type :math:`{\mathit{numtype}}` is valid.




The value type :math:`{\mathit{vectype}}` is valid if:


  * The value type :math:`{\mathit{vectype}}` is valid.




The value type :math:`{\mathit{reftype}}` is valid if:


  * The value type :math:`{\mathit{reftype}}` is valid.




The value type :math:`\mathsf{bot}` is valid.




The result type :math:`{t^\ast}` is valid if:


  * For all :math:`t` in :math:`{t^\ast}`:

    * The value type :math:`t` is valid.




The instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}` is valid if:


  * The result type :math:`{t_1^\ast}` is valid.

  * The result type :math:`{t_2^\ast}` is valid.

  * :math:`{|{\mathit{x*}}|}` is equal to :math:`{|{\mathit{lct*}}|}`.

  * For all :math:`x` in :math:`{x^\ast}`:

    * The local type :math:`C{.}\mathsf{locals}{}[x]` exists.

  * For all :math:`{{\mathit{lt}}}` in :math:`{{{\mathit{lt}}}^\ast}` and :math:`x` in :math:`{x^\ast}`:

    * The local type :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`{{\mathit{lt}}}`.




The packed type :math:`{\mathit{packtype}}` is valid.




The storage type :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid if:


  * Either:

    * The storage type :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{valtype}}`.

    * The value type :math:`{\mathit{valtype}}` is valid.

  * Or:

    * The storage type :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{packtype}}`.

    * The packed type :math:`{\mathit{packtype}}` is valid.




The storage type :math:`{\mathit{valtype}}` is valid if:


  * The storage type :math:`{\mathit{valtype}}` is valid.




The storage type :math:`{\mathit{packtype}}` is valid if:


  * The storage type :math:`{\mathit{packtype}}` is valid.




The field type :math:`({\mathsf{mut}^?}, {\mathit{storagetype}})` is valid if:


  * The storage type :math:`{\mathit{storagetype}}` is valid.




The function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid if:


  * The result type :math:`{t_1^\ast}` is valid.

  * The result type :math:`{t_2^\ast}` is valid.




The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid if:


  * Either:

    * The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{struct}~{{\mathit{fieldtype}}^\ast})`.

    * For all :math:`{\mathit{fieldtype}}` in :math:`{{\mathit{fieldtype}}^\ast}`:

      * The field type :math:`{\mathit{fieldtype}}` is valid.

  * Or:

    * The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{array}~{\mathit{fieldtype}})`.

    * The field type :math:`{\mathit{fieldtype}}` is valid.
  * Or:

    * The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{functype}})`.

    * The function type :math:`{\mathit{functype}}` is valid.




The composite type :math:`(\mathsf{struct}~{{\mathit{fieldtype}}^\ast})` is valid if:


  * For all :math:`{\mathit{fieldtype}}` in :math:`{{\mathit{fieldtype}}^\ast}`:

    * The field type :math:`{\mathit{fieldtype}}` is valid.




The composite type :math:`(\mathsf{array}~{\mathit{fieldtype}})` is valid if:


  * The field type :math:`{\mathit{fieldtype}}` is valid.




The composite type :math:`(\mathsf{func}~{\mathit{functype}})` is valid if:


  * The function type :math:`{\mathit{functype}}` is valid.




The packed type :math:`{\mathit{packtype}}` matches itself.




The number type :math:`{\mathit{numtype}}` matches itself.




The defined type :math:`{\mathit{deftype}}_1` matches the defined type :math:`{\mathit{deftype}}_2` if:


  * Either:

    * The defined type :math:`{{\mathrm{clos}}}_{C}({\mathit{deftype}}_1)` is equal to :math:`{{\mathrm{clos}}}_{C}({\mathit{deftype}}_2)`.

  * Or:

    * The sub type :math:`{\mathrm{unroll}}({\mathit{deftype}}_1)` is equal to :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{ct}})`.

    * :math:`{|{{\mathit{typeuse}}^\ast}|}` is greater than :math:`i`.

    * The type use :math:`{{\mathit{typeuse}}^\ast}{}[i]` matches the defined type :math:`{\mathit{deftype}}_2`.




The defined type :math:`{\mathit{deftype}}_1` matches the defined type :math:`{\mathit{deftype}}_2` if:


  * The defined type :math:`{{\mathrm{clos}}}_{C}({\mathit{deftype}}_1)` is equal to :math:`{{\mathrm{clos}}}_{C}({\mathit{deftype}}_2)`.




The defined type :math:`{\mathit{deftype}}_1` matches the defined type :math:`{\mathit{deftype}}_2` if:


  * The sub type :math:`{\mathrm{unroll}}({\mathit{deftype}}_1)` is equal to :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{ct}})`.

  * :math:`{|{{\mathit{typeuse}}^\ast}|}` is greater than :math:`i`.

  * The type use :math:`{{\mathit{typeuse}}^\ast}{}[i]` matches the defined type :math:`{\mathit{deftype}}_2`.




The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` matches the heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` if:


  * Either:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{heaptype}}`.

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{heaptype}}`.

  * Or:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{heaptype}}_1`.

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{heaptype}}_2`.

    * The heap type :math:`{\mathit{heaptype}'}` is valid.

    * The heap type :math:`{\mathit{heaptype}}_1` matches the heap type :math:`{\mathit{heaptype}'}`.

    * The heap type :math:`{\mathit{heaptype}'}` matches the heap type :math:`{\mathit{heaptype}}_2`.
  * Or:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{eq}`.

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{any}`.
  * Or:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{i{\scriptstyle 31}}`.

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{eq}`.
  * Or:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{struct}`.

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{eq}`.
  * Or:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{array}`.

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{eq}`.
  * Or:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{deftype}}`.

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{struct}`.

    * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{struct}~{{\mathit{fieldtype}}^\ast})`.
  * Or:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{deftype}}`.

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{array}`.

    * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{array}~{\mathit{fieldtype}})`.
  * Or:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{deftype}}`.

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{func}`.

    * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.
  * Or:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{deftype}}_1`.

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{deftype}}_2`.

    * The defined type :math:`{\mathit{deftype}}_1` matches the defined type :math:`{\mathit{deftype}}_2`.
  * Or:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{typeidx}}`.

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{heaptype}}`.

    * The defined type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

    * The defined type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` matches the heap type :math:`{\mathit{heaptype}}`.
  * Or:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{heaptype}}`.

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{typeidx}}`.

    * The defined type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

    * The heap type :math:`{\mathit{heaptype}}` matches the defined type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]`.
  * Or:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{rec}~i)`.

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{{\mathit{typeuse}}^\ast}{}[j]`.

    * :math:`{|{{\mathit{typeuse}}^\ast}|}` is greater than :math:`j`.

    * The sub type :math:`C{.}\mathsf{recs}{}[i]` exists.

    * The sub type :math:`C{.}\mathsf{recs}{}[i]` is equal to :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{ct}})`.
  * Or:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{none}`.

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{heaptype}}`.

    * The heap type :math:`{\mathit{heaptype}}` matches the heap type :math:`\mathsf{any}`.
  * Or:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{nofunc}`.

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{heaptype}}`.

    * The heap type :math:`{\mathit{heaptype}}` matches the heap type :math:`\mathsf{func}`.
  * Or:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{noextern}`.

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{heaptype}}`.

    * The heap type :math:`{\mathit{heaptype}}` matches the heap type :math:`\mathsf{extern}`.
  * Or:

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{bot}`.

    * The heap type :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{heaptype}}`.




The heap type :math:`{\mathit{heaptype}}` matches itself.




The heap type :math:`{\mathit{heaptype}}_1` matches the heap type :math:`{\mathit{heaptype}}_2` if:


  * The heap type :math:`{\mathit{heaptype}'}` is valid.

  * The heap type :math:`{\mathit{heaptype}}_1` matches the heap type :math:`{\mathit{heaptype}'}`.

  * The heap type :math:`{\mathit{heaptype}'}` matches the heap type :math:`{\mathit{heaptype}}_2`.




The heap type :math:`\mathsf{eq}` matches the heap type :math:`\mathsf{any}`.




The heap type :math:`\mathsf{i{\scriptstyle 31}}` matches the heap type :math:`\mathsf{eq}`.




The heap type :math:`\mathsf{struct}` matches the heap type :math:`\mathsf{eq}`.




The heap type :math:`\mathsf{array}` matches the heap type :math:`\mathsf{eq}`.




The heap type :math:`{\mathit{deftype}}` matches the heap type :math:`\mathsf{struct}` if:


  * The :ref:`expansion <aux-expand-deftype>` of the heap type :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{struct}~{{\mathit{fieldtype}}^\ast})`.




The heap type :math:`{\mathit{deftype}}` matches the heap type :math:`\mathsf{array}` if:


  * The :ref:`expansion <aux-expand-deftype>` of the heap type :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{array}~{\mathit{fieldtype}})`.




The heap type :math:`{\mathit{deftype}}` matches the heap type :math:`\mathsf{func}` if:


  * The :ref:`expansion <aux-expand-deftype>` of the heap type :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.




The heap type :math:`{\mathit{deftype}}_1` matches the heap type :math:`{\mathit{deftype}}_2` if:


  * The heap type :math:`{\mathit{deftype}}_1` matches the heap type :math:`{\mathit{deftype}}_2`.




The heap type :math:`{\mathit{typeidx}}` matches the heap type :math:`{\mathit{heaptype}}` if:


  * The defined type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

  * The defined type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` matches the heap type :math:`{\mathit{heaptype}}`.




The heap type :math:`{\mathit{heaptype}}` matches the heap type :math:`{\mathit{typeidx}}` if:


  * The defined type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

  * The heap type :math:`{\mathit{heaptype}}` matches the defined type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]`.




The heap type :math:`(\mathsf{rec}~i)` matches the type use :math:`{{\mathit{typeuse}}^\ast}{}[j]` if:


  * :math:`{|{{\mathit{typeuse}}^\ast}|}` is greater than :math:`j`.

  * The sub type :math:`C{.}\mathsf{recs}{}[i]` exists.

  * The sub type :math:`C{.}\mathsf{recs}{}[i]` is equal to :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{ct}})`.




The heap type :math:`\mathsf{none}` matches the heap type :math:`{\mathit{heaptype}}` if:


  * The heap type :math:`{\mathit{heaptype}}` matches the heap type :math:`\mathsf{any}`.




The heap type :math:`\mathsf{nofunc}` matches the heap type :math:`{\mathit{heaptype}}` if:


  * The heap type :math:`{\mathit{heaptype}}` matches the heap type :math:`\mathsf{func}`.




The heap type :math:`\mathsf{noextern}` matches the heap type :math:`{\mathit{heaptype}}` if:


  * The heap type :math:`{\mathit{heaptype}}` matches the heap type :math:`\mathsf{extern}`.




The heap type :math:`\mathsf{bot}` matches the heap type :math:`{\mathit{heaptype}}`.




The reference type :math:`(\mathsf{ref}~{{\mathsf{null}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}~{\mathit{ht}}_1)` matches the reference type :math:`(\mathsf{ref}~{{\mathsf{null}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}~{\mathit{ht}}_2)` if:


  * The heap type :math:`{\mathit{ht}}_1` matches the heap type :math:`{\mathit{ht}}_2`.

  * Either:

    * :math:`{{\mathsf{null}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is absent.

    * :math:`{{\mathsf{null}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is absent.

  * Or:

    * :math:`{{\mathsf{null}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{null}^?}`.

    * :math:`{{\mathsf{null}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{null}`.




The reference type :math:`(\mathsf{ref}~\epsilon~{\mathit{ht}}_1)` matches the reference type :math:`(\mathsf{ref}~\epsilon~{\mathit{ht}}_2)` if:


  * The heap type :math:`{\mathit{ht}}_1` matches the heap type :math:`{\mathit{ht}}_2`.




The reference type :math:`(\mathsf{ref}~{\mathsf{null}^?}~{\mathit{ht}}_1)` matches the reference type :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}}_2)` if:


  * The heap type :math:`{\mathit{ht}}_1` matches the heap type :math:`{\mathit{ht}}_2`.




The vector type :math:`{\mathit{vectype}}` matches itself.




The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` matches the value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` if:


  * Either:

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{numtype}}_1`.

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{numtype}}_2`.

    * The number type :math:`{\mathit{numtype}}_1` matches the number type :math:`{\mathit{numtype}}_2`.

  * Or:

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{vectype}}_1`.

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{vectype}}_2`.

    * The vector type :math:`{\mathit{vectype}}_1` matches the vector type :math:`{\mathit{vectype}}_2`.
  * Or:

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{reftype}}_1`.

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{reftype}}_2`.

    * The reference type :math:`{\mathit{reftype}}_1` matches the reference type :math:`{\mathit{reftype}}_2`.
  * Or:

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{bot}`.

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{valtype}}`.




The value type :math:`{\mathit{numtype}}_1` matches the value type :math:`{\mathit{numtype}}_2` if:


  * The value type :math:`{\mathit{numtype}}_1` matches the value type :math:`{\mathit{numtype}}_2`.




The value type :math:`{\mathit{vectype}}_1` matches the value type :math:`{\mathit{vectype}}_2` if:


  * The value type :math:`{\mathit{vectype}}_1` matches the value type :math:`{\mathit{vectype}}_2`.




The value type :math:`{\mathit{reftype}}_1` matches the value type :math:`{\mathit{reftype}}_2` if:


  * The value type :math:`{\mathit{reftype}}_1` matches the value type :math:`{\mathit{reftype}}_2`.




The value type :math:`\mathsf{bot}` matches the value type :math:`{\mathit{valtype}}`.




The storage type :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` matches the storage type :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` if:


  * Either:

    * The storage type :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{valtype}}_1`.

    * The storage type :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{valtype}}_2`.

    * The value type :math:`{\mathit{valtype}}_1` matches the value type :math:`{\mathit{valtype}}_2`.

  * Or:

    * The storage type :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{packtype}}_1`.

    * The storage type :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`{\mathit{packtype}}_2`.

    * The packed type :math:`{\mathit{packtype}}_1` matches the packed type :math:`{\mathit{packtype}}_2`.




The storage type :math:`{\mathit{valtype}}_1` matches the storage type :math:`{\mathit{valtype}}_2` if:


  * The storage type :math:`{\mathit{valtype}}_1` matches the storage type :math:`{\mathit{valtype}}_2`.




The storage type :math:`{\mathit{packtype}}_1` matches the storage type :math:`{\mathit{packtype}}_2` if:


  * The storage type :math:`{\mathit{packtype}}_1` matches the storage type :math:`{\mathit{packtype}}_2`.




The field type :math:`({{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, {\mathit{zt}}_1)` matches the field type :math:`({{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}, {\mathit{zt}}_2)` if:


  * The storage type :math:`{\mathit{zt}}_1` matches the storage type :math:`{\mathit{zt}}_2`.

  * Either:

    * :math:`{{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is absent.

    * :math:`{{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is absent.

  * Or:

    * :math:`{{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{mut}`.

    * :math:`{{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{mut}`.

    * The storage type :math:`{\mathit{zt}}_2` matches the storage type :math:`{\mathit{zt}}_1`.




The field type :math:`(\epsilon, {\mathit{zt}}_1)` matches the field type :math:`(\epsilon, {\mathit{zt}}_2)` if:


  * The storage type :math:`{\mathit{zt}}_1` matches the storage type :math:`{\mathit{zt}}_2`.




The field type :math:`(\mathsf{mut}, {\mathit{zt}}_1)` matches the field type :math:`(\mathsf{mut}, {\mathit{zt}}_2)` if:


  * The storage type :math:`{\mathit{zt}}_1` matches the storage type :math:`{\mathit{zt}}_2`.

  * The storage type :math:`{\mathit{zt}}_2` matches the storage type :math:`{\mathit{zt}}_1`.




The value type sequence :math:`{t_1^\ast}` matches the value type sequence :math:`{t_2^\ast}` if:


  * :math:`{|t_{\mathit{{\scriptstyle 2}*}}|}` is equal to :math:`{|t_{\mathit{{\scriptstyle 1}*}}|}`.

  * For all :math:`t_1` in :math:`{t_1^\ast}` and :math:`t_2` in :math:`{t_2^\ast}`:

    * The value type :math:`t_1` matches the value type :math:`t_2`.




The function type :math:`{t_{11}^\ast}~\rightarrow~{t_{12}^\ast}` matches the function type :math:`{t_{21}^\ast}~\rightarrow~{t_{22}^\ast}` if:


  * The value type sequence :math:`{t_{21}^\ast}` matches the value type sequence :math:`{t_{11}^\ast}`.

  * The value type sequence :math:`{t_{12}^\ast}` matches the value type sequence :math:`{t_{22}^\ast}`.




The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` matches the composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` if:


  * Either:

    * The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{struct}~{{\mathit{yt}}_1^\ast}~{\mathit{yt}'}_1)`.

    * The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{struct}~{{\mathit{yt}}_2^\ast})`.

    * :math:`{|{\mathit{yt}}_{\mathit{{\scriptstyle 2}*}}|}` is equal to :math:`{|{\mathit{yt}}_{\mathit{{\scriptstyle 1}*}}|}`.

    * For all :math:`{\mathit{yt}}_1` in :math:`{{\mathit{yt}}_1^\ast}` and :math:`{\mathit{yt}}_2` in :math:`{{\mathit{yt}}_2^\ast}`:

      * The field type :math:`{\mathit{yt}}_1` matches the field type :math:`{\mathit{yt}}_2`.

  * Or:

    * The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{array}~{\mathit{yt}}_1)`.

    * The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{array}~{\mathit{yt}}_2)`.

    * The field type :math:`{\mathit{yt}}_1` matches the field type :math:`{\mathit{yt}}_2`.
  * Or:

    * The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{ft}}_1)`.

    * The composite type :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{func}~{\mathit{ft}}_2)`.

    * The function type :math:`{\mathit{ft}}_1` matches the function type :math:`{\mathit{ft}}_2`.




The composite type :math:`(\mathsf{struct}~{{\mathit{yt}}_1^\ast}~{\mathit{yt}'}_1)` matches the composite type :math:`(\mathsf{struct}~{{\mathit{yt}}_2^\ast})` if:


  * :math:`{|{\mathit{yt}}_{\mathit{{\scriptstyle 2}*}}|}` is equal to :math:`{|{\mathit{yt}}_{\mathit{{\scriptstyle 1}*}}|}`.

  * For all :math:`{\mathit{yt}}_1` in :math:`{{\mathit{yt}}_1^\ast}` and :math:`{\mathit{yt}}_2` in :math:`{{\mathit{yt}}_2^\ast}`:

    * The field type :math:`{\mathit{yt}}_1` matches the field type :math:`{\mathit{yt}}_2`.




The composite type :math:`(\mathsf{array}~{\mathit{yt}}_1)` matches the composite type :math:`(\mathsf{array}~{\mathit{yt}}_2)` if:


  * The field type :math:`{\mathit{yt}}_1` matches the field type :math:`{\mathit{yt}}_2`.




The composite type :math:`(\mathsf{func}~{\mathit{ft}}_1)` matches the composite type :math:`(\mathsf{func}~{\mathit{ft}}_2)` if:


  * The function type :math:`{\mathit{ft}}_1` matches the function type :math:`{\mathit{ft}}_2`.




The sub type :math:`(\mathsf{sub}~{\mathsf{final}^?}~{x^\ast}~{\mathit{comptype}})` is valid with :math:`({\mathsf{ok}}{x_0})` if:


  * :math:`{|{x^\ast}|}` is less than or equal to :math:`1`.

  * For all :math:`x` in :math:`{x^\ast}`:

    * The index :math:`x` is less than :math:`x_0`.

  * :math:`{|{\mathit{x*}}|}` is equal to :math:`{|{\mathit{comptype'*}}|}`.

  * :math:`{|{\mathit{x'**}}|}` is equal to :math:`{|{\mathit{comptype'*}}|}`.

  * For all :math:`x` in :math:`{x^\ast}`:

    * The defined type :math:`C{.}\mathsf{types}{}[x]` exists.

  * For all :math:`{\mathit{comptype}'}` in :math:`{{\mathit{comptype}'}^\ast}` and :math:`x` in :math:`{x^\ast}` and :math:`{\mathit{x'*}}` in :math:`{{\mathit{x'*}}^\ast}`:

    * The sub type :math:`{\mathrm{unroll}}(C{.}\mathsf{types}{}[x])` is equal to :math:`(\mathsf{sub}~\epsilon~{{x'}^\ast}~{\mathit{comptype}'})`.

  * The composite type :math:`{\mathit{comptype}}` is valid.

  * For all :math:`{\mathit{comptype}'}` in :math:`{{\mathit{comptype}'}^\ast}`:

    * The composite type :math:`{\mathit{comptype}}` matches the composite type :math:`{\mathit{comptype}'}`.




The sub type :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{compttype}})` is valid with :math:`({\mathsf{ok}}{(x, i)})` if:


  * :math:`{|{{\mathit{typeuse}}^\ast}|}` is less than or equal to :math:`1`.

  * For all :math:`{\mathit{typeuse}}` in :math:`{{\mathit{typeuse}}^\ast}`:

    * :math:`{\mathit{typeuse}} \prec x, i` is equal to true.

  * :math:`{|{\mathit{typeuse*}}|}` is equal to :math:`{|{\mathit{comptype'*}}|}`.

  * :math:`{|{\mathit{typeuse'**}}|}` is equal to :math:`{|{\mathit{comptype'*}}|}`.

  * For all :math:`{\mathit{comptype}'}` in :math:`{{\mathit{comptype}'}^\ast}` and :math:`{\mathit{typeuse}}` in :math:`{{\mathit{typeuse}}^\ast}` and :math:`{\mathit{typeuse'*}}` in :math:`{{\mathit{typeuse'*}}^\ast}`:

    * The sub type :math:`{{\mathrm{unroll}}}_{C}({\mathit{typeuse}})` is equal to :math:`(\mathsf{sub}~\epsilon~{{\mathit{typeuse}'}^\ast}~{\mathit{comptype}'})`.

  * The composite type :math:`{\mathit{comptype}}` is valid.

  * For all :math:`{\mathit{comptype}'}` in :math:`{{\mathit{comptype}'}^\ast}`:

    * The composite type :math:`{\mathit{comptype}}` matches the composite type :math:`{\mathit{comptype}'}`.




The recursive type :math:`(\mathsf{rec}~{{\mathit{st}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})` is valid with :math:`({\mathsf{ok}}{(x, i)})` if:


  * Either:

    * The sub type sequence :math:`{{\mathit{st}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

  * Or:

    * The sub type sequence :math:`{{\mathit{st}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{\mathit{subtype}}_1~{{\mathit{subtype}}^\ast}`.

    * The sub type :math:`{\mathit{subtype}}_1` is valid with :math:`({\mathsf{ok}}{(x, i)})`.

    * The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is valid with :math:`({\mathsf{ok}}{(x + 1, i + 1)})`.




The recursive type :math:`(\mathsf{rec}~\epsilon)` is valid with :math:`({\mathsf{ok}}{(x, i)})`.




The recursive type :math:`(\mathsf{rec}~{\mathit{subtype}}_1~{{\mathit{subtype}}^\ast})` is valid with :math:`({\mathsf{ok}}{(x, i)})` if:


  * The sub type :math:`{\mathit{subtype}}_1` is valid with :math:`({\mathsf{ok}}{(x, i)})`.

  * The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is valid with :math:`({\mathsf{ok}}{(x + 1, i + 1)})`.




The recursive type :math:`(\mathsf{rec}~{{\mathit{st}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})` is valid with :math:`({\mathsf{ok}}{x})` if:


  * Either:

    * The sub type sequence :math:`{{\mathit{st}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

  * Or:

    * The sub type sequence :math:`{{\mathit{st}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{\mathit{subtype}}_1~{{\mathit{subtype}}^\ast}`.

    * The sub type :math:`{\mathit{subtype}}_1` is valid with :math:`({\mathsf{ok}}{x})`.

    * The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is valid with :math:`({\mathsf{ok}}{x + 1})`.
  * Or:

    * The sub type sequence :math:`{{\mathit{st}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{{\mathit{subtype}}^\ast}`.

    * Let :math:`{C'}` be the same context as :math:`C`, but with the sub type sequence :math:`{{\mathit{subtype}}^\ast}` prepended to the field :math:`\mathsf{recs}`.

    * Under the context :math:`{C'}`, the recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is valid with :math:`({\mathsf{ok}}{(x, 0)})`.




The recursive type :math:`(\mathsf{rec}~\epsilon)` is valid with :math:`({\mathsf{ok}}{x})`.




The recursive type :math:`(\mathsf{rec}~{\mathit{subtype}}_1~{{\mathit{subtype}}^\ast})` is valid with :math:`({\mathsf{ok}}{x})` if:


  * The sub type :math:`{\mathit{subtype}}_1` is valid with :math:`({\mathsf{ok}}{x})`.

  * The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is valid with :math:`({\mathsf{ok}}{x + 1})`.




The recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is valid with :math:`({\mathsf{ok}}{x})` if:


  * Let :math:`{C'}` be the same context as :math:`C`, but with the sub type sequence :math:`{{\mathit{subtype}}^\ast}` prepended to the field :math:`\mathsf{recs}`.

  * Under the context :math:`{C'}`, the recursive type :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` is valid with :math:`({\mathsf{ok}}{(x, 0)})`.




The defined type :math:`({\mathit{rectype}} {.} i)` is valid if:


  * The recursive type :math:`{\mathit{rectype}}` is valid with :math:`({\mathsf{ok}}{x})`.

  * The recursive type :math:`{\mathit{rectype}}` is equal to :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})`.

  * :math:`i` is less than :math:`n`.




The limits :math:`({}[~n~..~m~])` is valid with :math:`k` if:


  * :math:`n` is less than or equal to :math:`m`.

  * :math:`m` is less than or equal to :math:`k`.




The global type :math:`({\mathsf{mut}^?}, t)` is valid if:


  * The value type :math:`t` is valid.




The table type :math:`({\mathit{addrtype}}, {\mathit{limits}}, {\mathit{reftype}})` is valid if:


  * The limits :math:`{\mathit{limits}}` is valid with :math:`{2^{32}} - 1`.

  * The reference type :math:`{\mathit{reftype}}` is valid.




The memory type :math:`({\mathit{addrtype}}~{\mathit{limits}}~\mathsf{page})` is valid if:


  * The limits :math:`{\mathit{limits}}` is valid with :math:`{2^{16}}`.




The tag type :math:`{\mathit{deftype}}` is valid if:


  * The tag type :math:`{\mathit{deftype}}` is valid.

  * The :ref:`expansion <aux-expand-deftype>` of the tag type :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.




The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid if:


  * Either:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{deftype}})`.

    * The defined type :math:`{\mathit{deftype}}` is valid.

    * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.

  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~{\mathit{globaltype}})`.

    * The global type :math:`{\mathit{globaltype}}` is valid.
  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~{\mathit{tabletype}})`.

    * The table type :math:`{\mathit{tabletype}}` is valid.
  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~{\mathit{memtype}})`.

    * The memory type :math:`{\mathit{memtype}}` is valid.
  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{tag}~{\mathit{tagtype}})`.

    * The tag type :math:`{\mathit{tagtype}}` is valid.




The external type :math:`(\mathsf{func}~{\mathit{deftype}})` is valid if:


  * The defined type :math:`{\mathit{deftype}}` is valid.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`{\mathit{deftype}}` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.




The external type :math:`(\mathsf{global}~{\mathit{globaltype}})` is valid if:


  * The global type :math:`{\mathit{globaltype}}` is valid.




The external type :math:`(\mathsf{table}~{\mathit{tabletype}})` is valid if:


  * The table type :math:`{\mathit{tabletype}}` is valid.




The external type :math:`(\mathsf{mem}~{\mathit{memtype}})` is valid if:


  * The memory type :math:`{\mathit{memtype}}` is valid.




The external type :math:`(\mathsf{tag}~{\mathit{tagtype}})` is valid if:


  * The tag type :math:`{\mathit{tagtype}}` is valid.




The instruction type :math:`{t_{11}^\ast}~{\rightarrow}_{{x_1^\ast}}\,{t_{12}^\ast}` matches the instruction type :math:`{t_{21}^\ast}~{\rightarrow}_{{x_2^\ast}}\,{t_{22}^\ast}` if:


  * The value type sequence :math:`{t_{21}^\ast}` matches the value type sequence :math:`{t_{11}^\ast}`.

  * The value type sequence :math:`{t_{12}^\ast}` matches the value type sequence :math:`{t_{22}^\ast}`.

  * The local index sequence :math:`{x^\ast}` is equal to :math:`{x_2^\ast} \setminus {x_1^\ast}`.

  * :math:`{|{\mathit{x*}}|}` is equal to :math:`{|{\mathit{t*}}|}`.

  * For all :math:`x` in :math:`{x^\ast}`:

    * The local type :math:`C{.}\mathsf{locals}{}[x]` exists.

  * For all :math:`t` in :math:`{t^\ast}` and :math:`x` in :math:`{x^\ast}`:

    * The local type :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`(\mathsf{set}, t)`.




The limits :math:`({}[~n_1~..~m_1~])` matches the limits :math:`({}[~n_2~..~m_2~])` if:


  * :math:`n_1` is greater than or equal to :math:`n_2`.

  * :math:`m_1` is less than or equal to :math:`m_2`.




The global type :math:`({{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, {\mathit{valtype}}_1)` matches the global type :math:`({{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}, {\mathit{valtype}}_2)` if:


  * The value type :math:`{\mathit{valtype}}_1` matches the value type :math:`{\mathit{valtype}}_2`.

  * Either:

    * :math:`{{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is absent.

    * :math:`{{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is absent.

  * Or:

    * :math:`{{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{mut}`.

    * :math:`{{\mathsf{mut}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`\mathsf{mut}`.

    * The value type :math:`{\mathit{valtype}}_2` matches the value type :math:`{\mathit{valtype}}_1`.




The global type :math:`(\epsilon, {\mathit{valtype}}_1)` matches the global type :math:`(\epsilon, {\mathit{valtype}}_2)` if:


  * The value type :math:`{\mathit{valtype}}_1` matches the value type :math:`{\mathit{valtype}}_2`.




The global type :math:`(\mathsf{mut}, {\mathit{valtype}}_1)` matches the global type :math:`(\mathsf{mut}, {\mathit{valtype}}_2)` if:


  * The value type :math:`{\mathit{valtype}}_1` matches the value type :math:`{\mathit{valtype}}_2`.

  * The value type :math:`{\mathit{valtype}}_2` matches the value type :math:`{\mathit{valtype}}_1`.




The table type :math:`({\mathit{addrtype}}, {\mathit{limits}}_1, {\mathit{reftype}}_1)` matches the table type :math:`({\mathit{addrtype}}, {\mathit{limits}}_2, {\mathit{reftype}}_2)` if:


  * The limits :math:`{\mathit{limits}}_1` matches the limits :math:`{\mathit{limits}}_2`.

  * The reference type :math:`{\mathit{reftype}}_1` matches the reference type :math:`{\mathit{reftype}}_2`.

  * The reference type :math:`{\mathit{reftype}}_2` matches the reference type :math:`{\mathit{reftype}}_1`.




The memory type :math:`({\mathit{addrtype}}~{\mathit{limits}}_1~\mathsf{page})` matches the memory type :math:`({\mathit{addrtype}}~{\mathit{limits}}_2~\mathsf{page})` if:


  * The limits :math:`{\mathit{limits}}_1` matches the limits :math:`{\mathit{limits}}_2`.




The tag type :math:`{\mathit{deftype}}_1` matches the tag type :math:`{\mathit{deftype}}_2` if:


  * The tag type :math:`{\mathit{deftype}}_1` matches the tag type :math:`{\mathit{deftype}}_2`.

  * The tag type :math:`{\mathit{deftype}}_2` matches the tag type :math:`{\mathit{deftype}}_1`.




The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` matches the external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` if:


  * Either:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{deftype}}_1)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{func}~{\mathit{deftype}}_2)`.

    * The defined type :math:`{\mathit{deftype}}_1` matches the defined type :math:`{\mathit{deftype}}_2`.

  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~{\mathit{globaltype}}_1)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{global}~{\mathit{globaltype}}_2)`.

    * The global type :math:`{\mathit{globaltype}}_1` matches the global type :math:`{\mathit{globaltype}}_2`.
  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~{\mathit{tabletype}}_1)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{table}~{\mathit{tabletype}}_2)`.

    * The table type :math:`{\mathit{tabletype}}_1` matches the table type :math:`{\mathit{tabletype}}_2`.
  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~{\mathit{memtype}}_1)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{mem}~{\mathit{memtype}}_2)`.

    * The memory type :math:`{\mathit{memtype}}_1` matches the memory type :math:`{\mathit{memtype}}_2`.
  * Or:

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{tag}~{\mathit{tagtype}}_1)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is equal to :math:`(\mathsf{tag}~{\mathit{tagtype}}_2)`.

    * The tag type :math:`{\mathit{tagtype}}_1` matches the tag type :math:`{\mathit{tagtype}}_2`.




The external type :math:`(\mathsf{func}~{\mathit{deftype}}_1)` matches the external type :math:`(\mathsf{func}~{\mathit{deftype}}_2)` if:


  * The defined type :math:`{\mathit{deftype}}_1` matches the defined type :math:`{\mathit{deftype}}_2`.




The external type :math:`(\mathsf{global}~{\mathit{globaltype}}_1)` matches the external type :math:`(\mathsf{global}~{\mathit{globaltype}}_2)` if:


  * The global type :math:`{\mathit{globaltype}}_1` matches the global type :math:`{\mathit{globaltype}}_2`.




The external type :math:`(\mathsf{table}~{\mathit{tabletype}}_1)` matches the external type :math:`(\mathsf{table}~{\mathit{tabletype}}_2)` if:


  * The table type :math:`{\mathit{tabletype}}_1` matches the table type :math:`{\mathit{tabletype}}_2`.




The external type :math:`(\mathsf{mem}~{\mathit{memtype}}_1)` matches the external type :math:`(\mathsf{mem}~{\mathit{memtype}}_2)` if:


  * The memory type :math:`{\mathit{memtype}}_1` matches the memory type :math:`{\mathit{memtype}}_2`.




The external type :math:`(\mathsf{tag}~{\mathit{tagtype}}_1)` matches the external type :math:`(\mathsf{tag}~{\mathit{tagtype}}_2)` if:


  * The tag type :math:`{\mathit{tagtype}}_1` matches the tag type :math:`{\mathit{tagtype}}_2`.




The block type :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the instruction type :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~\rightarrow~{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` if:


  * Either:

    * The block type :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{{\mathit{valtype}}^?}`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`{{\mathit{valtype}}^?}`.

    * If :math:`{\mathit{valtype}}` is defined, then:

      * The value type :math:`{\mathit{valtype}}` is valid.

  * Or:

    * The block type :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{typeidx}}`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{t_1^\ast}`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 2}}}^\ast}` is equal to :math:`{t_2^\ast}`.

    * The defined type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

    * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The block type :math:`{{\mathit{valtype}}^?}` is valid with the instruction type :math:`\epsilon~\rightarrow~{{\mathit{valtype}}^?}` if:


  * If :math:`{\mathit{valtype}}` is defined, then:

    * The value type :math:`{\mathit{valtype}}` is valid.




The block type :math:`{\mathit{typeidx}}` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * The defined type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[{\mathit{typeidx}}]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The catch clause :math:`{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid if:


  * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

  * Either:

    * The catch clause :math:`{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{catch}~x~l)`.

    * The tag type :math:`C{.}\mathsf{tags}{}[x]` exists.

    * The :ref:`expansion <aux-expand-deftype>` of the tag type :math:`C{.}\mathsf{tags}{}[x]` is the composite type :math:`(\mathsf{func}~{t^\ast}~\rightarrow~\epsilon)`.

    * The value type sequence :math:`{t^\ast}` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.

  * Or:

    * The catch clause :math:`{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{catch\_ref}~x~l)`.

    * The tag type :math:`C{.}\mathsf{tags}{}[x]` exists.

    * The :ref:`expansion <aux-expand-deftype>` of the tag type :math:`C{.}\mathsf{tags}{}[x]` is the composite type :math:`(\mathsf{func}~{t^\ast}~\rightarrow~\epsilon)`.

    * The value type sequence :math:`{t^\ast}~(\mathsf{ref}~\epsilon~\mathsf{exn})` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.
  * Or:

    * The catch clause :math:`{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{catch\_all}~l)`.

    * The value type sequence :math:`\epsilon` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.
  * Or:

    * The catch clause :math:`{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{catch\_all\_ref}~l)`.

    * The value type sequence :math:`(\mathsf{ref}~\epsilon~\mathsf{exn})` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.




The catch clause :math:`(\mathsf{catch}~x~l)` is valid if:


  * The tag type :math:`C{.}\mathsf{tags}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the tag type :math:`C{.}\mathsf{tags}{}[x]` is the composite type :math:`(\mathsf{func}~{t^\ast}~\rightarrow~\epsilon)`.

  * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

  * The value type sequence :math:`{t^\ast}` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.




The catch clause :math:`(\mathsf{catch\_ref}~x~l)` is valid if:


  * The tag type :math:`C{.}\mathsf{tags}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the tag type :math:`C{.}\mathsf{tags}{}[x]` is the composite type :math:`(\mathsf{func}~{t^\ast}~\rightarrow~\epsilon)`.

  * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

  * The value type sequence :math:`{t^\ast}~(\mathsf{ref}~\epsilon~\mathsf{exn})` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.




The catch clause :math:`(\mathsf{catch\_all}~l)` is valid if:


  * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

  * The value type sequence :math:`\epsilon` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.




The catch clause :math:`(\mathsf{catch\_all\_ref}~l)` is valid if:


  * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

  * The value type sequence :math:`(\mathsf{ref}~\epsilon~\mathsf{exn})` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.




The value type :math:`t` is defaultable if:


  * The value :math:`{{\mathrm{default}}}_{t}` is not absent.




The instruction :math:`\mathsf{nop}` is valid with the instruction type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction :math:`\mathsf{unreachable}` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.




The instruction :math:`\mathsf{drop}` is valid with the instruction type :math:`t~\rightarrow~\epsilon` if:


  * The value type :math:`t` is valid.




The instruction :math:`(\mathsf{select}~{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?})` is valid with the instruction type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


  * The value type :math:`t` is valid.

  * Either:

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`t`.

  * Or:

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is absent.

    * The value type :math:`t` matches the value type :math:`{t'}`.

    * The value type :math:`{t'}` is equal to :math:`{\mathit{numtype}}` or :math:`{t'}` is equal to :math:`{\mathit{vectype}}`.




The instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * The block type :math:`{\mathit{bt}}` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

  * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.




The instruction :math:`(\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast})` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * The block type :math:`{\mathit{bt}}` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_1^\ast}` prepended to the field :math:`\mathsf{labels}`.

  * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.




The instruction :math:`(\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` is valid with the instruction type :math:`{t_1^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


  * The block type :math:`{\mathit{bt}}` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

  * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_1^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}}\,{t_2^\ast}`.

  * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_2^\ast}}\,{t_2^\ast}`.




The instruction :math:`(\mathsf{br}~l)` is valid with the instruction type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


  * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

  * The result type :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^\ast}`.

  * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.




The instruction :math:`(\mathsf{br\_if}~l)` is valid with the instruction type :math:`{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t^\ast}` if:


  * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

  * The result type :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^\ast}`.




The instruction :math:`(\mathsf{br\_table}~{l^\ast}~{l'})` is valid with the instruction type :math:`{t_1^\ast}~{t^\ast}~\mathsf{i{\scriptstyle 32}}~\rightarrow~{t_2^\ast}` if:


  * For all :math:`l` in :math:`{l^\ast}`:

    * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

  * For all :math:`l` in :math:`{l^\ast}`:

    * The value type sequence :math:`{t^\ast}` matches the result type :math:`C{.}\mathsf{labels}{}[l]`.

  * The result type :math:`C{.}\mathsf{labels}{}[{l'}]` exists.

  * The value type sequence :math:`{t^\ast}` matches the result type :math:`C{.}\mathsf{labels}{}[{l'}]`.

  * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.




The instruction :math:`(\mathsf{br\_on\_null}~l)` is valid with the instruction type :math:`{t^\ast}~(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~{t^\ast}~(\mathsf{ref}~\epsilon~{\mathit{ht}})` if:


  * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

  * The result type :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^\ast}`.

  * The heap type :math:`{\mathit{ht}}` is valid.




The instruction :math:`(\mathsf{br\_on\_non\_null}~l)` is valid with the instruction type :math:`{t^\ast}~(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~{t^\ast}` if:


  * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

  * The result type :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^\ast}~(\mathsf{ref}~\epsilon~{\mathit{ht}})`.




The instruction :math:`(\mathsf{br\_on\_cast}~l~{\mathit{rt}}_1~{\mathit{rt}}_2)` is valid with the instruction type :math:`{t^\ast}~{\mathit{rt}}_1~\rightarrow~{t^\ast}~{t'}` if:


  * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

  * The result type :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^\ast}~{\mathit{rt}}`.

  * The reference type :math:`{\mathit{rt}}_1` is valid.

  * The reference type :math:`{\mathit{rt}}_2` is valid.

  * The reference type :math:`{\mathit{rt}}_2` matches the reference type :math:`{\mathit{rt}}_1`.

  * The reference type :math:`{\mathit{rt}}_2` matches the reference type :math:`{\mathit{rt}}`.

  * Let :math:`{t'}` be the reference type :math:`{\mathit{rt}}_1 \setminus {\mathit{rt}}_2`.




The instruction :math:`(\mathsf{br\_on\_cast\_fail}~l~{\mathit{rt}}_1~{\mathit{rt}}_2)` is valid with the instruction type :math:`{t^\ast}~{\mathit{rt}}_1~\rightarrow~{t^\ast}~{\mathit{rt}}_2` if:


  * The result type :math:`C{.}\mathsf{labels}{}[l]` exists.

  * The result type :math:`C{.}\mathsf{labels}{}[l]` is equal to :math:`{t^\ast}~{\mathit{rt}}`.

  * The reference type :math:`{\mathit{rt}}_1` is valid.

  * The reference type :math:`{\mathit{rt}}_2` is valid.

  * The reference type :math:`{\mathit{rt}}_2` matches the reference type :math:`{\mathit{rt}}_1`.

  * The reference type :math:`{\mathit{rt}}_1 \setminus {\mathit{rt}}_2` matches the reference type :math:`{\mathit{rt}}`.




The instruction :math:`(\mathsf{call}~x)` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * The defined type :math:`C{.}\mathsf{funcs}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{funcs}{}[x]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The instruction :math:`(\mathsf{call\_ref}~x)` is valid with the instruction type :math:`{t_1^\ast}~(\mathsf{ref}~\mathsf{null}~x)~\rightarrow~{t_2^\ast}` if:


  * The defined type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The instruction :math:`(\mathsf{call\_indirect}~x~y)` is valid with the instruction type :math:`{t_1^\ast}~{\mathit{at}}~\rightarrow~{t_2^\ast}` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}, {\mathit{lim}}, {\mathit{rt}})`.

  * The reference type :math:`{\mathit{rt}}` matches the reference type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{func})`.

  * The defined type :math:`C{.}\mathsf{types}{}[y]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[y]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.




The instruction :math:`\mathsf{return}` is valid with the instruction type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


  * The result type :math:`C{.}\mathsf{return}` is equal to :math:`{t^\ast}`.

  * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.




The instruction :math:`(\mathsf{return\_call}~x)` is valid with the instruction type :math:`{t_3^\ast}~{t_1^\ast}~\rightarrow~{t_4^\ast}` if:


  * The defined type :math:`C{.}\mathsf{funcs}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{funcs}{}[x]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.

  * The result type :math:`C{.}\mathsf{return}` is equal to :math:`{{t'}_2^\ast}`.

  * The value type sequence :math:`{t_2^\ast}` matches the value type sequence :math:`{{t'}_2^\ast}`.

  * The instruction type :math:`{t_3^\ast}~\rightarrow~{t_4^\ast}` is valid.




The instruction :math:`(\mathsf{return\_call\_ref}~x)` is valid with the instruction type :math:`{t_3^\ast}~{t_1^\ast}~(\mathsf{ref}~\mathsf{null}~x)~\rightarrow~{t_4^\ast}` if:


  * The defined type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.

  * The result type :math:`C{.}\mathsf{return}` is equal to :math:`{{t'}_2^\ast}`.

  * The value type sequence :math:`{t_2^\ast}` matches the value type sequence :math:`{{t'}_2^\ast}`.

  * The instruction type :math:`{t_3^\ast}~\rightarrow~{t_4^\ast}` is valid.




The instruction :math:`(\mathsf{return\_call\_indirect}~x~y)` is valid with the instruction type :math:`{t_3^\ast}~{t_1^\ast}~{\mathit{at}}~\rightarrow~{t_4^\ast}` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}, {\mathit{lim}}, {\mathit{rt}})`.

  * The reference type :math:`{\mathit{rt}}` matches the reference type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{func})`.

  * The defined type :math:`C{.}\mathsf{types}{}[y]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[y]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.

  * The result type :math:`C{.}\mathsf{return}` is equal to :math:`{{t'}_2^\ast}`.

  * The value type sequence :math:`{t_2^\ast}` matches the value type sequence :math:`{{t'}_2^\ast}`.

  * The instruction type :math:`{t_3^\ast}~\rightarrow~{t_4^\ast}` is valid.




The instruction :math:`(\mathsf{throw}~x)` is valid with the instruction type :math:`{t_1^\ast}~{t^\ast}~\rightarrow~{t_2^\ast}` if:


  * The tag type :math:`C{.}\mathsf{tags}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the tag type :math:`C{.}\mathsf{tags}{}[x]` is the composite type :math:`(\mathsf{func}~{t^\ast}~\rightarrow~\epsilon)`.

  * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.




The instruction :math:`\mathsf{throw\_ref}` is valid with the instruction type :math:`{t_1^\ast}~(\mathsf{ref}~\mathsf{null}~\mathsf{exn})~\rightarrow~{t_2^\ast}` if:


  * The instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` is valid.




The instruction :math:`(\mathsf{try\_table}~{\mathit{bt}}~{{\mathit{catch}}^\ast}~{{\mathit{instr}}^\ast})` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * The block type :math:`{\mathit{bt}}` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

  * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.

  * For all :math:`{\mathit{catch}}` in :math:`{{\mathit{catch}}^\ast}`:

    * The catch clause :math:`{\mathit{catch}}` is valid.




The instruction :math:`({\mathit{nt}}{.}\mathsf{const}~c_{\mathit{nt}})` is valid with the instruction type :math:`\epsilon~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{unop}}_{\mathit{nt}})` is valid with the instruction type :math:`{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{binop}}_{\mathit{nt}})` is valid with the instruction type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~{\mathit{nt}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{testop}}_{\mathit{nt}})` is valid with the instruction type :math:`{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{nt}} {.} {\mathit{relop}}_{\mathit{nt}})` is valid with the instruction type :math:`{\mathit{nt}}~{\mathit{nt}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{nt}}_1 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_2})` is valid with the instruction type :math:`{\mathit{nt}}_2~\rightarrow~{\mathit{nt}}_1`.




The instruction :math:`(\mathsf{ref{.}null}~{\mathit{ht}})` is valid with the instruction type :math:`\epsilon~\rightarrow~(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})` if:


  * The heap type :math:`{\mathit{ht}}` is valid.




The instruction :math:`(\mathsf{ref{.}func}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~(\mathsf{ref}~\epsilon~{\mathit{dt}})` if:


  * The defined type :math:`C{.}\mathsf{funcs}{}[x]` exists.

  * The defined type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{\mathit{dt}}`.

  * The index :math:`C{.}\mathsf{refs}{}[0]` exists.

  * :math:`x` is contained in :math:`C{.}\mathsf{refs}`.




The instruction :math:`\mathsf{ref{.}i{\scriptstyle 31}}` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~\epsilon~\mathsf{i{\scriptstyle 31}})`.




The instruction :math:`\mathsf{ref{.}is\_null}` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * The heap type :math:`{\mathit{ht}}` is valid.




The instruction :math:`\mathsf{ref{.}as\_non\_null}` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~{\mathit{ht}})~\rightarrow~(\mathsf{ref}~\epsilon~{\mathit{ht}})` if:


  * The heap type :math:`{\mathit{ht}}` is valid.




The instruction :math:`\mathsf{ref{.}eq}` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{eq})~(\mathsf{ref}~\mathsf{null}~\mathsf{eq})~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(\mathsf{ref{.}test}~{\mathit{rt}})` is valid with the instruction type :math:`{\mathit{rt}'}~\rightarrow~\mathsf{i{\scriptstyle 32}}` if:


  * The reference type :math:`{\mathit{rt}}` is valid.

  * The reference type :math:`{\mathit{rt}'}` is valid.

  * The reference type :math:`{\mathit{rt}}` matches the reference type :math:`{\mathit{rt}'}`.




The instruction :math:`(\mathsf{ref{.}cast}~{\mathit{rt}})` is valid with the instruction type :math:`{\mathit{rt}'}~\rightarrow~{\mathit{rt}}` if:


  * The reference type :math:`{\mathit{rt}}` is valid.

  * The reference type :math:`{\mathit{rt}'}` is valid.

  * The reference type :math:`{\mathit{rt}}` matches the reference type :math:`{\mathit{rt}'}`.




The instruction :math:`({\mathsf{i{\scriptstyle 31}{.}get}}{\mathsf{\_}}{{\mathit{sx}}})` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{i{\scriptstyle 31}})~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(\mathsf{struct{.}new}~x)` is valid with the instruction type :math:`{t^\ast}~\rightarrow~(\mathsf{ref}~\epsilon~x)` if:


  * The defined type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{struct}~{({\mathsf{mut}^?}, {\mathit{zt}})^\ast})`.

  * Let :math:`{t^\ast}` be the value type sequence :math:`{{\mathrm{unpack}}({\mathit{zt}})^\ast}`.




The instruction :math:`(\mathsf{struct{.}new\_default}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~(\mathsf{ref}~\epsilon~x)` if:


  * The defined type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{struct}~{({\mathsf{mut}^?}, {\mathit{zt}})^\ast})`.

  * For all :math:`{\mathit{zt}}` in :math:`{{\mathit{zt}}^\ast}`:

    * A :ref:`default value <default-val>` for value type the value type :math:`{\mathrm{unpack}}({\mathit{zt}})` is defined.




The instruction :math:`({\mathsf{struct{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x~i)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\rightarrow~t` if:


  * The defined type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{struct}~{{\mathit{yt}}^\ast})`.

  * :math:`{|{{\mathit{yt}}^\ast}|}` is greater than :math:`i`.

  * The field type :math:`{{\mathit{yt}}^\ast}{}[i]` is equal to :math:`({\mathsf{mut}^?}, {\mathit{zt}})`.

  * The signedness :math:`{{\mathit{sx}}^?}` is absent if and only if the storage type :math:`{\mathit{zt}}` is equal to :math:`{\mathrm{unpack}}({\mathit{zt}})`.

  * Let :math:`t` be the value type :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{struct{.}set}~x~i)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~t~\rightarrow~\epsilon` if:


  * The defined type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{struct}~{{\mathit{yt}}^\ast})`.

  * :math:`{|{{\mathit{yt}}^\ast}|}` is greater than :math:`i`.

  * The field type :math:`{{\mathit{yt}}^\ast}{}[i]` is equal to :math:`(\mathsf{mut}, {\mathit{zt}})`.

  * Let :math:`t` be the value type :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}new}~x)` is valid with the instruction type :math:`t~\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~\epsilon~x)` if:


  * The defined type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}, {\mathit{zt}}))`.

  * Let :math:`t` be the value type :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}new\_default}~x)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~\epsilon~x)` if:


  * The defined type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}, {\mathit{zt}}))`.

  * A :ref:`default value <default-val>` for value type the value type :math:`{\mathrm{unpack}}({\mathit{zt}})` is defined.




The instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)` is valid with the instruction type :math:`{t^{n}}~\rightarrow~(\mathsf{ref}~\epsilon~x)` if:


  * The defined type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}, {\mathit{zt}}))`.

  * Let :math:`t` be the value type :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}new\_elem}~x~y)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~\epsilon~x)` if:


  * The defined type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}, {\mathit{rt}}))`.

  * The element type :math:`C{.}\mathsf{elems}{}[y]` exists.

  * The element type :math:`C{.}\mathsf{elems}{}[y]` matches the reference type :math:`{\mathit{rt}}`.




The instruction :math:`(\mathsf{array{.}new\_data}~x~y)` is valid with the instruction type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~(\mathsf{ref}~\epsilon~x)` if:


  * The defined type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}, {\mathit{zt}}))`.

  * The value type :math:`{\mathrm{unpack}}({\mathit{zt}})` is equal to :math:`{\mathit{numtype}}` or :math:`{\mathrm{unpack}}({\mathit{zt}})` is equal to :math:`{\mathit{vectype}}`.

  * The data type :math:`C{.}\mathsf{datas}{}[y]` exists.

  * The data type :math:`C{.}\mathsf{datas}{}[y]` is equal to :math:`\mathsf{ok}`.




The instruction :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


  * The defined type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}, {\mathit{zt}}))`.

  * The signedness :math:`{{\mathit{sx}}^?}` is absent if and only if the storage type :math:`{\mathit{zt}}` is equal to :math:`{\mathrm{unpack}}({\mathit{zt}})`.

  * Let :math:`t` be the value type :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}set}~x)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~t~\rightarrow~\epsilon` if:


  * The defined type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~(\mathsf{mut}, {\mathit{zt}}))`.

  * Let :math:`t` be the value type :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`\mathsf{array{.}len}` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{array})~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`(\mathsf{array{.}fill}~x)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * The defined type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~(\mathsf{mut}, {\mathit{zt}}))`.

  * Let :math:`t` be the value type :math:`{\mathrm{unpack}}({\mathit{zt}})`.




The instruction :math:`(\mathsf{array{.}copy}~x_1~x_2)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x_1)~\mathsf{i{\scriptstyle 32}}~(\mathsf{ref}~\mathsf{null}~x_2)~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * The defined type :math:`C{.}\mathsf{types}{}[x_1]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[x_1]` is the composite type :math:`(\mathsf{array}~(\mathsf{mut}, {\mathit{zt}}_1))`.

  * The defined type :math:`C{.}\mathsf{types}{}[x_2]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[x_2]` is the composite type :math:`(\mathsf{array}~({\mathsf{mut}^?}, {\mathit{zt}}_2))`.

  * The storage type :math:`{\mathit{zt}}_2` matches the storage type :math:`{\mathit{zt}}_1`.




The instruction :math:`(\mathsf{array{.}init\_elem}~x~y)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * The defined type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~(\mathsf{mut}, {\mathit{zt}}))`.

  * The element type :math:`C{.}\mathsf{elems}{}[y]` exists.

  * The element type :math:`C{.}\mathsf{elems}{}[y]` matches the storage type :math:`{\mathit{zt}}`.




The instruction :math:`(\mathsf{array{.}init\_data}~x~y)` is valid with the instruction type :math:`(\mathsf{ref}~\mathsf{null}~x)~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * The defined type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{array}~(\mathsf{mut}, {\mathit{zt}}))`.

  * The value type :math:`{\mathrm{unpack}}({\mathit{zt}})` is equal to :math:`{\mathit{numtype}}` or :math:`{\mathrm{unpack}}({\mathit{zt}})` is equal to :math:`{\mathit{vectype}}`.

  * The data type :math:`C{.}\mathsf{datas}{}[y]` exists.

  * The data type :math:`C{.}\mathsf{datas}{}[y]` is equal to :math:`\mathsf{ok}`.




The instruction :math:`\mathsf{extern{.}convert\_any}` is valid with the instruction type :math:`(\mathsf{ref}~{\mathsf{null}}{{{}_{1}^?}}~\mathsf{any})~\rightarrow~(\mathsf{ref}~{\mathsf{null}}{{{}_{2}^?}}~\mathsf{extern})` if:


  * :math:`{\mathsf{null}}{{{}_{1}^?}}` is equal to :math:`{\mathsf{null}}{{{}_{2}^?}}`.




The instruction :math:`\mathsf{any{.}convert\_extern}` is valid with the instruction type :math:`(\mathsf{ref}~{\mathsf{null}}{{{}_{1}^?}}~\mathsf{extern})~\rightarrow~(\mathsf{ref}~{\mathsf{null}}{{{}_{2}^?}}~\mathsf{any})` if:


  * :math:`{\mathsf{null}}{{{}_{1}^?}}` is equal to :math:`{\mathsf{null}}{{{}_{2}^?}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` is valid with the instruction type :math:`\epsilon~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvunop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvbinop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvternop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvtestop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vunop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vbinop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vternop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vtestop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vrelop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vshiftop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{bitmask})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction :math:`({\mathit{sh}} {.} {\mathit{vswizzlop}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{shuffle}~{i^\ast})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * For all :math:`i` in :math:`{i^\ast}`:

    * The lane index :math:`i` is less than :math:`2 \cdot {\mathrm{dim}}({\mathit{sh}})`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{splat})` is valid with the instruction type :math:`t~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * Let :math:`t` be the number type :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({{\mathit{sh}}{.}\mathsf{extract\_lane}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~i)` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~t` if:


  * The lane index :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.

  * Let :math:`t` be the number type :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({\mathit{sh}}{.}\mathsf{replace\_lane}~i)` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~t~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * The lane index :math:`i` is less than :math:`{\mathrm{dim}}({\mathit{sh}})`.

  * Let :math:`t` be the number type :math:`{\mathrm{unpack}}({\mathit{sh}})`.




The instruction :math:`({\mathit{sh}}_1 {.} {{\mathit{vextunop}}}{\mathsf{\_}}{{\mathit{sh}}_2})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}_1 {.} {{\mathit{vextbinop}}}{\mathsf{\_}}{{\mathit{sh}}_2})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}_1 {.} {{\mathit{vextternop}}}{\mathsf{\_}}{{\mathit{sh}}_2})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({{\mathit{sh}}_1{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{sh}}_2}{\mathsf{\_}}{{\mathit{sx}}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`({\mathit{sh}}_1 {.} {{\mathit{vcvtop}}}{\mathsf{\_}}{{{\mathit{zero}}^?}}{\mathsf{\_}}{{\mathit{sh}}_2}{\mathsf{\_}}{{{\mathit{half}}^?}})` is valid with the instruction type :math:`\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}`.




The instruction :math:`(\mathsf{local{.}get}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~t` if:


  * The local type :math:`C{.}\mathsf{locals}{}[x]` exists.

  * The local type :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`(\mathsf{set}, t)`.




The instruction :math:`(\mathsf{local{.}set}~x)` is valid with the instruction type :math:`t~{\rightarrow}_{x}\,\epsilon` if:


  * The local type :math:`C{.}\mathsf{locals}{}[x]` exists.

  * The local type :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`({\mathit{init}}, t)`.




The instruction :math:`(\mathsf{local{.}tee}~x)` is valid with the instruction type :math:`t~{\rightarrow}_{x}\,t` if:


  * The local type :math:`C{.}\mathsf{locals}{}[x]` exists.

  * The local type :math:`C{.}\mathsf{locals}{}[x]` is equal to :math:`({\mathit{init}}, t)`.




The instruction :math:`(\mathsf{global{.}get}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~t` if:


  * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

  * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`({\mathsf{mut}^?}, t)`.




The instruction :math:`(\mathsf{global{.}set}~x)` is valid with the instruction type :math:`t~\rightarrow~\epsilon` if:


  * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

  * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`(\mathsf{mut}, t)`.




The instruction :math:`(\mathsf{table{.}get}~x)` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~{\mathit{rt}}` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}, {\mathit{lim}}, {\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}set}~x)` is valid with the instruction type :math:`{\mathit{at}}~{\mathit{rt}}~\rightarrow~\epsilon` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}, {\mathit{lim}}, {\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}size}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~{\mathit{at}}` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}, {\mathit{lim}}, {\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}grow}~x)` is valid with the instruction type :math:`{\mathit{rt}}~{\mathit{at}}~\rightarrow~{\mathit{at}}` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}, {\mathit{lim}}, {\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}fill}~x)` is valid with the instruction type :math:`{\mathit{at}}~{\mathit{rt}}~{\mathit{at}}~\rightarrow~\epsilon` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}, {\mathit{lim}}, {\mathit{rt}})`.




The instruction :math:`(\mathsf{table{.}copy}~x_1~x_2)` is valid with the instruction type :math:`{\mathit{at}}_1~{\mathit{at}}_2~t~\rightarrow~\epsilon` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x_1]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x_1]` is equal to :math:`({\mathit{at}}_1, {\mathit{lim}}_1, {\mathit{rt}}_1)`.

  * The table type :math:`C{.}\mathsf{tables}{}[x_2]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x_2]` is equal to :math:`({\mathit{at}}_2, {\mathit{lim}}_2, {\mathit{rt}}_2)`.

  * The reference type :math:`{\mathit{rt}}_2` matches the reference type :math:`{\mathit{rt}}_1`.

  * Let :math:`t` be the address type :math:`{\mathrm{min}}({\mathit{at}}_1, {\mathit{at}}_2)`.




The instruction :math:`(\mathsf{table{.}init}~x~y)` is valid with the instruction type :math:`{\mathit{at}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}, {\mathit{lim}}, {\mathit{rt}}_1)`.

  * The element type :math:`C{.}\mathsf{elems}{}[y]` exists.

  * The element type :math:`C{.}\mathsf{elems}{}[y]` is equal to :math:`{\mathit{rt}}_2`.

  * The reference type :math:`{\mathit{rt}}_2` matches the reference type :math:`{\mathit{rt}}_1`.




The instruction :math:`(\mathsf{elem{.}drop}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~\epsilon` if:


  * The element type :math:`C{.}\mathsf{elems}{}[x]` exists.

  * The element type :math:`C{.}\mathsf{elems}{}[x]` is equal to :math:`{\mathit{rt}}`.




The instruction :math:`(\mathsf{memory{.}size}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~{\mathit{at}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.




The instruction :math:`(\mathsf{memory{.}grow}~x)` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~{\mathit{at}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.




The instruction :math:`(\mathsf{memory{.}fill}~x)` is valid with the instruction type :math:`{\mathit{at}}~\mathsf{i{\scriptstyle 32}}~{\mathit{at}}~\rightarrow~\epsilon` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.




The instruction :math:`(\mathsf{memory{.}copy}~x_1~x_2)` is valid with the instruction type :math:`{\mathit{at}}_1~{\mathit{at}}_2~t~\rightarrow~\epsilon` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x_1]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x_1]` is equal to :math:`({\mathit{at}}_1~{\mathit{lim}}_1~\mathsf{page})`.

  * The memory type :math:`C{.}\mathsf{mems}{}[x_2]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x_2]` is equal to :math:`({\mathit{at}}_2~{\mathit{lim}}_2~\mathsf{page})`.

  * Let :math:`t` be the address type :math:`{\mathrm{min}}({\mathit{at}}_1, {\mathit{at}}_2)`.




The instruction :math:`(\mathsf{memory{.}init}~x~y)` is valid with the instruction type :math:`{\mathit{at}}~\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\epsilon` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

  * The data type :math:`C{.}\mathsf{datas}{}[y]` exists.

  * The data type :math:`C{.}\mathsf{datas}{}[y]` is equal to :math:`\mathsf{ok}`.




The instruction :math:`(\mathsf{data{.}drop}~x)` is valid with the instruction type :math:`\epsilon~\rightarrow~\epsilon` if:


  * The data type :math:`C{.}\mathsf{datas}{}[x]` exists.

  * The data type :math:`C{.}\mathsf{datas}{}[x]` is equal to :math:`\mathsf{ok}`.




The instruction :math:`({{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{load}}{{{\mathit{loadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

  * Either:

    * The number type :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{nt}}`.

    * :math:`{{\mathit{loadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is absent.

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{nt}}`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

  * Or:

    * The number type :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{N}`.

    * :math:`{{\mathit{loadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`(M, {\mathit{sx}})`.

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{N}`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{store}}{{{\mathit{storeop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}~\rightarrow~\epsilon` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

  * Either:

    * The number type :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{nt}}`.

    * :math:`{{\mathit{storeop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is absent.

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{nt}}`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.

  * Or:

    * The number type :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{N}`.

    * :math:`{{\mathit{storeop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`M`.

    * The value type :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathsf{i}}{N}`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

  * Either:

    * :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is absent.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|\mathsf{v{\scriptstyle 128}}|} / 8`.

  * Or:

    * :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`({M}{\mathsf{x}}{N}{\mathsf{\_}}{{\mathit{sx}}})`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8 \cdot N`.
  * Or:

    * :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`({N}{\mathsf{\_}}{\mathsf{splat}})`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.
  * Or:

    * :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is equal to :math:`({N}{\mathsf{\_}}{\mathsf{zero}})`.

    * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{memarg}}~i)` is valid with the instruction type :math:`{\mathit{at}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.

  * :math:`i` is less than :math:`128 / N`.




The instruction :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|\mathsf{v{\scriptstyle 128}}|} / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{memarg}}~i)` is valid with the instruction type :math:`{\mathit{at}}~\mathsf{v{\scriptstyle 128}}~\rightarrow~\epsilon` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.

  * :math:`i` is less than :math:`128 / N`.




The instruction :math:`(\mathsf{select}~t)` is valid with the instruction type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


  * The value type :math:`t` is valid.




The instruction :math:`(\mathsf{select}~\epsilon)` is valid with the instruction type :math:`t~t~\mathsf{i{\scriptstyle 32}}~\rightarrow~t` if:


  * The value type :math:`t` is valid.

  * The value type :math:`t` matches the value type :math:`{t'}`.

  * The value type :math:`{t'}` is equal to :math:`{\mathit{numtype}}` or :math:`{t'}` is equal to :math:`{\mathit{vectype}}`.




The instruction :math:`({{\mathit{nt}}{.}\mathsf{load}}{\epsilon}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~{\mathit{nt}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.




The instruction :math:`({{\mathsf{i}}{N}{.}\mathsf{load}}{(M, {\mathit{sx}})}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~{\mathsf{i}}{N}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({{\mathit{nt}}{.}\mathsf{store}}{\epsilon}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~{\mathit{nt}}~\rightarrow~\epsilon` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|{\mathit{nt}}|} / 8`.




The instruction :math:`({{\mathsf{i}}{N}{.}\mathsf{store}}{M}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~{\mathsf{i}}{N}~\rightarrow~\epsilon` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{\epsilon}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`{|\mathsf{v{\scriptstyle 128}}|} / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{M}{\mathsf{x}}{N}{\mathsf{\_}}{{\mathit{sx}}}}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`M / 8 \cdot N`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{N}{\mathsf{\_}}{\mathsf{splat}}}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.




The instruction :math:`({\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{N}{\mathsf{\_}}{\mathsf{zero}}}~x~{\mathit{memarg}})` is valid with the instruction type :math:`{\mathit{at}}~\rightarrow~\mathsf{v{\scriptstyle 128}}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.

  * :math:`{2^{{\mathit{memarg}}{.}\mathsf{align}}}` is less than or equal to :math:`N / 8`.




The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is valid with the instruction type :math:`{\mathit{instrtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


  * Either:

    * The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

    * The instruction type :math:`{\mathit{instrtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\epsilon~\rightarrow~\epsilon`.

  * Or:

    * The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}`.

    * The instruction type :math:`{\mathit{instrtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}~{x_2^\ast}}\,{t_3^\ast}`.

    * The instruction :math:`{\mathit{instr}}_1` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}}\,{t_2^\ast}`.

    * :math:`{|{\mathit{t*}}|}` is equal to :math:`{|{\mathit{init*}}|}`.

    * :math:`{|x_{\mathit{{\scriptstyle 1}*}}|}` is equal to :math:`{|{\mathit{init*}}|}`.

    * For all :math:`x_1` in :math:`{x_1^\ast}`:

      * The local type :math:`C{.}\mathsf{locals}{}[x_1]` exists.

    * For all :math:`{\mathit{init}}` in :math:`{{\mathit{init}}^\ast}` and :math:`t` in :math:`{t^\ast}` and :math:`x_1` in :math:`{x_1^\ast}`:

      * The local type :math:`C{.}\mathsf{locals}{}[x_1]` is equal to :math:`({\mathit{init}}, t)`.

    * Under the context :math:`C{}[{.}\mathsf{local}{}[{x_1^\ast}] = {(\mathsf{set}, t)^\ast}]`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the instruction type :math:`{t_2^\ast}~{\rightarrow}_{{x_2^\ast}}\,{t_3^\ast}`.
  * Or:

    * The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{{\mathit{instr}}^\ast}`.

    * The instruction type :math:`{\mathit{instrtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{\mathit{it}'}`.

    * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{\mathit{it}}`.

    * The instruction type :math:`{\mathit{it}}` matches the instruction type :math:`{\mathit{it}'}`.

    * The instruction type :math:`{\mathit{it}'}` is valid.
  * Or:

    * The instruction sequence :math:`{{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{{\mathit{instr}}^\ast}`.

    * The instruction type :math:`{\mathit{instrtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`{t^\ast}~{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t^\ast}~{t_2^\ast}`.

    * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.

    * The result type :math:`{t^\ast}` is valid.




The instruction sequence :math:`\epsilon` is valid with the instruction type :math:`\epsilon~\rightarrow~\epsilon`.




The instruction sequence :math:`{\mathit{instr}}_1~{{\mathit{instr}}_2^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}~{x_2^\ast}}\,{t_3^\ast}` if:


  * The instruction :math:`{\mathit{instr}}_1` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x_1^\ast}}\,{t_2^\ast}`.

  * :math:`{|{\mathit{t*}}|}` is equal to :math:`{|{\mathit{init*}}|}`.

  * :math:`{|x_{\mathit{{\scriptstyle 1}*}}|}` is equal to :math:`{|{\mathit{init*}}|}`.

  * For all :math:`x_1` in :math:`{x_1^\ast}`:

    * The local type :math:`C{.}\mathsf{locals}{}[x_1]` exists.

  * For all :math:`{\mathit{init}}` in :math:`{{\mathit{init}}^\ast}` and :math:`t` in :math:`{t^\ast}` and :math:`x_1` in :math:`{x_1^\ast}`:

    * The local type :math:`C{.}\mathsf{locals}{}[x_1]` is equal to :math:`({\mathit{init}}, t)`.

  * Under the context :math:`C{}[{.}\mathsf{local}{}[{x_1^\ast}] = {(\mathsf{set}, t)^\ast}]`, the instruction sequence :math:`{{\mathit{instr}}_2^\ast}` is valid with the instruction type :math:`{t_2^\ast}~{\rightarrow}_{{x_2^\ast}}\,{t_3^\ast}`.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{\mathit{it}'}` if:


  * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{\mathit{it}}`.

  * The instruction type :math:`{\mathit{it}}` matches the instruction type :math:`{\mathit{it}'}`.

  * The instruction type :math:`{\mathit{it}'}` is valid.




The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{t^\ast}~{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t^\ast}~{t_2^\ast}` if:


  * The instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{t_1^\ast}~{\rightarrow}_{{x^\ast}}\,{t_2^\ast}`.

  * The result type :math:`{t^\ast}` is valid.




The expression :math:`{{\mathit{instr}}^\ast}` is valid with the result type :math:`{t^\ast}` if:


  * The expression :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`\epsilon~\rightarrow~{t^\ast}`.




:math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is const if:


  * Either:

    * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`({\mathit{nt}}{.}\mathsf{const}~c_{\mathit{nt}})`.

  * Or:

    * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`({\mathit{vt}}{.}\mathsf{const}~c_{\mathit{vt}})`.
  * Or:

    * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref{.}null}~{\mathit{ht}})`.
  * Or:

    * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{ref{.}i{\scriptstyle 31}}`.
  * Or:

    * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{ref{.}func}~x)`.
  * Or:

    * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{struct{.}new}~x)`.
  * Or:

    * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{struct{.}new\_default}~x)`.
  * Or:

    * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{array{.}new}~x)`.
  * Or:

    * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{array{.}new\_default}~x)`.
  * Or:

    * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{array{.}new\_fixed}~x~n)`.
  * Or:

    * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{any{.}convert\_extern}`.
  * Or:

    * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{extern{.}convert\_any}`.
  * Or:

    * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global{.}get}~x)`.

    * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

    * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`(\epsilon, t)`.
  * Or:

    * The instruction :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`({\mathsf{i}}{N} {.} {\mathit{binop}})`.

    * :math:`{\mathsf{i}}{N}` is contained in [:math:`\mathsf{i{\scriptstyle 32}}`; :math:`\mathsf{i{\scriptstyle 64}}`].

    * :math:`{\mathit{binop}}` is contained in [:math:`\mathsf{add}`; :math:`\mathsf{sub}`; :math:`\mathsf{mul}`].




:math:`({\mathit{nt}}{.}\mathsf{const}~c_{\mathit{nt}})` is const.




:math:`({\mathit{vt}}{.}\mathsf{const}~c_{\mathit{vt}})` is const.




:math:`(\mathsf{ref{.}null}~{\mathit{ht}})` is const.




:math:`\mathsf{ref{.}i{\scriptstyle 31}}` is const.




:math:`(\mathsf{ref{.}func}~x)` is const.




:math:`(\mathsf{struct{.}new}~x)` is const.




:math:`(\mathsf{struct{.}new\_default}~x)` is const.




:math:`(\mathsf{array{.}new}~x)` is const.




:math:`(\mathsf{array{.}new\_default}~x)` is const.




:math:`(\mathsf{array{.}new\_fixed}~x~n)` is const.




:math:`\mathsf{any{.}convert\_extern}` is const.




:math:`\mathsf{extern{.}convert\_any}` is const.




:math:`(\mathsf{global{.}get}~x)` is const if:


  * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

  * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`(\epsilon, t)`.




:math:`({\mathsf{i}}{N} {.} {\mathit{binop}})` is const if:


  * :math:`{\mathsf{i}}{N}` is contained in [:math:`\mathsf{i{\scriptstyle 32}}`; :math:`\mathsf{i{\scriptstyle 64}}`].

  * :math:`{\mathit{binop}}` is contained in [:math:`\mathsf{add}`; :math:`\mathsf{sub}`; :math:`\mathsf{mul}`].




:math:`{{\mathit{instr}}^\ast}` is const if:


  * For all :math:`{\mathit{instr}}` in :math:`{{\mathit{instr}}^\ast}`:

    * :math:`{\mathit{instr}}` is const.




The type definition :math:`(\mathsf{type}~{\mathit{rectype}})` is valid with the defined type sequence :math:`{{\mathit{dt}}^\ast}` if:


  * :math:`{|C{.}\mathsf{types}|}` is equal to :math:`x`.

  * The defined type sequence :math:`{{\mathit{dt}}^\ast}` is equal to :math:`{{{{\mathrm{roll}}}_{x}^\ast}}{({\mathit{rectype}})}`.

  * Let :math:`{C'}` be the same context as :math:`C`, but with the defined type sequence :math:`{{\mathit{dt}}^\ast}` appended to the field :math:`\mathsf{types}`.

  * Under the context :math:`{C'}`, the recursive type :math:`{\mathit{rectype}}` is valid with :math:`({\mathsf{ok}}{x})`.




The local :math:`(\mathsf{local}~t)` is valid with the local type :math:`({\mathit{init}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, t)` if:


  * Either:

    * The initialization status :math:`{\mathit{init}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{set}`.

    * A :ref:`default value <default-val>` for value type the value type :math:`t` is defined.

  * Or:

    * The initialization status :math:`{\mathit{init}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{unset}`.

    * A :ref:`default value <default-val>` for value type the value type :math:`t` is not defined.




The local :math:`(\mathsf{local}~t)` is valid with the local type :math:`(\mathsf{set}, t)` if:


  * A :ref:`default value <default-val>` for value type the value type :math:`t` is defined.




The local :math:`(\mathsf{local}~t)` is valid with the local type :math:`(\mathsf{unset}, t)` if:


  * A :ref:`default value <default-val>` for value type the value type :math:`t` is not defined.




The function :math:`(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}})` is valid with the defined type :math:`C{.}\mathsf{types}{}[x]` if:


  * The defined type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{func}~{t_1^\ast}~\rightarrow~{t_2^\ast})`.

  * :math:`{|{\mathit{local*}}|}` is equal to :math:`{|{\mathit{lct*}}|}`.

  * For all :math:`{{\mathit{lt}}}` in :math:`{{{\mathit{lt}}}^\ast}` and :math:`{\mathit{local}}` in :math:`{{\mathit{local}}^\ast}`:

    * The local :math:`{\mathit{local}}` is valid with the local type :math:`{{\mathit{lt}}}`.

  * Under the context :math:`C{}[{.}\mathsf{locals} \mathrel{{=}{\oplus}} {(\mathsf{set}, t_1)^\ast}~{{{\mathit{lt}}}^\ast}]{}[{.}\mathsf{labels} \mathrel{{=}{\oplus}} {t_2^\ast}]{}[{.}\mathsf{return} \mathrel{{=}{\oplus}} {t_2^\ast}]`, the expression :math:`{\mathit{expr}}` is valid with the result type :math:`{t_2^\ast}`.




The global :math:`(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}})` is valid with the global type :math:`{\mathit{globaltype}}` if:


  * The global type :math:`{\mathit{gt}}` is valid.

  * The global type :math:`{\mathit{globaltype}}` is equal to :math:`({\mathsf{mut}^?}, t)`.

  * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`t`.

  * :math:`{\mathit{expr}}` is const.




The table :math:`(\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}})` is valid with the table type :math:`{\mathit{tabletype}}` if:


  * The table type :math:`{\mathit{tt}}` is valid.

  * The table type :math:`{\mathit{tabletype}}` is equal to :math:`({\mathit{at}}, {\mathit{lim}}, {\mathit{rt}})`.

  * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`{\mathit{rt}}`.

  * :math:`{\mathit{expr}}` is const.




The memory :math:`(\mathsf{memory}~{\mathit{memtype}})` is valid with the memory type :math:`{\mathit{memtype}}` if:


  * The memory type :math:`{\mathit{memtype}}` is valid.




The tag :math:`(\mathsf{tag}~x)` is valid with the tag type :math:`C{.}\mathsf{types}{}[x]` if:


  * The tag type :math:`C{.}\mathsf{types}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the tag type :math:`C{.}\mathsf{types}{}[x]` is the composite type :math:`(\mathsf{func}~{\mathit{functype}})`.




The element mode :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the element type :math:`{\mathit{rt}}` if:


  * Either:

    * The element mode :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{active}~x~{\mathit{expr}})`.

    * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

    * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}, {\mathit{lim}}, {\mathit{rt}'})`.

    * The element type :math:`{\mathit{rt}}` matches the reference type :math:`{\mathit{rt}'}`.

    * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

    * :math:`{\mathit{expr}}` is const.

  * Or:

    * The element mode :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{passive}`.
  * Or:

    * The element mode :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{declare}`.




The element mode :math:`(\mathsf{active}~x~{\mathit{expr}})` is valid with the element type :math:`{\mathit{rt}}` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`({\mathit{at}}, {\mathit{lim}}, {\mathit{rt}'})`.

  * The element type :math:`{\mathit{rt}}` matches the reference type :math:`{\mathit{rt}'}`.

  * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

  * :math:`{\mathit{expr}}` is const.




The element mode :math:`\mathsf{passive}` is valid with the element type :math:`{\mathit{rt}}`.




The element mode :math:`\mathsf{declare}` is valid with the element type :math:`{\mathit{rt}}`.




The table segment :math:`(\mathsf{elem}~{\mathit{elemtype}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}})` is valid with the element type :math:`{\mathit{elemtype}}` if:


  * The element type :math:`{\mathit{elemtype}}` is valid.

  * For all :math:`{\mathit{expr}}` in :math:`{{\mathit{expr}}^\ast}`:

    * The expression :math:`{\mathit{expr}}` is valid with the element type :math:`{\mathit{elemtype}}`.

    * :math:`{\mathit{expr}}` is const.

  * The element mode :math:`{\mathit{elemmode}}` is valid with the element type :math:`{\mathit{elemtype}}`.




The data mode :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the data type :math:`\mathsf{ok}` if:


  * Either:

    * The data mode :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{active}~x~{\mathit{expr}})`.

    * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

    * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`{\mathit{mt}}`.

    * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

    * :math:`{\mathit{expr}}` is const.

  * Or:

    * The data mode :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`\mathsf{passive}`.




The data mode :math:`(\mathsf{active}~x~{\mathit{expr}})` is valid with the data type :math:`\mathsf{ok}` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`{\mathit{mt}}`.

  * The expression :math:`{\mathit{expr}}` is valid with the value type :math:`\mathsf{i{\scriptstyle 32}}`.

  * :math:`{\mathit{expr}}` is const.




The data mode :math:`\mathsf{passive}` is valid with the data type :math:`\mathsf{ok}`.




The memory segment :math:`(\mathsf{data}~{b^\ast}~{\mathit{datamode}})` is valid with the data type :math:`\mathsf{ok}` if:


  * The data mode :math:`{\mathit{datamode}}` is valid with the data type :math:`\mathsf{ok}`.




The start function :math:`(\mathsf{start}~x)` is valid if:


  * The defined type :math:`C{.}\mathsf{funcs}{}[x]` exists.

  * The :ref:`expansion <aux-expand-deftype>` of the defined type :math:`C{.}\mathsf{funcs}{}[x]` is the composite type :math:`(\mathsf{func}~\epsilon~\rightarrow~\epsilon)`.




The import :math:`(\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{xt}})` is valid with the external type :math:`{\mathit{xt}}` if:


  * The external type :math:`{\mathit{xt}}` is valid.




The external index :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` if:


  * Either:

    * The external index :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~x)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{func}~{\mathit{dt}})`.

    * The defined type :math:`C{.}\mathsf{funcs}{}[x]` exists.

    * The defined type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{\mathit{dt}}`.

  * Or:

    * The external index :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~x)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global}~{\mathit{gt}})`.

    * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

    * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`{\mathit{gt}}`.
  * Or:

    * The external index :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~x)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{table}~{\mathit{tt}})`.

    * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

    * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`{\mathit{tt}}`.
  * Or:

    * The external index :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~x)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{mem}~{\mathit{mt}})`.

    * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

    * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`{\mathit{mt}}`.
  * Or:

    * The external index :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{tag}~x)`.

    * The external type :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{tag}~{\mathit{jt}})`.

    * The tag type :math:`C{.}\mathsf{tags}{}[x]` exists.

    * The tag type :math:`C{.}\mathsf{tags}{}[x]` is equal to :math:`{\mathit{jt}}`.




The external index :math:`(\mathsf{func}~x)` is valid with the external type :math:`(\mathsf{func}~{\mathit{dt}})` if:


  * The defined type :math:`C{.}\mathsf{funcs}{}[x]` exists.

  * The defined type :math:`C{.}\mathsf{funcs}{}[x]` is equal to :math:`{\mathit{dt}}`.




The external index :math:`(\mathsf{global}~x)` is valid with the external type :math:`(\mathsf{global}~{\mathit{gt}})` if:


  * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

  * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`{\mathit{gt}}`.




The external index :math:`(\mathsf{table}~x)` is valid with the external type :math:`(\mathsf{table}~{\mathit{tt}})` if:


  * The table type :math:`C{.}\mathsf{tables}{}[x]` exists.

  * The table type :math:`C{.}\mathsf{tables}{}[x]` is equal to :math:`{\mathit{tt}}`.




The external index :math:`(\mathsf{mem}~x)` is valid with the external type :math:`(\mathsf{mem}~{\mathit{mt}})` if:


  * The memory type :math:`C{.}\mathsf{mems}{}[x]` exists.

  * The memory type :math:`C{.}\mathsf{mems}{}[x]` is equal to :math:`{\mathit{mt}}`.




The external index :math:`(\mathsf{tag}~x)` is valid with the external type :math:`(\mathsf{tag}~{\mathit{jt}})` if:


  * The tag type :math:`C{.}\mathsf{tags}{}[x]` exists.

  * The tag type :math:`C{.}\mathsf{tags}{}[x]` is equal to :math:`{\mathit{jt}}`.




The export :math:`(\mathsf{export}~{\mathit{name}}~{\mathit{externidx}})` is valid with the name :math:`{\mathit{name}}` and the external type :math:`{\mathit{xt}}` if:


  * The external index :math:`{\mathit{externidx}}` is valid with the external type :math:`{\mathit{xt}}`.




The global sequence :math:`{{\mathit{global}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is valid with the global type sequence :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` if:


  * Either:

    * The global sequence :math:`{{\mathit{global}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

    * The global type sequence :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

  * Or:

    * The global sequence :math:`{{\mathit{global}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{\mathit{global}}_1~{{\mathit{global}}^\ast}`.

    * The global type sequence :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{\mathit{gt}}_1~{{\mathit{gt}}^\ast}`.

    * The global :math:`{\mathit{global}}_1` is valid with the global type :math:`{\mathit{gt}}_1`.

    * Let :math:`{C'}` be the same context as :math:`C`, but with the global type :math:`{\mathit{gt}}_1` appended to the field :math:`\mathsf{globals}`.

    * Under the context :math:`{C'}`, the global sequence :math:`{{\mathit{global}}^\ast}` is valid with the global type sequence :math:`{{\mathit{gt}}^\ast}`.




The global type sequence :math:`\epsilon` is valid with the global type sequence :math:`\epsilon`.




The global sequence :math:`{\mathit{global}}_1~{{\mathit{global}}^\ast}` is valid with the global type sequence :math:`{\mathit{gt}}_1~{{\mathit{gt}}^\ast}` if:


  * The global :math:`{\mathit{global}}_1` is valid with the global type :math:`{\mathit{gt}}_1`.

  * Let :math:`{C'}` be the same context as :math:`C`, but with the global type :math:`{\mathit{gt}}_1` appended to the field :math:`\mathsf{globals}`.

  * Under the context :math:`{C'}`, the global sequence :math:`{{\mathit{global}}^\ast}` is valid with the global type sequence :math:`{{\mathit{gt}}^\ast}`.




The type definition sequence :math:`{{\mathit{type}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is valid with the defined type sequence :math:`{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` if:


  * Either:

    * The type definition sequence :math:`{{\mathit{type}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

    * The defined type sequence :math:`{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

  * Or:

    * The type definition sequence :math:`{{\mathit{type}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{\mathit{type}}_1~{{\mathit{type}}^\ast}`.

    * The defined type sequence :math:`{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{{\mathit{dt}}_1^\ast}~{{\mathit{dt}}^\ast}`.

    * The type definition :math:`{\mathit{type}}_1` is valid with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}`.

    * Let :math:`{C'}` be the same context as :math:`C`, but with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}` appended to the field :math:`\mathsf{types}`.

    * Under the context :math:`{C'}`, the type definition sequence :math:`{{\mathit{type}}^\ast}` is valid with the defined type sequence :math:`{{\mathit{dt}}^\ast}`.




The defined type sequence :math:`\epsilon` is valid with the defined type sequence :math:`\epsilon`.




The type definition sequence :math:`{\mathit{type}}_1~{{\mathit{type}}^\ast}` is valid with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}~{{\mathit{dt}}^\ast}` if:


  * The type definition :math:`{\mathit{type}}_1` is valid with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}`.

  * Let :math:`{C'}` be the same context as :math:`C`, but with the defined type sequence :math:`{{\mathit{dt}}_1^\ast}` appended to the field :math:`\mathsf{types}`.

  * Under the context :math:`{C'}`, the type definition sequence :math:`{{\mathit{type}}^\ast}` is valid with the defined type sequence :math:`{{\mathit{dt}}^\ast}`.




The module :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` is valid with the module type :math:`t` if:


  * Under the context :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{recs}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{tags}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon,\; \mathsf{return}~\epsilon,\; \mathsf{refs}~\epsilon \}\end{array}`, the type definition sequence :math:`{{\mathit{type}}^\ast}` is valid with the defined type sequence :math:`{{\mathit{dt}'}^\ast}`.

  * :math:`{|{\mathit{xt}}_{\mathsf{i*}}|}` is equal to :math:`{|{\mathit{import*}}|}`.

  * For all :math:`{\mathit{import}}` in :math:`{{\mathit{import}}^\ast}` and :math:`{\mathit{xt}}_{\mathsf{i}}` in :math:`{{\mathit{xt}}_{\mathsf{i}}^\ast}`:

    * Under the context :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{dt}'}^\ast},\; \mathsf{recs}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{tags}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon,\; \mathsf{return}~\epsilon,\; \mathsf{refs}~\epsilon \}\end{array}`, the import :math:`{\mathit{import}}` is valid with the external type :math:`{\mathit{xt}}_{\mathsf{i}}`.

  * Under the context :math:`{C'}`, the global sequence :math:`{{\mathit{global}}^\ast}` is valid with the global type sequence :math:`{{\mathit{gt}}^\ast}`.

  * :math:`{|{\mathit{tt*}}|}` is equal to :math:`{|{\mathit{table*}}|}`.

  * For all :math:`{\mathit{table}}` in :math:`{{\mathit{table}}^\ast}` and :math:`{\mathit{tt}}` in :math:`{{\mathit{tt}}^\ast}`:

    * Under the context :math:`{C'}`, the table :math:`{\mathit{table}}` is valid with the table type :math:`{\mathit{tt}}`.

  * :math:`{|{\mathit{mt*}}|}` is equal to :math:`{|{\mathit{mem*}}|}`.

  * For all :math:`{\mathit{mem}}` in :math:`{{\mathit{mem}}^\ast}` and :math:`{\mathit{mt}}` in :math:`{{\mathit{mt}}^\ast}`:

    * Under the context :math:`{C'}`, the memory :math:`{\mathit{mem}}` is valid with the memory type :math:`{\mathit{mt}}`.

  * :math:`{|{\mathit{tag*}}|}` is equal to :math:`{|{\mathit{jt*}}|}`.

  * For all :math:`{\mathit{jt}}` in :math:`{{\mathit{jt}}^\ast}` and :math:`{\mathit{tag}}` in :math:`{{\mathit{tag}}^\ast}`:

    * Under the context :math:`{C'}`, the tag :math:`{\mathit{tag}}` is valid with the tag type :math:`{\mathit{jt}}`.

  * :math:`{|{\mathit{func*}}|}` is equal to :math:`{|{\mathit{dt*}}|}`.

  * For all :math:`{\mathit{dt}}` in :math:`{{\mathit{dt}}^\ast}` and :math:`{\mathit{func}}` in :math:`{{\mathit{func}}^\ast}`:

    * The function :math:`{\mathit{func}}` is valid with the defined type :math:`{\mathit{dt}}`.

  * :math:`{|{\mathit{rt*}}|}` is equal to :math:`{|{\mathit{elem*}}|}`.

  * For all :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}` and :math:`{\mathit{rt}}` in :math:`{{\mathit{rt}}^\ast}`:

    * The table segment :math:`{\mathit{elem}}` is valid with the element type :math:`{\mathit{rt}}`.

  * :math:`{|{\mathit{ok*}}|}` is equal to :math:`{|{\mathit{data*}}|}`.

  * For all :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}` and :math:`{\mathit{ok}}` in :math:`{{\mathit{ok}}^\ast}`:

    * The memory segment :math:`{\mathit{data}}` is valid with the data type :math:`{\mathit{ok}}`.

  * If :math:`{\mathit{start}}` is defined, then:

    * The start function :math:`{\mathit{start}}` is valid.

  * :math:`{|{\mathit{nm*}}|}` is equal to :math:`{|{\mathit{export*}}|}`.

  * :math:`{|{\mathit{xt}}_{\mathsf{e*}}|}` is equal to :math:`{|{\mathit{export*}}|}`.

  * For all :math:`{\mathit{export}}` in :math:`{{\mathit{export}}^\ast}` and :math:`{\mathit{nm}}` in :math:`{{\mathit{nm}}^\ast}` and :math:`{\mathit{xt}}_{\mathsf{e}}` in :math:`{{\mathit{xt}}_{\mathsf{e}}^\ast}`:

    * The export :math:`{\mathit{export}}` is valid with the name :math:`{\mathit{nm}}` and the external type :math:`{\mathit{xt}}_{\mathsf{e}}`.

  * :math:`{{\mathit{nm}}^\ast}~{\mathrm{disjoint}}` is equal to true.

  * The context :math:`C` is equal to :math:`{C'}{}[{.}\mathsf{globals} \mathrel{{=}{\oplus}} {{\mathit{gt}}^\ast}]{}[{.}\mathsf{tables} \mathrel{{=}{\oplus}} {{\mathit{tt}}_{\mathsf{i}}^\ast}~{{\mathit{tt}}^\ast}]{}[{.}\mathsf{mems} \mathrel{{=}{\oplus}} {{\mathit{mt}}_{\mathsf{i}}^\ast}~{{\mathit{mt}}^\ast}]{}[{.}\mathsf{tags} \mathrel{{=}{\oplus}} {{\mathit{jt}}_{\mathsf{i}}^\ast}~{{\mathit{jt}}^\ast}]{}[{.}\mathsf{elems} \mathrel{{=}{\oplus}} {{\mathit{rt}}^\ast}]{}[{.}\mathsf{datas} \mathrel{{=}{\oplus}} {{\mathit{ok}}^\ast}]`.

  * The context :math:`{C'}` is equal to :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{dt}'}^\ast},\; \mathsf{recs}~\epsilon,\; \mathsf{funcs}~{{\mathit{dt}}_{\mathsf{i}}^\ast}~{{\mathit{dt}}^\ast},\; \mathsf{globals}~{{\mathit{gt}}_{\mathsf{i}}^\ast},\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{tags}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon,\; \mathsf{return}~\epsilon,\; \mathsf{refs}~{x^\ast} \}\end{array}`.

  * The function index sequence :math:`{x^\ast}` is equal to :math:`{\mathrm{funcidx}}(({{\mathit{global}}^\ast}, {{\mathit{table}}^\ast}, {{\mathit{mem}}^\ast}, {{\mathit{elem}}^\ast}, {{\mathit{data}}^\ast}))`.

  * The defined type sequence :math:`{{\mathit{dt}}_{\mathsf{i}}^\ast}` is equal to :math:`{\mathrm{funcs}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

  * The global type sequence :math:`{{\mathit{gt}}_{\mathsf{i}}^\ast}` is equal to :math:`{\mathrm{globals}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

  * The table type sequence :math:`{{\mathit{tt}}_{\mathsf{i}}^\ast}` is equal to :math:`{\mathrm{tables}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

  * The memory type sequence :math:`{{\mathit{mt}}_{\mathsf{i}}^\ast}` is equal to :math:`{\mathrm{mems}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

  * The tag type sequence :math:`{{\mathit{jt}}_{\mathsf{i}}^\ast}` is equal to :math:`{\mathrm{tags}}({{\mathit{xt}}_{\mathsf{i}}^\ast})`.

  * Let :math:`t` be the module type :math:`{{\mathrm{clos}}}_{C}({{\mathit{xt}}_{\mathsf{i}}^\ast}~\rightarrow~{{\mathit{xt}}_{\mathsf{e}}^\ast})`.




The instruction sequence :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is valid with the function type :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~\rightarrow~{t_{\mathit{u{\kern-0.1em\scriptstyle 3}}}^\ast}` if:


  * Either:

    * The instruction sequence :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{i{\scriptstyle 32}} {.} \mathsf{add})`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 3}}}^\ast}` is equal to :math:`\mathsf{i{\scriptstyle 32}}`.

  * Or:

    * The instruction sequence :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{global{.}get}~x)`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`\epsilon`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 3}}}^\ast}` is equal to :math:`t`.

    * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

    * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`({\mathsf{mut}^?}, t)`.
  * Or:

    * The instruction sequence :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is equal to :math:`(\mathsf{block}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast})`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}` is equal to :math:`{t_1^\ast}`.

    * The value type sequence :math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 3}}}^\ast}` is equal to :math:`{t_2^\ast}`.

    * The block type :math:`{\mathit{blocktype}}` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

    * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

    * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the instruction type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.




The instruction sequence :math:`(\mathsf{i{\scriptstyle 32}} {.} \mathsf{add})` is valid with the function type :math:`\mathsf{i{\scriptstyle 32}}~\mathsf{i{\scriptstyle 32}}~\rightarrow~\mathsf{i{\scriptstyle 32}}`.




The instruction sequence :math:`(\mathsf{global{.}get}~x)` is valid with the function type :math:`\epsilon~\rightarrow~t` if:


  * The global type :math:`C{.}\mathsf{globals}{}[x]` exists.

  * The global type :math:`C{.}\mathsf{globals}{}[x]` is equal to :math:`({\mathsf{mut}^?}, t)`.




The instruction sequence :math:`(\mathsf{block}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast})` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` if:


  * The block type :math:`{\mathit{blocktype}}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.

  * Let :math:`{C'}` be the same context as :math:`C`, but with the result type sequence :math:`{t_2^\ast}` prepended to the field :math:`\mathsf{labels}`.

  * Under the context :math:`{C'}`, the instruction sequence :math:`{{\mathit{instr}}^\ast}` is valid with the function type :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}`.


:math:`\mathsf{unreachable}`
............................


1. Trap.


:math:`\mathsf{nop}`
....................


1. Do nothing.


:math:`\mathsf{drop}`
.....................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Do nothing.


:math:`\mathsf{select}~{({t^\ast})^?}`
......................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_2` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}_1` from the stack.

#. If :math:`c \neq 0`, then:

  a. Push the value :math:`{\mathit{val}}_1` to the stack.

#. Else:

  a. Push the value :math:`{\mathit{val}}_2` to the stack.


:math:`\mathsf{if}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast}~{{\mathit{instr}}_2^\ast}`
.....................................................................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

  a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_1^\ast})`.

#. Else:

  a. Execute the instruction :math:`(\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}_2^\ast})`.


:math:`\mathsf{label}`
......................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{label}`.

#. Pop the current :math:`\mathsf{label}` context from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`\mathsf{br}~l`
.....................


1. If the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

  a. Let :math:`({{\mathsf{label}}_{n}}{\{}~{{\mathit{instr}'}^\ast}~\})` be the current :math:`\mathsf{label}` context.

  #. If :math:`l = 0`, then:

    1) Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

    #) Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

    #) Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

    #) Pop the current :math:`\mathsf{label}` context from the stack.

    #) Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

    #) Execute the instruction :math:`{{\mathit{instr}'}^\ast}`.

  #. Else:

    1) Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

    #) If :math:`l > 0`, then:

      a) Pop the current :math:`\mathsf{label}` context from the stack.

      #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

      #) Execute the instruction :math:`(\mathsf{br}~l - 1)`.

#. Else if the first non-value entry of the stack is a :math:`\mathsf{handler}`, then:

  a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

  #. Pop the current :math:`\mathsf{handler}` context from the stack.

  #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{br\_if}~l`
.........................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` from the stack.

#. If :math:`c \neq 0`, then:

  a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

  a. Do nothing.


:math:`\mathsf{br\_table}~{l^\ast}~{l'}`
........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i < {|{l^\ast}|}`, then:

  a. Execute the instruction :math:`(\mathsf{br}~{l^\ast}{}[i])`.

#. Else:

  a. Execute the instruction :math:`(\mathsf{br}~{l'})`.


:math:`\mathsf{br\_on\_null}~l`
...............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else:

  a. Push the value :math:`{\mathit{val}}` to the stack.


:math:`\mathsf{br\_on\_non\_null}~l`
....................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. If :math:`{\mathit{val}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Do nothing.

#. Else:

  a. Push the value :math:`{\mathit{val}}` to the stack.

  #. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{call\_indirect}~x~y`
...................................


1. Execute the instruction :math:`(\mathsf{table{.}get}~x)`.

#. Execute the instruction :math:`(\mathsf{ref{.}cast}~(\mathsf{ref}~\mathsf{null}~y))`.

#. Execute the instruction :math:`(\mathsf{call\_ref}~y)`.


:math:`\mathsf{return\_call\_indirect}~x~y`
...........................................


1. Execute the instruction :math:`(\mathsf{table{.}get}~x)`.

#. Execute the instruction :math:`(\mathsf{ref{.}cast}~(\mathsf{ref}~\mathsf{null}~y))`.

#. Execute the instruction :math:`(\mathsf{return\_call\_ref}~y)`.


:math:`\mathsf{frame}`
......................


1. Let :math:`({{\mathsf{frame}}_{n}}{\{}~f~\})` be the current :math:`\mathsf{frame}` context.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{frame}`.

#. Pop the current :math:`\mathsf{frame}` context from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.


:math:`\mathsf{return}`
.......................


1. If the first non-value entry of the stack is a :math:`\mathsf{frame}`, then:

  a. Let :math:`({{\mathsf{frame}}_{n}}{\{}~f~\})` be the current :math:`\mathsf{frame}` context.

  #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

  #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

  #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

  #. Pop the current :math:`\mathsf{frame}` context from the stack.

  #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Else if the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

  a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

  #. Pop the current :math:`\mathsf{label}` context from the stack.

  #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Execute the instruction :math:`\mathsf{return}`.

#. Else:

  a. If the first non-value entry of the stack is a :math:`\mathsf{handler}`, then:

    1) Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

    #) Pop the current :math:`\mathsf{handler}` context from the stack.

    #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

    #) Execute the instruction :math:`\mathsf{return}`.


:math:`\mathsf{handler}`
........................


1. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Assert: Due to validation, the first non-value entry of the stack is a :math:`\mathsf{handler}`.

#. Pop the current :math:`\mathsf{handler}` context from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{unop}}`
.........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{unop}}}{{}_{{\mathit{nt}}}(c_1)}|} \leq 0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{unop}}}{{}_{{\mathit{nt}}}(c_1)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{binop}}`
..........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{numtype}}_0` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{binop}}}{{}_{{\mathit{nt}}}(c_1, c_2)}|} \leq 0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{binop}}}{{}_{{\mathit{nt}}}(c_1, c_2)}`.

#. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{testop}}`
...........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{testop}}}{{}_{{\mathit{nt}}}(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}} {.} {\mathit{relop}}`
..........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{numtype}}_0` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{relop}}}{{}_{{\mathit{nt}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{nt}}_2 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{nt}}_1}`
............................................................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}_1` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}(c_1)}|} \leq 0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{cvtop}}}{{}_{{\mathit{nt}}_1, {\mathit{nt}}_2}(c_1)}`.

#. Push the value :math:`({\mathit{nt}}_2{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{ref{.}i{\scriptstyle 31}}`
.........................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Push the value :math:`(\mathsf{ref{.}i{\scriptstyle 31}}~{{\mathrm{wrap}}}_{32, 31}(i))` to the stack.


:math:`\mathsf{ref{.}is\_null}`
...............................


1. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. If :math:`{\mathit{ref}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`\mathsf{ref{.}as\_non\_null}`
....................................


1. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. If :math:`{\mathit{ref}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. Push the value :math:`{\mathit{ref}}` to the stack.


:math:`\mathsf{ref{.}eq}`
.........................


1. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}_2` from the stack.

#. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}_1` from the stack.

#. If :math:`{\mathit{ref}}_1` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. If :math:`{\mathit{ref}}_2` is of the case :math:`\mathsf{ref{.}null}`, then:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

  #. Else if :math:`{\mathit{ref}}_1 = {\mathit{ref}}_2`, then:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

  #. Else:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.

#. Else if :math:`{\mathit{ref}}_1 = {\mathit{ref}}_2`, then:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`{\mathsf{i{\scriptstyle 31}{.}get}}{\mathsf{\_}}{{\mathit{sx}}}`
.......................................................................


1. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}i{\scriptstyle 31}}`, then:

  a. Let :math:`(\mathsf{ref{.}i{\scriptstyle 31}}~i)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{31, 32}^{{\mathit{sx}}}}}{(i)})` to the stack.


:math:`\mathsf{array{.}new}~x`
..............................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`\mathsf{extern{.}convert\_any}`
......................................


1. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Push the value :math:`(\mathsf{ref{.}null}~\mathsf{extern})` to the stack.

#. If the type of :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is address value, then:

  a. Let :math:`{\mathit{addrref}}` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Push the value :math:`(\mathsf{ref{.}extern}~{\mathit{addrref}})` to the stack.


:math:`\mathsf{any{.}convert\_extern}`
......................................


1. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Push the value :math:`(\mathsf{ref{.}null}~\mathsf{any})` to the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}extern}`, then:

  a. Let :math:`(\mathsf{ref{.}extern}~{\mathit{addrref}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Push the value :math:`{\mathit{addrref}}` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvunop}}`
..........................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{|{{\mathit{vvunop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1)}|} > 0`.

#. Let :math:`c` be an element of :math:`{{\mathit{vvunop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvbinop}}`
...........................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{|{{\mathit{vvbinop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2)}|} > 0`.

#. Let :math:`c` be an element of :math:`{{\mathit{vvbinop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} {\mathit{vvternop}}`
............................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_3)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{|{{\mathit{vvternop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2, c_3)}|} > 0`.

#. Let :math:`c` be an element of :math:`{{\mathit{vvternop}}}{{}_{\mathsf{v{\scriptstyle 128}}}(c_1, c_2, c_3)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{v{\scriptstyle 128}} {.} \mathsf{any\_true}`
...........................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{ine}}}_{{|\mathsf{v{\scriptstyle 128}}|}}(c_1, 0)`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vunop}}`
..........................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{vunop}}}{{}_{{\mathit{sh}}}(c_1)}|} \leq 0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vunop}}}{{}_{{\mathit{sh}}}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vbinop}}`
...........................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}(c_1, c_2)}|} \leq 0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vbinop}}}{{}_{{\mathit{sh}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vternop}}`
............................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_3)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{|{{\mathit{vternop}}}{{}_{{\mathit{sh}}}(c_1, c_2, c_3)}|} \leq 0`, then:

  a. Trap.

#. Let :math:`c` be an element of :math:`{{\mathit{vternop}}}{{}_{{\mathit{sh}}}(c_1, c_2, c_3)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vtestop}}`
............................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`i` be :math:`{{\mathit{vtestop}}}{{}_{{\mathit{sh}}}(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vrelop}}`
...........................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vrelop}}}{{}_{{\mathit{sh}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{vshiftop}}`
.............................................


1. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vshiftop}}}{{}_{{\mathit{sh}}}}{(c_1, i)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}{.}\mathsf{bitmask}`
........................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{\mathsf{vbitmask}}{{}_{{\mathit{sh}}}(c_1)}`.

#. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}} {.} {\mathit{swizzlop}}`
.............................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{swizzlop}}}{{}_{{\mathit{sh}}}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}{.}\mathsf{shuffle}~{i^\ast}`
.................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{\mathsf{vshuffle}}{{}_{{\mathit{sh}}}({i^\ast}, c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathsf{i}}{N}}{\mathsf{x}}{M}{.}\mathsf{splat}`
.........................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = {\mathrm{unpack}}({\mathsf{i}}{N})`.

#. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({{{\mathrm{pack}}}_{{\mathsf{i}}{N}}(c_1)^{M}})}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}{.}\mathsf{extract\_lane}}{\mathsf{\_}}{{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~i`
...................................................................................................................................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. If :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined and the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

  a. Let :math:`{\mathit{nt}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`i < {|{{\mathrm{lanes}}}_{{{\mathit{nt}}}{\mathsf{x}}{M}}(c_1)|}`, then:

    1) Let :math:`c_2` be :math:`{{\mathrm{lanes}}}_{{{\mathit{nt}}}{\mathsf{x}}{M}}(c_1){}[i]`.

    #) Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c_2)` to the stack.

#. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type, then:

  a. Let :math:`{\mathit{pt}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

    1) Let :math:`{\mathit{sx}}` be :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

    #) If :math:`i < {|{{\mathrm{lanes}}}_{{{\mathit{pt}}}{\mathsf{x}}{M}}(c_1)|}`, then:

      a) Let :math:`c_2` be :math:`{{{{\mathrm{extend}}}_{{|{\mathit{pt}}|}, 32}^{{\mathit{sx}}}}}{({{\mathrm{lanes}}}_{{{\mathit{pt}}}{\mathsf{x}}{M}}(c_1){}[i])}`.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~c_2)` to the stack.


:math:`{{\mathsf{i}}{N}}{\mathsf{x}}{M}{.}\mathsf{replace\_lane}~i`
...................................................................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = {\mathrm{unpack}}({\mathsf{i}}{N})`.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c_1){}[{}[i] = {{\mathrm{pack}}}_{{\mathsf{i}}{N}}(c_2)])}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}_2 {.} {{\mathit{vextunop}}}{\mathsf{\_}}{{\mathit{sh}}_1}`
...............................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vextunop}}}{{}_{{\mathit{sh}}_1, {\mathit{sh}}_2}(c_1)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}_2 {.} {{\mathit{vextbinop}}}{\mathsf{\_}}{{\mathit{sh}}_1}`
................................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vextbinop}}}{{}_{{\mathit{sh}}_1, {\mathit{sh}}_2}(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}_2 {.} {{\mathit{vextternop}}}{\mathsf{\_}}{{\mathit{sh}}_1}`
.................................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_3)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathit{vextternop}}}{{}_{{\mathit{sh}}_1, {\mathit{sh}}_2}(c_1, c_2, c_3)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{{\mathit{sh}}_2{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{sh}}_1}{\mathsf{\_}}{{\mathit{sx}}}`
.....................................................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{\mathsf{vnarrow}}{{{}_{{\mathit{sh}}_1, {\mathit{sh}}_2}^{{\mathit{sx}}}}}{(c_1, c_2)}`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathit{sh}}_2 {.} {{\mathit{vcvtop}}}{\mathsf{\_}}{{{\mathit{zero}}^?}}{\mathsf{\_}}{{\mathit{sh}}_1}{\mathsf{\_}}{{{\mathit{half}}^?}}`
.................................................................................................................................................


1. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Let :math:`c` be :math:`{{\mathrm{vcvtop}}}_{{\mathit{sh}}_1, {\mathit{sh}}_2}({\mathit{vcvtop}}, {{\mathit{half}}^?}, {{\mathit{zero}}^?}, c_1)`.

#. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{local{.}tee}~x`
..............................


1. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Push the value :math:`{\mathit{val}}` to the stack.

#. Execute the instruction :math:`(\mathsf{local{.}set}~x)`.


:math:`\mathsf{block}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
............................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{m}}~\rightarrow~{t_2^{n}}` be :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`m` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{m}}` from the stack.

#. Enter :math:`{{\mathit{val}}^{m}}~{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{n}}{\{}~\epsilon~\})`.


:math:`\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast}`
...........................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{m}}~\rightarrow~{t_2^{n}}` be :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`m` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{m}}` from the stack.

#. Enter :math:`{{\mathit{val}}^{m}}~{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{m}}{\{}~(\mathsf{loop}~{\mathit{bt}}~{{\mathit{instr}}^\ast})~\})`.


:math:`\mathsf{br\_on\_cast}~l~{\mathit{rt}}_1~{\mathit{rt}}_2`
...............................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. If :math:`{\mathit{ref}}` is not :ref:`valid <valid-val>`, then:

  a. Fail.

#. Let :math:`{\mathit{rt}}` be the type of :math:`{\mathit{ref}}`.

#. Push the value :math:`{\mathit{ref}}` to the stack.

#. If :math:`{\mathit{rt}}` does not match :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}}_2)`, then:

  a. Do nothing.

#. Else:

  a. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{br\_on\_cast\_fail}~l~{\mathit{rt}}_1~{\mathit{rt}}_2`
.....................................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. If :math:`{\mathit{ref}}` is not :ref:`valid <valid-val>`, then:

  a. Fail.

#. Let :math:`{\mathit{rt}}` be the type of :math:`{\mathit{ref}}`.

#. Push the value :math:`{\mathit{ref}}` to the stack.

#. If :math:`{\mathit{rt}}` matches :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}}_2)`, then:

  a. Do nothing.

#. Else:

  a. Execute the instruction :math:`(\mathsf{br}~l)`.


:math:`\mathsf{call}~x`
.......................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Let :math:`a` be :math:`z{.}\mathsf{module}{.}\mathsf{funcs}{}[x]`.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~a)` to the stack.

#. Execute the instruction :math:`(\mathsf{call\_ref}~z{.}\mathsf{funcs}{}[a]{.}\mathsf{type})`.


:math:`\mathsf{call\_ref}~y`
............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}func}`, then:

  a. Let :math:`(\mathsf{ref{.}func}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`a < {|z{.}\mathsf{funcs}|}`, then:

    1) Let :math:`{\mathit{fi}}` be :math:`z{.}\mathsf{funcs}{}[a]`.

    #) Assert: Due to validation, :math:`{\mathit{fi}}{.}\mathsf{code}` is of the case :math:`\mathsf{func}`.

    #) Let :math:`(\mathsf{func}~x~{{\mathit{local}}_0^\ast}~{{\mathit{instr}}^\ast})` be :math:`{\mathit{fi}}{.}\mathsf{code}`.

    #) If for all :math:`{\mathit{local}}_0` in :math:`{{\mathit{local}}_0^\ast}`, :math:`{\mathit{local}}_0` is of the case :math:`\mathsf{local}`, then:

      a) Let :math:`{(\mathsf{local}~t)^\ast}` be :math:`{{\mathit{local}}_0^\ast}`.

      #) Assert: Due to validation, :math:`{\mathrm{expand}}({\mathit{fi}}{.}\mathsf{type})` is of the case :math:`\mathsf{func}`.

      #) Let :math:`(\mathsf{func}~{\mathit{functype}}_0)` be :math:`{\mathrm{expand}}({\mathit{fi}}{.}\mathsf{type})`.

      #) Let :math:`{t_1^{n}}~\rightarrow~{t_2^{m}}` be :math:`{\mathit{functype}}_0`.

      #) Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

      #) Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

      #) Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~{{\mathit{val}}^{n}}~{{{\mathrm{default}}}_{t}^\ast},\; \mathsf{module}~{\mathit{fi}}{.}\mathsf{module} \}\end{array}`.

      #) Push the evaluation context :math:`({{\mathsf{frame}}_{m}}{\{}~f~\})` to the stack.

      #) Enter :math:`{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{m}}{\{}~\epsilon~\})`.


:math:`\mathsf{return\_call}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Let :math:`a` be :math:`z{.}\mathsf{module}{.}\mathsf{funcs}{}[x]`.

#. Assert: Due to validation, :math:`a < {|z{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~a)` to the stack.

#. Execute the instruction :math:`(\mathsf{return\_call\_ref}~z{.}\mathsf{funcs}{}[a]{.}\mathsf{type})`.


:math:`\mathsf{return\_call\_ref}~y`
....................................


1. Let :math:`z` be the current state.

#. If the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

  a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

  #. Pop the current :math:`\mathsf{label}` context from the stack.

  #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Execute the instruction :math:`(\mathsf{return\_call\_ref}~y)`.

#. Else if the first non-value entry of the stack is a :math:`\mathsf{handler}`, then:

  a. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

  #. Pop the current :math:`\mathsf{handler}` context from the stack.

  #. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

  #. Execute the instruction :math:`(\mathsf{return\_call\_ref}~y)`.

#. Else:

  a. If the first non-value entry of the stack is a :math:`\mathsf{frame}`, then:

    1) Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

    #) Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

    #) If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

      a) Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

      #) Pop the current :math:`\mathsf{frame}` context from the stack.

      #) Trap.

    #) If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}func}`, then:

      a) Let :math:`(\mathsf{ref{.}func}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) If :math:`a < {|z{.}\mathsf{funcs}|}`, then:

        1. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{funcs}{}[a]{.}\mathsf{type})` is of the case :math:`\mathsf{func}`.

        #. Let :math:`(\mathsf{func}~{\mathit{functype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{funcs}{}[a]{.}\mathsf{type})`.

        #. Let :math:`{t_1^{n}}~\rightarrow~{t_2^{m}}` be :math:`{\mathit{functype}}_0`.

        #. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

        #. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

        #. Pop all values :math:`{{\mathit{val}'}^\ast}` from the top of the stack.

        #. Pop the current :math:`\mathsf{frame}` context from the stack.

        #. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

        #. Push the value :math:`(\mathsf{ref{.}func}~a)` to the stack.

        #. Execute the instruction :math:`(\mathsf{call\_ref}~y)`.


:math:`\mathsf{throw\_ref}`
...........................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}exn}`, then:

  a. Let :math:`(\mathsf{ref{.}exn}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

  #. If :math:`{{\mathit{val}}^\ast} \neq \epsilon`, then:

    1) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

    #) Execute the instruction :math:`\mathsf{throw\_ref}`.

  #. Else if the first non-value entry of the stack is a :math:`\mathsf{label}`, then:

    1) Pop the current :math:`\mathsf{label}` context from the stack.

    #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

    #) Execute the instruction :math:`\mathsf{throw\_ref}`.

  #. Else:

    1) If the first non-value entry of the stack is a :math:`\mathsf{frame}`, then:

      a) Pop the current :math:`\mathsf{frame}` context from the stack.

      #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

      #) Execute the instruction :math:`\mathsf{throw\_ref}`.

    #) Else if not the first non-value entry of the stack is a :math:`\mathsf{handler}`, then:

      a) Throw the exception :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` as a result.

    #) Else:

      a) Let :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~\})` be the current :math:`\mathsf{handler}` context.

      #) If :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

        1. Pop the current :math:`\mathsf{handler}` context from the stack.

        #. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

        #. Execute the instruction :math:`\mathsf{throw\_ref}`.

      #) Else if :math:`a \geq {|z{.}\mathsf{exns}|}`, then:

        1. Let :math:`{\mathit{catch}}_0~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

        #. If :math:`{\mathit{catch}}_0` is of the case :math:`\mathsf{catch\_all}`, then:

          a. Let :math:`(\mathsf{catch\_all}~l)` be :math:`{\mathit{catch}}_0`.

          #. Pop the current :math:`\mathsf{handler}` context from the stack.

          #. Execute the instruction :math:`(\mathsf{br}~l)`.

        #. Else if :math:`{\mathit{catch}}_0` is not of the case :math:`\mathsf{catch\_all\_ref}`, then:

          a. Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

          #. Pop the current :math:`\mathsf{handler}` context from the stack.

          #. Push the evaluation context :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}'}^\ast}~\})` to the stack.

          #. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

          #. Execute the instruction :math:`\mathsf{throw\_ref}`.

        #. Else:

          a. Let :math:`(\mathsf{catch\_all\_ref}~l)` be :math:`{\mathit{catch}}_0`.

          #. Pop the current :math:`\mathsf{handler}` context from the stack.

          #. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

          #. Execute the instruction :math:`(\mathsf{br}~l)`.

      #) Else:

        1. Let :math:`{{\mathit{val}}^\ast}` be :math:`z{.}\mathsf{exns}{}[a]{.}\mathsf{fields}`.

        #. Let :math:`{\mathit{catch}}_0~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

        #. If :math:`{\mathit{catch}}_0` is of the case :math:`\mathsf{catch}`, then:

          a. Let :math:`(\mathsf{catch}~x~l)` be :math:`{\mathit{catch}}_0`.

          #. If :math:`x < {|z{.}\mathsf{tags}|}` and :math:`z{.}\mathsf{exns}{}[a]{.}\mathsf{tag} = z{.}\mathsf{tags}{}[x]`, then:

            1) Pop the current :math:`\mathsf{handler}` context from the stack.

            #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

            #) Execute the instruction :math:`(\mathsf{br}~l)`.

          #. Else:

            1) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

            #) Pop the current :math:`\mathsf{handler}` context from the stack.

            #) Push the evaluation context :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}'}^\ast}~\})` to the stack.

            #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

            #) Execute the instruction :math:`\mathsf{throw\_ref}`.

        #. Else if :math:`{\mathit{catch}}_0` is of the case :math:`\mathsf{catch\_ref}`, then:

          a. Let :math:`(\mathsf{catch\_ref}~x~l)` be :math:`{\mathit{catch}}_0`.

          #. If :math:`x \geq {|z{.}\mathsf{tags}|}`, then:

            1) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

            #) Pop the current :math:`\mathsf{handler}` context from the stack.

            #) Push the evaluation context :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}'}^\ast}~\})` to the stack.

            #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

            #) Execute the instruction :math:`\mathsf{throw\_ref}`.

          #. Else if :math:`z{.}\mathsf{exns}{}[a]{.}\mathsf{tag} \neq z{.}\mathsf{tags}{}[x]`, then:

            1) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

            #) Pop the current :math:`\mathsf{handler}` context from the stack.

            #) Push the evaluation context :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}'}^\ast}~\})` to the stack.

            #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

            #) Execute the instruction :math:`\mathsf{throw\_ref}`.

          #. Else:

            1) Pop the current :math:`\mathsf{handler}` context from the stack.

            #) Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

            #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

            #) Execute the instruction :math:`(\mathsf{br}~l)`.

        #. Else:

          a. If :math:`{\mathit{catch}}_0` is of the case :math:`\mathsf{catch\_all}`, then:

            1) Let :math:`(\mathsf{catch\_all}~l)` be :math:`{\mathit{catch}}_0`.

            #) Pop the current :math:`\mathsf{handler}` context from the stack.

            #) Execute the instruction :math:`(\mathsf{br}~l)`.

          #. Else if :math:`{\mathit{catch}}_0` is not of the case :math:`\mathsf{catch\_all\_ref}`, then:

            1) Let :math:`{\mathit{catch}}~{{\mathit{catch}'}^\ast}` be :math:`{{\mathit{catch}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

            #) Pop the current :math:`\mathsf{handler}` context from the stack.

            #) Push the evaluation context :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}'}^\ast}~\})` to the stack.

            #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

            #) Execute the instruction :math:`\mathsf{throw\_ref}`.

          #. Else:

            1) Let :math:`(\mathsf{catch\_all\_ref}~l)` be :math:`{\mathit{catch}}_0`.

            #) Pop the current :math:`\mathsf{handler}` context from the stack.

            #) Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

            #) Execute the instruction :math:`(\mathsf{br}~l)`.

#. Else if not the first non-value entry of the stack is a :math:`\mathsf{label}` and not the first non-value entry of the stack is a :math:`\mathsf{frame}` and not the first non-value entry of the stack is a :math:`\mathsf{handler}`, then:

  a. Throw the exception :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` as a result.


:math:`\mathsf{try\_table}~{\mathit{bt}}~{{\mathit{catch}}^\ast}~{{\mathit{instr}}^\ast}`
.........................................................................................


1. Let :math:`z` be the current state.

#. Let :math:`{t_1^{m}}~\rightarrow~{t_2^{n}}` be :math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}})`.

#. Assert: Due to validation, there are at least :math:`m` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{m}}` from the stack.

#. Push the evaluation context :math:`({{\mathsf{handler}}_{n}}{\{}~{{\mathit{catch}}^\ast}~\})` to the stack.

#. Enter :math:`{{\mathit{val}}^{m}}~{{\mathit{instr}}^\ast}` with label :math:`({{\mathsf{label}}_{n}}{\{}~\epsilon~\})`.


:math:`\mathsf{ref{.}null}~x`
.............................


1. Let :math:`z` be the current state.

#. Push the value :math:`(\mathsf{ref{.}null}~z{.}\mathsf{types}{}[x])` to the stack.


:math:`\mathsf{ref{.}func}~x`
.............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{module}{.}\mathsf{funcs}|}`.

#. Push the value :math:`(\mathsf{ref{.}func}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x])` to the stack.


:math:`\mathsf{ref{.}test}~{\mathit{rt}}`
.........................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. If :math:`{\mathit{ref}}` is not :ref:`valid <valid-val>`, then:

  a. Fail.

#. Let :math:`{\mathit{rt}'}` be the type of :math:`{\mathit{ref}}`.

#. If :math:`{\mathit{rt}'}` matches :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}})`, then:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~1)` to the stack.

#. Else:

  a. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)` to the stack.


:math:`\mathsf{ref{.}cast}~{\mathit{rt}}`
.........................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. If :math:`{\mathit{ref}}` is not :ref:`valid <valid-val>`, then:

  a. Fail.

#. Let :math:`{\mathit{rt}'}` be the type of :math:`{\mathit{ref}}`.

#. If :math:`{\mathit{rt}'}` does not match :math:`{{\mathrm{inst}}}_{f{.}\mathsf{module}}({\mathit{rt}})`, then:

  a. Trap.

#. Push the value :math:`{\mathit{ref}}` to the stack.


:math:`\mathsf{struct{.}new\_default}~x`
........................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{struct}`.

#. Let :math:`(\mathsf{struct}~{\mathit{structtype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

#. Let :math:`{({\mathsf{mut}^?}, {\mathit{zt}})^\ast}` be :math:`{\mathit{structtype}}_0`.

#. Assert: Due to validation, for all :math:`{\mathit{zt}}` in :math:`{{\mathit{zt}}^\ast}`, :math:`{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}` is defined.

#. Let :math:`{{\mathit{val}}^\ast}` be :math:`{{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}^\ast}`.

#. Assert: Due to validation, :math:`{|{\mathit{val*}}|} = {|{\mathit{zt*}}|}`.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

#. Execute the instruction :math:`(\mathsf{struct{.}new}~x)`.


:math:`{\mathsf{struct{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x~i`
...................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}struct}`, then:

  a. Let :math:`(\mathsf{ref{.}struct}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`i < {|z{.}\mathsf{structs}{}[a]{.}\mathsf{fields}|}` and :math:`a < {|z{.}\mathsf{structs}|}`, then:

    1) Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{struct}`.

    #) Let :math:`(\mathsf{struct}~{\mathit{structtype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

    #) Let :math:`{({\mathsf{mut}^?}, {\mathit{zt}})^\ast}` be :math:`{\mathit{structtype}}_0`.

    #) If :math:`i < {|{{\mathit{zt}}^\ast}|}`, then:

      a) Push the value :math:`{{{{\mathrm{unpack}}}_{{{\mathit{zt}}^\ast}{}[i]}^{{{\mathit{sx}}^?}}}}{(z{.}\mathsf{structs}{}[a]{.}\mathsf{fields}{}[i])}` to the stack.


:math:`\mathsf{array{.}new\_default}~x`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{array}`.

#. Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

#. Let :math:`({\mathsf{mut}^?}, {\mathit{zt}})` be :math:`{\mathit{arraytype}}_0`.

#. Assert: Due to validation, :math:`{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}` is defined.

#. Let :math:`{\mathit{val}}` be :math:`{{\mathrm{default}}}_{{\mathrm{unpack}}({\mathit{zt}})}`.

#. Push the values :math:`{{\mathit{val}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`\mathsf{array{.}new\_elem}~x~y`
......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. Assert: Due to validation, :math:`{|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[i : n]|} = n`.

#. Let :math:`{{\mathit{ref}}^\ast}` be :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[i : n]`.

#. Push the values :math:`{{\mathit{ref}}^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`\mathsf{array{.}new\_data}~x~y`
......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{array}`.

#. Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

#. Let :math:`({\mathsf{mut}^?}, {\mathit{zt}})` be :math:`{\mathit{arraytype}}_0`.

#. If :math:`i + n \cdot {|{\mathit{zt}}|} / 8 > {|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. Assert: Due to validation, the length of :math:`({\mathit{fresh}}_1)` for which :math:`{\bigoplus}\, {\mathit{fresh}}_1` :math:`=` :math:`z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}{}[i : n \cdot {|{\mathit{zt}}|} / 8]` is :math:`n`.

#. Let :math:`{{{\mathit{byte}}^\ast}^\ast}` be the result for which :math:`{\bigoplus}\, {{{\mathit{byte}}^\ast}^\ast}` :math:`=` :math:`z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}{}[i : n \cdot {|{\mathit{zt}}|} / 8]`.

#. Let :math:`{c^\ast}` be the result for which :math:`{({{\mathrm{bytes}}}_{{\mathit{zt}}}({c^\ast}) = {{\mathit{byte}}^\ast})^\ast}`.

#. Push the values :math:`{{\mathrm{unpack}}({\mathit{zt}}){.}\mathsf{const}~{{\mathrm{unpack}}}_{{\mathit{zt}}}(c)^{n}}` to the stack.

#. Execute the instruction :math:`(\mathsf{array{.}new\_fixed}~x~n)`.


:math:`{\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x`
................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}array}`, then:

  a. Let :math:`(\mathsf{ref{.}array}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`a < {|z{.}\mathsf{arrays}|}` and :math:`i \geq {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

    1) Trap.

  #. If :math:`i < {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}` and :math:`a < {|z{.}\mathsf{arrays}|}`, then:

    1) Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{array}`.

    #) Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

    #) Let :math:`({\mathsf{mut}^?}, {\mathit{zt}})` be :math:`{\mathit{arraytype}}_0`.

    #) Push the value :math:`{{{{\mathrm{unpack}}}_{{\mathit{zt}}}^{{{\mathit{sx}}^?}}}}{(z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}{}[i])}` to the stack.


:math:`\mathsf{array{.}len}`
............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}array}`, then:

  a. Let :math:`(\mathsf{ref{.}array}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`a < {|z{.}\mathsf{arrays}|}`, then:

    1) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|})` to the stack.


:math:`\mathsf{array{.}fill}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}array}`, then:

  a. Let :math:`(\mathsf{ref{.}array}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`a \geq {|z{.}\mathsf{arrays}|}`, then:

    1) Do nothing.

  #. Else if :math:`i + n > {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

    1) Trap.

  #. If :math:`n = 0`, then:

    1) Do nothing.

  #. Else:

    1) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

    #) Push the value :math:`{\mathit{val}}` to the stack.

    #) Execute the instruction :math:`(\mathsf{array{.}set}~x)`.

    #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

    #) Push the value :math:`{\mathit{val}}` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

    #) Execute the instruction :math:`(\mathsf{array{.}fill}~x)`.


:math:`\mathsf{array{.}copy}~x_1~x_2`
.....................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2)` from the stack.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1)` from the stack.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is of the case :math:`\mathsf{ref{.}null}` and the type of :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is reference value, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}null}` and the type of :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is reference value, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is of the case :math:`\mathsf{ref{.}array}`, then:

  a. Let :math:`(\mathsf{ref{.}array}~a_1)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}array}`, then:

    1) If :math:`a_1 < {|z{.}\mathsf{arrays}|}` and :math:`i_1 + n > {|z{.}\mathsf{arrays}{}[a_1]{.}\mathsf{fields}|}`, then:

      a) Trap.

    #) Let :math:`(\mathsf{ref{.}array}~a_2)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) If :math:`a_2 \geq {|z{.}\mathsf{arrays}|}`, then:

      a) Do nothing.

    #) Else if :math:`i_2 + n > {|z{.}\mathsf{arrays}{}[a_2]{.}\mathsf{fields}|}`, then:

      a) Trap.

    #) If :math:`n = 0`, then:

      a) Do nothing.

    #) Else if :math:`i_1 \leq i_2` and :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x_2])` is of the case :math:`\mathsf{array}`, then:

      a) Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x_2])`.

      #) Let :math:`({\mathsf{mut}^?}, {\mathit{zt}}_2)` be :math:`{\mathit{arraytype}}_0`.

      #) Let :math:`{{\mathit{sx}}^?}` be :math:`{\mathrm{sx}}({\mathit{zt}}_2)`.

      #) Push the value :math:`(\mathsf{ref{.}array}~a_1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1)` to the stack.

      #) Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2)` to the stack.

      #) Execute the instruction :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x_2)`.

      #) Execute the instruction :math:`(\mathsf{array{.}set}~x_1)`.

      #) Push the value :math:`(\mathsf{ref{.}array}~a_1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1 + 1)` to the stack.

      #) Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2 + 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

      #) Execute the instruction :math:`(\mathsf{array{.}copy}~x_1~x_2)`.

    #) Else:

      a) If :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x_2])` is of the case :math:`\mathsf{array}`, then:

        1. Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x_2])`.

        #. Let :math:`({\mathsf{mut}^?}, {\mathit{zt}}_2)` be :math:`{\mathit{arraytype}}_0`.

        #. Let :math:`{{\mathit{sx}}^?}` be :math:`{\mathrm{sx}}({\mathit{zt}}_2)`.

        #. Push the value :math:`(\mathsf{ref{.}array}~a_1)` to the stack.

        #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1 + n - 1)` to the stack.

        #. Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

        #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2 + n - 1)` to the stack.

        #. Execute the instruction :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~x_2)`.

        #. Execute the instruction :math:`(\mathsf{array{.}set}~x_1)`.

        #. Push the value :math:`(\mathsf{ref{.}array}~a_1)` to the stack.

        #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_1)` to the stack.

        #. Push the value :math:`(\mathsf{ref{.}array}~a_2)` to the stack.

        #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i_2)` to the stack.

        #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

        #. Execute the instruction :math:`(\mathsf{array{.}copy}~x_1~x_2)`.

  #. Else if :math:`n \neq 0`, then:

    1) Do nothing.


:math:`\mathsf{array{.}init\_elem}~x~y`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}array}`, then:

  a. Let :math:`(\mathsf{ref{.}array}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`a < {|z{.}\mathsf{arrays}|}` and :math:`i + n > {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

    1) Trap.

  #. If :math:`j + n > {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

    1) Trap.

  #. If :math:`n = 0`, then:

    1) Do nothing.

  #. Else if :math:`j < {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

    1) Let :math:`{\mathit{ref}}` be :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[j]`.

    #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

    #) Push the value :math:`{\mathit{ref}}` to the stack.

    #) Execute the instruction :math:`(\mathsf{array{.}set}~x)`.

    #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

    #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

    #) Execute the instruction :math:`(\mathsf{array{.}init\_elem}~x~y)`.


:math:`\mathsf{array{.}init\_data}~x~y`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}array}`, then:

  a. Let :math:`(\mathsf{ref{.}array}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`a < {|z{.}\mathsf{arrays}|}` and :math:`i + n > {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

    1) Trap.

  #. If :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{array}`, then:

    1) Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

    #) Let :math:`({\mathsf{mut}^?}, {\mathit{zt}})` be :math:`{\mathit{arraytype}}_0`.

    #) If :math:`j + n \cdot {|{\mathit{zt}}|} / 8 > {|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

      a) Trap.

    #) If :math:`n = 0`, then:

      a) Do nothing.

    #) Else:

      a) Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathit{zt}}}(c)` :math:`=` :math:`z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}{}[j : {|{\mathit{zt}}|} / 8]`.

      #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` to the stack.

      #) Push the value :math:`{\mathrm{unpack}}({\mathit{zt}}){.}\mathsf{const}~{{\mathrm{unpack}}}_{{\mathit{zt}}}(c)` to the stack.

      #) Execute the instruction :math:`(\mathsf{array{.}set}~x)`.

      #) Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i + 1)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + {|{\mathit{zt}}|} / 8)` to the stack.

      #) Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

      #) Execute the instruction :math:`(\mathsf{array{.}init\_data}~x~y)`.

  #. Else if :math:`n = 0`, then:

    1) Do nothing.


:math:`\mathsf{local{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`z{.}\mathsf{locals}{}[x]` is defined.

#. Let :math:`{\mathit{val}}` be :math:`z{.}\mathsf{locals}{}[x]`.

#. Push the value :math:`{\mathit{val}}` to the stack.


:math:`\mathsf{global{.}get}~x`
...............................


1. Let :math:`z` be the current state.

#. Let :math:`{\mathit{val}}` be :math:`z{.}\mathsf{globals}{}[x]{.}\mathsf{value}`.

#. Push the value :math:`{\mathit{val}}` to the stack.


:math:`\mathsf{table{.}get}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. Push the value :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i]` to the stack.


:math:`\mathsf{table{.}size}~x`
...............................


1. Let :math:`z` be the current state.

#. Let :math:`({\mathit{at}}, {\mathit{lim}}, {\mathit{rt}})` be :math:`z{.}\mathsf{tables}{}[x]{.}\mathsf{type}`.

#. Let :math:`n` be :math:`{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`.

#. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{table{.}fill}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`n = 0`, then:

  a. Do nothing.

#. Else:

  a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` to the stack.

  #. Push the value :math:`{\mathit{val}}` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

  #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Push the value :math:`{\mathit{val}}` to the stack.

  #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}fill}~x)`.


:math:`\mathsf{table{.}copy}~x_1~x_2`
.....................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}'}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}'}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}_2` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}_1` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` from the stack.

#. If :math:`i_1 + n > {|z{.}\mathsf{tables}{}[x_1]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`i_2 + n > {|z{.}\mathsf{tables}{}[x_2]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`n = 0`, then:

  a. Do nothing.

#. Else:

  a. If :math:`i_1 \leq i_2`, then:

    1) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` to the stack.

    #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` to the stack.

    #) Execute the instruction :math:`(\mathsf{table{.}get}~x_2)`.

    #) Execute the instruction :math:`(\mathsf{table{.}set}~x_1)`.

    #) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1 + 1)` to the stack.

    #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2 + 1)` to the stack.

  #. Else:

    1) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1 + n - 1)` to the stack.

    #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2 + n - 1)` to the stack.

    #) Execute the instruction :math:`(\mathsf{table{.}get}~x_2)`.

    #) Execute the instruction :math:`(\mathsf{table{.}set}~x_1)`.

    #) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` to the stack.

    #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` to the stack.

  #. Push the value :math:`({\mathit{at}'}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}copy}~x_1~x_2)`.


:math:`\mathsf{table{.}init}~x~y`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. If :math:`n = 0`, then:

  a. Do nothing.

#. Else if :math:`j < {|z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}|}`, then:

  a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` to the stack.

  #. Push the value :math:`z{.}\mathsf{elems}{}[y]{.}\mathsf{refs}{}[j]` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}set}~x)`.

  #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{table{.}init}~x~y)`.


:math:`{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{load}}{{{\mathit{loadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~x~{\mathit{ao}}`
..............................................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`{{\mathit{loadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Let :math:`{\mathit{nt}}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}}|} / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

    1) Trap.

  #. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathit{nt}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}}|} / 8]`.

  #. Push the value :math:`({\mathit{nt}}{.}\mathsf{const}~c)` to the stack.

#. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. If :math:`{{\mathit{loadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

    1) Let :math:`{\mathit{loadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{loadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

    #) Let :math:`(n, {\mathit{sx}})` be :math:`{\mathit{loadop\_{\scriptstyle 0}}}`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

      a) Trap.

  #. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{{\mathit{loadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

    1) Let :math:`{\mathit{loadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{loadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

    #) Let :math:`(n, {\mathit{sx}})` be :math:`{\mathit{loadop\_{\scriptstyle 0}}}`.

    #) Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8]`.

    #) Push the value :math:`({\mathsf{i}}{N}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{n, {|{\mathsf{i}}{N}|}}^{{\mathit{sx}}}}}{(c)})` to the stack.


:math:`{\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~x~{\mathit{ao}}`
......................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}` and :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Trap.

#. If :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Let :math:`c` be the result for which :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8]`.

  #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

#. Else:

  a. Let :math:`{\mathit{vloadop\_{\scriptstyle 0}}}` be :math:`{{\mathit{vloadop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

  #. If :math:`{\mathit{vloadop\_{\scriptstyle 0}}}` is of the case :math:`\mathsf{shape}`, then:

    1) Let :math:`({M}{\mathsf{x}}{K}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vloadop\_{\scriptstyle 0}}}`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + M \cdot K / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

      a) Trap.

    #) Let :math:`{j^{K}}` be the result for which :math:`{({{\mathrm{bytes}}}_{{\mathsf{i}}{M}}({j^{K}}) = z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} + k \cdot M / 8 : M / 8])^{k<K}}`.

    #) If the type of :math:`N` for which :math:`N` :math:`=` :math:`M \cdot 2` is Jnn, then:

      a) Let :math:`{\mathsf{i}}{N}` be the result for which :math:`N` :math:`=` :math:`M \cdot 2`.

      #) Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{K}}^{{-1}}}}{({{{{{\mathrm{extend}}}_{M, N}^{{\mathit{sx}}}}}{(j)}^{K}})}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

  #. If :math:`{\mathit{vloadop\_{\scriptstyle 0}}}` is of the case :math:`\mathsf{splat}`, then:

    1) Let :math:`({N}{\mathsf{\_}}{\mathsf{splat}})` be :math:`{\mathit{vloadop\_{\scriptstyle 0}}}`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

      a) Trap.

    #) Let :math:`M` be :math:`128 / N`.

    #) If the type of :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`N` is Jnn, then:

      a) Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`N`.

      #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

      #) Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({j^{M}})}`.

      #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.

  #. If :math:`{\mathit{vloadop\_{\scriptstyle 0}}}` is of the case :math:`\mathsf{zero}`, then:

    1) Let :math:`({N}{\mathsf{\_}}{\mathsf{zero}})` be :math:`{\mathit{vloadop\_{\scriptstyle 0}}}`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

      a) Trap.

    #) Let :math:`j` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(j)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

    #) Let :math:`c` be :math:`{{{{\mathrm{extend}}}_{N, 128}^{\mathsf{u}}}}{(j)}`.

    #) Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`{\mathsf{v{\scriptstyle 128}}{.}\mathsf{load}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{ao}}~j`
.......................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c_1)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. Let :math:`M` be :math:`{|\mathsf{v{\scriptstyle 128}}|} / N`.

#. If the type of :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`N` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`N`.

  #. Let :math:`k` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(k)` :math:`=` :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8]`.

  #. Let :math:`c` be :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c_1){}[{}[j] = k])}`.

  #. Push the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` to the stack.


:math:`\mathsf{memory{.}size}~x`
................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{type}` is of the case :math:`\mathsf{page}`.

#. Let :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})` be :math:`z{.}\mathsf{mems}{}[x]{.}\mathsf{type}`.

#. Let :math:`n \cdot 64 \, {\mathrm{Ki}}` be :math:`{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`.

#. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` to the stack.


:math:`\mathsf{memory{.}fill}~x`
................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{numtype}}_0{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`n = 0`, then:

  a. Do nothing.

#. Else:

  a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` to the stack.

  #. Push the value :math:`{\mathit{val}}` to the stack.

  #. Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x)`.

  #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Push the value :math:`{\mathit{val}}` to the stack.

  #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{memory{.}fill}~x)`.


:math:`\mathsf{memory{.}copy}~x_1~x_2`
......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}'}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}'}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}_2` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}_1` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` from the stack.

#. If :math:`i_1 + n > {|z{.}\mathsf{mems}{}[x_1]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`i_2 + n > {|z{.}\mathsf{mems}{}[x_2]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`n = 0`, then:

  a. Do nothing.

#. Else:

  a. If :math:`i_1 \leq i_2`, then:

    1) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` to the stack.

    #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` to the stack.

    #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{(8, \mathsf{u})}~x_2)`.

    #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x_1)`.

    #) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1 + 1)` to the stack.

    #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2 + 1)` to the stack.

  #. Else:

    1) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1 + n - 1)` to the stack.

    #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2 + n - 1)` to the stack.

    #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{load}}{(8, \mathsf{u})}~x_2)`.

    #) Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x_1)`.

    #) Push the value :math:`({\mathit{at}}_1{.}\mathsf{const}~i_1)` to the stack.

    #) Push the value :math:`({\mathit{at}}_2{.}\mathsf{const}~i_2)` to the stack.

  #. Push the value :math:`({\mathit{at}'}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{memory{.}copy}~x_1~x_2)`.


:math:`\mathsf{memory{.}init}~x~y`
..................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + n > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`j + n > {|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. If :math:`n = 0`, then:

  a. Do nothing.

#. Else if :math:`j < {|z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}|}`, then:

  a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~z{.}\mathsf{datas}{}[y]{.}\mathsf{bytes}{}[j])` to the stack.

  #. Execute the instruction :math:`({\mathsf{i{\scriptstyle 32}}{.}\mathsf{store}}{8}~x)`.

  #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~i + 1)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~j + 1)` to the stack.

  #. Push the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n - 1)` to the stack.

  #. Execute the instruction :math:`(\mathsf{memory{.}init}~x~y)`.


:math:`\mathsf{throw}~x`
........................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`x < {|z{.}\mathsf{tags}|}`.

#. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{tags}{}[x]{.}\mathsf{type})` is of the case :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~{\mathit{functype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{tags}{}[x]{.}\mathsf{type})`.

#. Let :math:`{t^{n}}~\rightarrow~{\mathit{resulttype}}_1` be :math:`{\mathit{functype}}_0`.

#. Assert: Due to validation, :math:`{\mathit{resulttype}}_1 = \epsilon`.

#. Let :math:`a` be :math:`{|z{.}\mathsf{exns}|}`.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Let :math:`{\mathit{exn}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{tag}~z{.}\mathsf{tags}{}[x],\; \mathsf{fields}~{{\mathit{val}}^{n}} \}\end{array}`.

#. Perform :math:`z{}[{.}\mathsf{exns} \mathrel{{=}{\oplus}} {\mathit{exn}}]`.

#. Push the value :math:`(\mathsf{ref{.}exn}~a)` to the stack.

#. Execute the instruction :math:`\mathsf{throw\_ref}`.


:math:`\mathsf{struct{.}new}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{struct}`.

#. Let :math:`(\mathsf{struct}~{\mathit{structtype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

#. Let :math:`{({\mathsf{mut}^?}, {\mathit{zt}})^{n}}` be :math:`{\mathit{structtype}}_0`.

#. Let :math:`a` be :math:`{|z{.}\mathsf{structs}|}`.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Let :math:`{\mathit{si}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~z{.}\mathsf{types}{}[x],\; \mathsf{fields}~{{{\mathrm{pack}}}_{{\mathit{zt}}}({\mathit{val}})^{n}} \}\end{array}`.

#. Push the value :math:`(\mathsf{ref{.}struct}~a)` to the stack.

#. Perform :math:`z{}[{.}\mathsf{structs} \mathrel{{=}{\oplus}} {\mathit{si}}]`.


:math:`\mathsf{struct{.}set}~x~i`
.................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}struct}`, then:

  a. Let :math:`(\mathsf{ref{.}struct}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{struct}`.

  #. Let :math:`(\mathsf{struct}~{\mathit{structtype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

  #. Let :math:`{({\mathsf{mut}^?}, {\mathit{zt}})^\ast}` be :math:`{\mathit{structtype}}_0`.

  #. If :math:`i < {|{{\mathit{zt}}^\ast}|}`, then:

    1) Perform :math:`z{}[{.}\mathsf{structs}{}[a]{.}\mathsf{fields}{}[i] = {{\mathrm{pack}}}_{{{\mathit{zt}}^\ast}{}[i]}({\mathit{val}})]`.


:math:`\mathsf{array{.}new\_fixed}~x~n`
.......................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{array}`.

#. Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

#. Let :math:`({\mathsf{mut}^?}, {\mathit{zt}})` be :math:`{\mathit{arraytype}}_0`.

#. Let :math:`a` be :math:`{|z{.}\mathsf{arrays}|}`.

#. Assert: Due to validation, there are at least :math:`n` values on the top of the stack.

#. Pop the values :math:`{{\mathit{val}}^{n}}` from the stack.

#. Let :math:`{\mathit{ai}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~z{.}\mathsf{types}{}[x],\; \mathsf{fields}~{{{\mathrm{pack}}}_{{\mathit{zt}}}({\mathit{val}})^{n}} \}\end{array}`.

#. Push the value :math:`(\mathsf{ref{.}array}~a)` to the stack.

#. Perform :math:`z{}[{.}\mathsf{arrays} \mathrel{{=}{\oplus}} {\mathit{ai}}]`.


:math:`\mathsf{array{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`\mathsf{i{\scriptstyle 32}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~i)` from the stack.

#. Assert: Due to validation, an :ref:`instruction <syntax-instr>` is on the top of the stack.

#. Pop the value :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` from the stack.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Trap.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}array}`, then:

  a. Let :math:`(\mathsf{ref{.}array}~a)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`a < {|z{.}\mathsf{arrays}|}` and :math:`i \geq {|z{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}|}`, then:

    1) Trap.

  #. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{array}`.

  #. Let :math:`(\mathsf{array}~{\mathit{arraytype}}_0)` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

  #. Let :math:`({\mathsf{mut}^?}, {\mathit{zt}})` be :math:`{\mathit{arraytype}}_0`.

  #. Perform :math:`z{}[{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}{}[i] = {{\mathrm{pack}}}_{{\mathit{zt}}}({\mathit{val}})]`.


:math:`\mathsf{local{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{locals}{}[x] = {\mathit{val}}]`.


:math:`\mathsf{global{.}set}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value is on the top of the stack.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Perform :math:`z{}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = {\mathit{val}}]`.


:math:`\mathsf{table{.}set}~x`
..............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i \geq {|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|}`, then:

  a. Trap.

#. Perform :math:`z{}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = {\mathit{ref}}]`.


:math:`\mathsf{table{.}grow}~x`
...............................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Assert: Due to validation, a :ref:`reference value <syntax-ref>` is on the top of the stack.

#. Pop the value :math:`{\mathit{ref}}` from the stack.

#. Either:

  a. Let :math:`{\mathit{ti}}` be :math:`{\mathrm{growtable}}(z{.}\mathsf{tables}{}[x], n, {\mathit{ref}})`.

  #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~{|z{.}\mathsf{tables}{}[x]{.}\mathsf{refs}|})` to the stack.

  #. Perform :math:`z{}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`.

#. Or:

  a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{{|{\mathit{at}}|}}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{elem{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Perform :math:`z{}[{.}\mathsf{elems}{}[x]{.}\mathsf{refs} = \epsilon]`.


:math:`{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{store}}{{{\mathit{storeop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}~x~{\mathit{ao}}`
................................................................................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. Let :math:`{\mathit{nt}}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|{\mathit{nt}}|} / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}` and :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = {\mathit{nt}}` and :math:`{{\mathit{storeop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Trap.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = {\mathit{nt}}` and :math:`{{\mathit{storeop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathit{nt}}}(c)`.

  #. Perform :math:`z{}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|{\mathit{nt}}|} / 8] = {b^\ast}]`.

#. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

  #. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = {\mathsf{i}}{N}` and :math:`{{\mathit{storeop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

    1) Let :math:`n` be :math:`{{\mathit{storeop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

    #) If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + n / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

      a) Trap.

    #) Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{n}}({{\mathrm{wrap}}}_{{|{\mathsf{i}}{N}|}, n}(c))`.

    #) Perform :math:`z{}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : n / 8] = {b^\ast}]`.


:math:`\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}~x~{\mathit{ao}}`
.....................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + {|\mathsf{v{\scriptstyle 128}}|} / 8 > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{\mathsf{v{\scriptstyle 128}}}(c)`.

#. Perform :math:`z{}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : {|\mathsf{v{\scriptstyle 128}}|} / 8] = {b^\ast}]`.


:math:`{\mathsf{v{\scriptstyle 128}}{.}\mathsf{store}}{N}{\mathsf{\_}}{\mathsf{lane}}~x~{\mathit{ao}}~j`
........................................................................................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`vector type <syntax-vectype>` :math:`\mathsf{v{\scriptstyle 128}}` is on the top of the stack.

#. Pop the value :math:`(\mathsf{v{\scriptstyle 128}}{.}\mathsf{const}~c)` from the stack.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~i)` from the stack.

#. If :math:`i + {\mathit{ao}}{.}\mathsf{offset} + N > {|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|}`, then:

  a. Trap.

#. Let :math:`M` be :math:`128 / N`.

#. If the type of :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`N` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`N`.

  #. If :math:`j < {|{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c)|}`, then:

    1) Let :math:`{b^\ast}` be :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}({{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c){}[j])`.

    #) Perform :math:`z{}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i + {\mathit{ao}}{.}\mathsf{offset} : N / 8] = {b^\ast}]`.


:math:`\mathsf{memory{.}grow}~x`
................................


1. Let :math:`z` be the current state.

#. Assert: Due to validation, a value of :ref:`number type <syntax-numtype>` :math:`{\mathit{at}}` is on the top of the stack.

#. Pop the value :math:`({\mathit{at}}{.}\mathsf{const}~n)` from the stack.

#. Either:

  a. Let :math:`{\mathit{mi}}` be :math:`{\mathrm{growmem}}(z{.}\mathsf{mems}{}[x], n)`.

  #. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~{|z{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}|} / 64 \, {\mathrm{Ki}})` to the stack.

  #. Perform :math:`z{}[{.}\mathsf{mems}{}[x] = {\mathit{mi}}]`.

#. Or:

  a. Push the value :math:`({\mathit{at}}{.}\mathsf{const}~{{{{\mathrm{signed}}}_{{|{\mathit{at}}|}}^{{-1}}}}{({-1})})` to the stack.


:math:`\mathsf{data{.}drop}~x`
..............................


1. Let :math:`z` be the current state.

#. Perform :math:`z{}[{.}\mathsf{datas}{}[x]{.}\mathsf{bytes} = \epsilon]`.


:math:`{\mathrm{min}}(i, j)`
............................


1. If :math:`i \leq j`, then:

  a. Return :math:`i`.

#. Return :math:`j`.


:math:`{\Sigma}\, {n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`
...................................................................


1. If :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`0`.

#. Let :math:`n~{{n'}^\ast}` be :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`n + {\Sigma}\, {{n'}^\ast}`.


:math:`{\Pi}\, {n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`
................................................................


1. If :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`1`.

#. Let :math:`n~{{n'}^\ast}` be :math:`{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`n \cdot {\Pi}\, {{n'}^\ast}`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`
........................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} = 1`.

#. Let :math:`w` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`w`.


:math:`{\bigoplus}\, {X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`
......................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{w^\ast}~{{{w'}^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{w^\ast}~{\bigoplus}\, {{{w'}^\ast}^\ast}`.


:math:`{\bigoplus}\, {X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`
......................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{w^{n}}~{({{w'}^{n}})^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{w^{n}}~{\bigoplus}\, {({{w'}^{n}})^\ast}`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}~{\mathrm{disjoint}}`
............................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return true.

#. Let :math:`w~{{w'}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`w` is not contained in :math:`{{w'}^\ast}` and :math:`{{w'}^\ast}~{\mathrm{disjoint}}`.


:math:`{{\mathrm{setminus{\kern-0.1em\scriptstyle 1}}}}_{{\mathit{TODO}}}(w, {X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
...............................................................................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`w`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`w = w_1`, then:

  a. Return :math:`\epsilon`.

#. Return :math:`{{\mathrm{setminus{\kern-0.1em\scriptstyle 1}}}}_{{\mathit{TODO}}}(w, {{w'}^\ast})`.


:math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} \setminus {w^\ast}`
...........................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{{\mathrm{setminus{\kern-0.1em\scriptstyle 1}}}}_{{\mathit{TODO}}}(w_1, {w^\ast})~{{w'}^\ast} \setminus {w^\ast}`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{{\mathit{TODO}}}(w_1, {X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
...................................................................................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{{w'}^\ast}~{{w^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`w_1~{{w'}^\ast}~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{{\mathit{TODO}}}(w_1, {{w^\ast}^\ast})`.


:math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{{\mathit{TODO}}}({X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {{w^\ast}^\ast})`
...............................................................................................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`w_1~{{w'}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 2}}}}_{{\mathit{TODO}}}(w_1, {{w^\ast}^\ast})~{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{{\mathit{TODO}}}({{w'}^\ast}, {{w^\ast}^\ast})`.


:math:`\Large\times~{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`
.....................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{w_1^\ast}~{{w^\ast}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{{\mathrm{setproduct{\kern-0.1em\scriptstyle 1}}}}_{{\mathit{TODO}}}({w_1^\ast}, \Large\times~{{w^\ast}^\ast})`.


:math:`{\mathrm{signif}}(N_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
....................................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 32`, then:

  a. Return :math:`23`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 64`.

#. Return :math:`52`.


:math:`{\mathrm{expon}}(N_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
...................................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 32`, then:

  a. Return :math:`8`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 64`.

#. Return :math:`11`.


:math:`M`
.........


1. Return :math:`{\mathrm{signif}}(N)`.


:math:`E`
.........


1. Return :math:`{\mathrm{expon}}(N)`.


:math:`{+0}`
............


1. Return :math:`({+((0 + 0 \cdot {2^{{-M}}}) \cdot {2^{e}})})`.


:math:`{+1}`
............


1. Return :math:`({+((1 + 1 \cdot {2^{{-M}}}) \cdot {2^{0}})})`.


:math:`{{\mathrm{canon}}}_{N}`
..............................


1. Return :math:`{2^{{\mathrm{signif}}(N) - 1}}`.


:math:`{\mathrm{cont}}(b)`
..........................


1. Assert: Due to validation, :math:`128 < b`.

#. Assert: Due to validation, :math:`b < 192`.

#. Return :math:`b - 128`.


:math:`\mathsf{anyref}`
.......................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{any})`.


:math:`\mathsf{eqref}`
......................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{eq})`.


:math:`\mathsf{i{\scriptstyle 31}ref}`
......................................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{i{\scriptstyle 31}})`.


:math:`\mathsf{structref}`
..........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{struct})`.


:math:`\mathsf{arrayref}`
.........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{array})`.


:math:`\mathsf{funcref}`
........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{func})`.


:math:`\mathsf{externref}`
..........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{extern})`.


:math:`\mathsf{nullref}`
........................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{none})`.


:math:`\mathsf{nullfuncref}`
............................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{nofunc})`.


:math:`\mathsf{nullexternref}`
..............................


1. Return :math:`(\mathsf{ref}~\mathsf{null}~\mathsf{noextern})`.


:math:`{|{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}|}`
.................................................................


1. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 32}}`, then:

  a. Return :math:`32`.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 64}}`, then:

  a. Return :math:`64`.

#. If :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 32}}`, then:

  a. Return :math:`32`.

#. Assert: Due to validation, :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{f{\scriptstyle 64}}`.

#. Return :math:`64`.


:math:`{|\mathsf{v{\scriptstyle 128}}|}`
........................................


1. Return :math:`128`.


:math:`{|{\mathit{pt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}|}`
.................................................................


1. If :math:`{\mathit{pt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 8}}`, then:

  a. Return :math:`8`.

#. Assert: Due to validation, :math:`{\mathit{pt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{i{\scriptstyle 16}}`.

#. Return :math:`16`.


:math:`{|{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}|}`
.................................................................


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{|{\mathit{numtype}}|}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{|{\mathit{packtype}}|}`.


:math:`{|{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}|}`
.................................................................


1. If the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{|{\mathit{numtype}}|}`.

#. If the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is vector type, then:

  a. Let :math:`{\mathit{vectype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{|{\mathit{vectype}}|}`.

#. Assert: Due to validation, the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{|{\mathit{packtype}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{nt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{vt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{pt}}|}`.


:math:`N`
.........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_1`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`N_2`
...........


1. Return :math:`{|{\mathit{lt}}|}`.


:math:`{\mathrm{unpack}}({\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
................................................................................


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathit{numtype}}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Return :math:`\mathsf{i{\scriptstyle 32}}`.


:math:`{\mathrm{unpack}}({\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
................................................................................


1. If the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is value type, then:

  a. Let :math:`{\mathit{valtype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathit{valtype}}`.

#. Assert: Due to validation, the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Return :math:`\mathsf{i{\scriptstyle 32}}`.


:math:`{\mathrm{unpack}}({\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
................................................................................


1. If the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathit{numtype}}`.

#. If the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type, then:

  a. Return :math:`\mathsf{i{\scriptstyle 32}}`.


:math:`{\mathrm{unpack}}({\mathit{vectype}})`
.............................................


1. Return :math:`{\mathit{vectype}}`.


:math:`{\mathrm{unpack}}({\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
................................................................................


1. If the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is literal type, then:

  a. Let :math:`{\mathit{consttype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathit{consttype}}`.

#. If the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type, then:

  a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. If the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is lane type, then:

  a. Let :math:`{\mathit{lanetype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{unpack}}({\mathit{lanetype}})`.


:math:`{\mathrm{dim}}({{\mathsf{i}}{N}}{\mathsf{x}}{N})`
........................................................


1. Return :math:`N`.


:math:`{\mathrm{lanetype}}({{\mathsf{i}}{N}}{\mathsf{x}}{N})`
.............................................................


1. Return :math:`{\mathsf{i}}{N}`.


:math:`{\mathrm{unpack}}({{\mathsf{i}}{N}}{\mathsf{x}}{N})`
...........................................................


1. Return :math:`{\mathrm{unpack}}({\mathsf{i}}{N})`.


:math:`{\mathrm{funcs}}({{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
......................................................................................


1. If :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~x)` be :math:`{\mathit{externidx}}_0`.

  #. Return :math:`x~{\mathrm{funcs}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~x)` be :math:`{\mathit{externidx}}_0`.

  #. Return :math:`x~{\mathrm{globals}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................


1. If :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~x)` be :math:`{\mathit{externidx}}_0`.

  #. Return :math:`x~{\mathrm{tables}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~x)` be :math:`{\mathit{externidx}}_0`.

  #. Return :math:`x~{\mathrm{mems}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xx}}^\ast})`.


:math:`{\mathrm{tags}}({{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externidx}}_0~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externidx}}_0` is of the case :math:`\mathsf{tag}`, then:

  a. Let :math:`(\mathsf{tag}~x)` be :math:`{\mathit{externidx}}_0`.

  #. Return :math:`x~{\mathrm{tags}}({{\mathit{xx}}^\ast})`.

#. Let :math:`{\mathit{externidx}}~{{\mathit{xx}}^\ast}` be :math:`{{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tags}}({{\mathit{xx}}^\ast})`.


:math:`{\mathsf{i}}{N_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}`
...............................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 32`, then:

  a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 64`.

#. Return :math:`\mathsf{i{\scriptstyle 64}}`.


:math:`{\mathsf{f}}{N_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}`
...............................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 32`, then:

  a. Return :math:`\mathsf{f{\scriptstyle 32}}`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 64`.

#. Return :math:`\mathsf{f{\scriptstyle 64}}`.


:math:`{\mathsf{i}}{N_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}`
...............................................................


1. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 8`, then:

  a. Return :math:`\mathsf{i{\scriptstyle 8}}`.

#. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 16`, then:

  a. Return :math:`\mathsf{i{\scriptstyle 16}}`.

#. If :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 32`, then:

  a. Return :math:`\mathsf{i{\scriptstyle 32}}`.

#. Assert: Due to validation, :math:`N_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = 64`.

#. Return :math:`\mathsf{i{\scriptstyle 64}}`.


:math:`{\mathrm{min}}({\mathit{at}}_1, {\mathit{at}}_2)`
........................................................


1. If :math:`{|{\mathit{at}}_1|} \leq {|{\mathit{at}}_2|}`, then:

  a. Return :math:`{\mathit{at}}_1`.

#. Return :math:`{\mathit{at}}_2`.


:math:`(\mathsf{ref}~{\mathsf{null}}{{{}_{1}^?}}~{\mathit{ht}}_1) \setminus (\mathsf{ref}~{{\mathsf{null}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}~{\mathit{ht}}_2)`
.......................................................................................................................................................................


1. If :math:`{{\mathsf{null}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{null}`, then:

  a. Return :math:`(\mathsf{ref}~\epsilon~{\mathit{ht}}_1)`.

#. Assert: Due to validation, :math:`{{\mathsf{null}^?}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is not defined.

#. Return :math:`(\mathsf{ref}~{\mathsf{null}}{{{}_{1}^?}}~{\mathit{ht}}_1)`.


:math:`{\mathrm{funcs}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
......................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{dt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{dt}}~{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{gt}}~{\mathrm{globals}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{tt}}~{\mathrm{tables}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{mt}}~{\mathrm{mems}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xt}}^\ast})`.


:math:`{\mathrm{tags}}({{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externtype}}_0~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externtype}}_0` is of the case :math:`\mathsf{tag}`, then:

  a. Let :math:`(\mathsf{tag}~{\mathit{jt}})` be :math:`{\mathit{externtype}}_0`.

  #. Return :math:`{\mathit{jt}}~{\mathrm{tags}}({{\mathit{xt}}^\ast})`.

#. Let :math:`{\mathit{externtype}}~{{\mathit{xt}}^\ast}` be :math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tags}}({{\mathit{xt}}^\ast})`.


:math:`{{\mathit{tv}}}{{}[ {{\mathit{tv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} := {y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} ]}`
...............................................................................................................................................


1. If :math:`{{\mathit{tv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon` and :math:`{y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`{\mathit{tv}}`.

#. Assert: Due to validation, :math:`{|{y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{tu}}_1~{{\mathit{tu}'}^\ast}` be :math:`{y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{tv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{tv}}_1~{{\mathit{tv}'}^\ast}` be :math:`{{\mathit{tv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{tv}} = {\mathit{tv}}_1`, then:

  a. Return :math:`{\mathit{tu}}_1`.

#. Return :math:`{{\mathit{tv}}}{{}[ {{\mathit{tv}'}^\ast} := {{\mathit{tu}'}^\ast} ]}`.


:math:`{{\mathit{pt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{\mathit{pt}}`.


:math:`{{\mathit{nt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{\mathit{nt}}`.


:math:`{{\mathit{vt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{\mathit{vt}}`.


:math:`{y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.......................................................................................................


1. If the type of :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is type variable, then:

  a. Let :math:`{\mathit{tv}'}` be :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathit{tv}'}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Assert: Due to validation, the type of :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is defined type.

#. Let :math:`{\mathit{dt}}` be :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{\mathit{dt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.


:math:`{{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...................................................................................................................


1. If the type of :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is type variable, then:

  a. Let :math:`{\mathit{tv}'}` be :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathit{tv}'}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. If the type of :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is defined type, then:

  a. Let :math:`{\mathit{dt}}` be :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathit{dt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Let :math:`{\mathit{ht}}` be :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathit{ht}}`.


:math:`{(\mathsf{ref}~{\mathsf{null}^?}~{\mathit{ht}})}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
............................................................................................................


1. Return :math:`(\mathsf{ref}~{\mathsf{null}^?}~{{\mathit{ht}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.......................................................................................................


1. If the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

  a. Let :math:`{\mathit{nt}}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathit{nt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. If the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is vector type, then:

  a. Let :math:`{\mathit{vt}}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathit{vt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. If the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is reference type, then:

  a. Let :math:`{\mathit{rt}}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{\mathit{rt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Assert: Due to validation, :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{bot}`.

#. Return :math:`\mathsf{bot}`.


:math:`{{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...................................................................................................................


1. If the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is value type, then:

  a. Let :math:`t` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{t}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.

#. Assert: Due to validation, the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{pt}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{\mathit{pt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.


:math:`{({\mathsf{mut}^?}, {\mathit{zt}})}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...............................................................................................


1. Return :math:`({\mathsf{mut}^?}, {{\mathit{zt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...................................................................................................................


1. If :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{struct}`, then:

  a. Let :math:`(\mathsf{struct}~{{\mathit{yt}}^\ast})` be :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`(\mathsf{struct}~{{{\mathit{yt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast})`.

#. If :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{array}`, then:

  a. Let :math:`(\mathsf{array}~{\mathit{yt}})` be :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`(\mathsf{array}~{{\mathit{yt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. Assert: Due to validation, :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~{\mathit{ft}})` be :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`(\mathsf{func}~{{\mathit{ft}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{tu}'}^\ast}~{\mathit{ct}})}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...................................................................................................................................


1. Return :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{{\mathit{tu}'}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}~{{\mathit{ct}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{(\mathsf{rec}~{{\mathit{st}}^\ast})}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.................................................................................................


1. Return :math:`(\mathsf{rec}~{{{\mathit{st}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast})`.


:math:`{({\mathit{qt}} {.} i)}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...................................................................................


1. Return :math:`({{\mathit{qt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]} {.} i)`.


:math:`{{t_1^\ast}~\rightarrow~{t_2^\ast}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...............................................................................................


1. Return :math:`{{t_1}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}~\rightarrow~{{t_2}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}`.


:math:`{{\mathit{at}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{\mathit{at}}`.


:math:`{({\mathsf{mut}^?}, t)}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...................................................................................


1. Return :math:`({\mathsf{mut}^?}, {t}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{({\mathit{at}}, {\mathit{lim}}, {\mathit{rt}})}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
............................................................................................................


1. Return :math:`({\mathit{at}}, {\mathit{lim}}, {{\mathit{rt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{({\mathit{at}}~{\mathit{lim}}~\mathsf{page})}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
..........................................................................................................


1. Return :math:`({\mathit{at}}~{\mathit{lim}}~\mathsf{page})`.


:math:`{{\mathit{dt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...........................................................................


1. Return :math:`{{\mathit{dt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`.


:math:`{{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
...................................................................................................................


1. If :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{dt}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`(\mathsf{func}~{{\mathit{dt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. If :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{gt}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`(\mathsf{global}~{{\mathit{gt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. If :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{tt}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`(\mathsf{table}~{{\mathit{tt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. If :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~{\mathit{mt}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`(\mathsf{mem}~{{\mathit{mt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.

#. Assert: Due to validation, :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{tag}`.

#. Let :math:`(\mathsf{tag}~{\mathit{jt}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`(\mathsf{tag}~{{\mathit{jt}}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]})`.


:math:`{{{\mathit{xt}}_1^\ast}~\rightarrow~{{\mathit{xt}}_2^\ast}}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}`
.......................................................................................................................


1. Return :math:`{{{\mathit{xt}}_1}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}~\rightarrow~{{{\mathit{xt}}_2}{{}[ {{\mathit{tv}}^\ast} := {{\mathit{tu}}^\ast} ]}^\ast}`.


:math:`{t}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.............................................


1. Return :math:`{t}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{rt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{rt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{dt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{dt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{gt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{gt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{tt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{tt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{mt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
.........................................................


1. Return :math:`{{\mathit{mt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{\mathit{mmt}}}{{}[ {:=}\, {{\mathit{tu}}^{n}} ]}`
..........................................................


1. Return :math:`{{\mathit{mmt}}}{{}[ {i^{i<n}} := {{\mathit{tu}}^{n}} ]}`.


:math:`{{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}}{{}[ {:=}\, {{\mathit{tu}}^\ast} ]}`
.........................................................................................................


1. If :math:`{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{dt}}_1~{{\mathit{dt}}^\ast}` be :math:`{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{{\mathit{dt}}_1}{{}[ {:=}\, {{\mathit{tu}}^\ast} ]}~{{{\mathit{dt}}^\ast}}{{}[ {:=}\, {{\mathit{tu}}^\ast} ]}`.


:math:`{{\mathrm{roll}}}_{x}({\mathit{rectype}})`
.................................................


1. Assert: Due to validation, :math:`{\mathit{rectype}}` is of the case :math:`\mathsf{rec}`.

#. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})` be :math:`{\mathit{rectype}}`.

#. Return :math:`(\mathsf{rec}~{{{\mathit{subtype}}}{{}[ {x + i^{i<n}} := {(\mathsf{rec}~i)^{i<n}} ]}^{n}})`.


:math:`{\mathrm{unroll}}({\mathit{rectype}})`
.............................................


1. Assert: Due to validation, :math:`{\mathit{rectype}}` is of the case :math:`\mathsf{rec}`.

#. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})` be :math:`{\mathit{rectype}}`.

#. Return :math:`(\mathsf{rec}~{{{\mathit{subtype}}}{{}[ {(\mathsf{rec}~i)^{i<n}} := {({\mathit{rectype}} {.} i)^{i<n}} ]}^{n}})`.


:math:`{{{{\mathrm{roll}}}_{x}^\ast}}{({\mathit{rectype}})}`
............................................................


1. Assert: Due to validation, :math:`{{\mathrm{roll}}}_{x}({\mathit{rectype}})` is of the case :math:`\mathsf{rec}`.

#. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^{n}})` be :math:`{{\mathrm{roll}}}_{x}({\mathit{rectype}})`.

#. Return :math:`{((\mathsf{rec}~{{\mathit{subtype}}^{n}}) {.} i)^{i<n}}`.


:math:`{\mathrm{unroll}}(({\mathit{rectype}} {.} i))`
.....................................................


1. Assert: Due to validation, :math:`{\mathrm{unroll}}({\mathit{rectype}})` is of the case :math:`\mathsf{rec}`.

#. Let :math:`(\mathsf{rec}~{{\mathit{subtype}}^\ast})` be :math:`{\mathrm{unroll}}({\mathit{rectype}})`.

#. Return :math:`{{\mathit{subtype}}^\ast}{}[i]`.


:math:`{\mathrm{expand}}({\mathit{deftype}})`
.............................................


1. Assert: Due to validation, :math:`{\mathrm{unroll}}({\mathit{deftype}})` is of the case :math:`\mathsf{sub}`.

#. Let :math:`(\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{comptype}})` be :math:`{\mathrm{unroll}}({\mathit{deftype}})`.

#. Return :math:`{\mathit{comptype}}`.






1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{align}~0,\; \mathsf{offset}~0 \}\end{array}`.


:math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}{.}\mathsf{const}~c`
.......................................................................................


1. If the type of :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`({\mathit{numtype}}{.}\mathsf{const}~c)`.

#. Assert: Due to validation, the type of :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is vector type.

#. Let :math:`{\mathit{vectype}}` be :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`({\mathit{vectype}}{.}\mathsf{const}~c)`.


:math:`{\mathrm{free}}_{\mathit{opt}}({{\mathit{free}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?})`
...................................................................................................


1. If :math:`{{\mathit{free}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. Let :math:`{\mathit{free}}` be :math:`{{\mathit{free}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

#. Return :math:`{\mathit{free}}`.


:math:`{\mathrm{free}}_{\mathit{list}}({{\mathit{free}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................................


1. If :math:`{{\mathit{free}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. Let :math:`{\mathit{free}}~{{\mathit{free}'}^\ast}` be :math:`{{\mathit{free}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return `free ++ $free_list(free'*{free' <- free'*})`.


:math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{\mathit{typeidx}},\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~{\mathit{funcidx}},\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`
..................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~{\mathit{globalidx}},\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`
................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~{\mathit{tableidx}},\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`
............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~{\mathit{memidx}},\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{elemidx}}({\mathit{elemidx}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~{\mathit{elemidx}},\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{dataidx}}({\mathit{dataidx}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~{\mathit{dataidx}},\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`
................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~{\mathit{localidx}},\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`
................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~{\mathit{labelidx}} \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{externidx}}({\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
...................................................................................................


1. If :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{funcidx}})` be :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{globalidx}})` be :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`.

#. If :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{tableidx}})` be :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. Assert: Due to validation, :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{mem}`.

#. Let :math:`(\mathsf{mem}~{\mathit{memidx}})` be :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.


:math:`{\mathrm{free}}_{\mathit{addrtype}}({\mathit{addrtype}})`
................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{packtype}}({\mathit{packtype}})`
................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{lanetype}}({\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
..................................................................................................


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{packtype}}({\mathit{packtype}})`.


:math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`
..............................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{consttype}}({\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
..........................................................................................................


1. If the type of :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. Assert: Due to validation, the type of :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is vector type.

#. Let :math:`{\mathit{vectype}}` be :math:`{\mathit{consttype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.


:math:`{\mathrm{free}}_{\mathit{absheaptype}}({\mathit{absheaptype}})`
......................................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{typevar}}({\mathit{tv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
.................................................................................................


1. If :math:`{\mathit{tv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case , then:

  a. Let :math:`{\mathit{typeidx}}` be :math:`{\mathit{tv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. Assert: Due to validation, :math:`{\mathit{tv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{rec}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{heaptype}}({\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
..................................................................................................


1. If the type of :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is abstract heap type, then:

  a. Let :math:`{\mathit{absheaptype}}` be :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{absheaptype}}({\mathit{absheaptype}})`.

#. Assert: Due to validation, the type of :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is type use.

#. Let :math:`{\mathit{typeuse}}` be :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`.


:math:`{\mathrm{free}}_{\mathit{reftype}}((\mathsf{ref}~{\mathsf{null}^?}~{\mathit{heaptype}}))`
................................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{heaptype}}({\mathit{heaptype}})`.


:math:`{\mathrm{free}}_{\mathit{typeuse}}(y_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
.....................................................................................


1. If the type of :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is type variable, then:

  a. Let :math:`{\mathit{typevar}}` be :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typevar}}({\mathit{typevar}})`.

#. Assert: Due to validation, the type of :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is defined type.

#. Let :math:`{\mathit{deftype}}` be :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{deftype}}({\mathit{deftype}})`.


:math:`{\mathrm{free}}_{\mathit{valtype}}(t_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
.....................................................................................


1. If the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

  a. Let :math:`{\mathit{numtype}}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is vector type, then:

  a. Let :math:`{\mathit{vectype}}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is reference type, then:

  a. Let :math:`{\mathit{reftype}}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{reftype}})`.

#. Assert: Due to validation, :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{bot}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{resulttype}}({{\mathit{valtype}}^\ast})`
........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})^\ast})`.


:math:`{\mathrm{free}}_{\mathit{storagetype}}({\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
.....................................................................................................


1. If the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is value type, then:

  a. Let :math:`{\mathit{valtype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})`.

#. Assert: Due to validation, the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{packtype}}({\mathit{packtype}})`.


:math:`{\mathrm{free}}_{\mathit{fieldtype}}(({\mathsf{mut}^?}, {\mathit{storagetype}}))`
........................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{storagetype}}({\mathit{storagetype}})`.


:math:`{\mathrm{free}}_{\mathit{structtype}}({{\mathit{fieldtype}}^\ast})`
..........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{fieldtype}}({\mathit{fieldtype}})^\ast})`.


:math:`{\mathrm{free}}_{\mathit{arraytype}}({\mathit{fieldtype}})`
..................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{fieldtype}}({\mathit{fieldtype}})`.


:math:`{\mathrm{free}}_{\mathit{functype}}({\mathit{resulttype}}_1~\rightarrow~{\mathit{resulttype}}_2)`
........................................................................................................


1. Return `$free_resulttype(resulttype_1) ++ $free_resulttype(resulttype_2)`.


:math:`{\mathrm{free}}_{\mathit{comptype}}({\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
..................................................................................................


1. If :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{struct}`, then:

  a. Let :math:`(\mathsf{struct}~{\mathit{structtype}})` be :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{structtype}}({\mathit{structtype}})`.

#. If :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{array}`, then:

  a. Let :math:`(\mathsf{array}~{\mathit{arraytype}})` be :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{arraytype}}({\mathit{arraytype}})`.

#. Assert: Due to validation, :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~{\mathit{functype}})` be :math:`{\mathit{ct}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{functype}}({\mathit{functype}})`.


:math:`{\mathrm{free}}_{\mathit{subtype}}((\mathsf{sub}~{\mathsf{final}^?}~{{\mathit{typeuse}}^\ast}~{\mathit{comptype}}))`
...........................................................................................................................


1. Return `$free_list($free_typeuse(typeuse)*{typeuse <- typeuse*}) ++ $free_comptype(comptype)`.


:math:`{\mathrm{free}}_{\mathit{rectype}}((\mathsf{rec}~{{\mathit{subtype}}^\ast}))`
....................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{subtype}}({\mathit{subtype}})^\ast})`.


:math:`{\mathrm{free}}_{\mathit{deftype}}(({\mathit{rectype}} {.} n))`
......................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{rectype}}({\mathit{rectype}})`.


:math:`{\mathrm{free}}_{\mathit{globaltype}}(({\mathsf{mut}^?}, {\mathit{valtype}}))`
.....................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})`.


:math:`{\mathrm{free}}_{\mathit{tabletype}}(({\mathit{addrtype}}, {\mathit{limits}}, {\mathit{reftype}}))`
..........................................................................................................


1. Return `$free_addrtype(addrtype) ++ $free_reftype(reftype)`.


:math:`{\mathrm{free}}_{\mathit{memtype}}(({\mathit{addrtype}}~{\mathit{limits}}~\mathsf{page}))`
.................................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{addrtype}}({\mathit{addrtype}})`.


:math:`{\mathrm{free}}_{\mathit{tagtype}}({\mathit{deftype}})`
..............................................................


1. Return :math:`{\mathrm{free}}_{\mathit{deftype}}({\mathit{deftype}})`.


:math:`{\mathrm{free}}_{\mathit{elemtype}}({\mathit{reftype}})`
...............................................................


1. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{reftype}})`.


:math:`{\mathrm{free}}_{\mathit{datatype}}(\mathsf{ok})`
........................................................


1. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{externtype}}({\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
....................................................................................................


1. If :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~{\mathit{typeuse}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`.

#. If :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~{\mathit{globaltype}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{globaltype}}({\mathit{globaltype}})`.

#. If :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~{\mathit{tabletype}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{tabletype}}({\mathit{tabletype}})`.

#. If :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~{\mathit{memtype}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{memtype}}({\mathit{memtype}})`.

#. Assert: Due to validation, :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{tag}`.

#. Let :math:`(\mathsf{tag}~{\mathit{tagtype}})` be :math:`{\mathit{xt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{tagtype}}({\mathit{tagtype}})`.


:math:`{\mathrm{free}}_{\mathit{moduletype}}({{\mathit{externtype}}_1^\ast}~\rightarrow~{{\mathit{externtype}}_2^\ast})`
........................................................................................................................


1. Return `$free_list($free_externtype(externtype_1)*{externtype_1 <- externtype_1*}) ++ $free_list($free_externtype(externtype_2)*{externtype_2 <- externtype_2*})`.


:math:`{\mathrm{free}}_{\mathit{shape}}({{\mathit{lanetype}}}{\mathsf{x}}{{\mathit{dim}}})`
...........................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{lanetype}}({\mathit{lanetype}})`.


:math:`{\mathrm{free}}_{\mathit{blocktype}}({\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
...................................................................................................


1. If :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case , then:

  a. Let :math:`{{\mathit{valtype}}^?}` be :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{opt}}({{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})^?})`.

#. Assert: Due to validation, :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case .

#. Let :math:`{\mathit{funcidx}}` be :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.


:math:`{\mathrm{shift}}_{\mathit{labelidxs}}({l_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
...............................................................................................


1. If :math:`{l_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{labelidx}}_0~{{\mathit{labelidx}'}^\ast}` be :math:`{l_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{labelidx}}_0 = 0`, then:

  a. Return :math:`{\mathrm{shift}}_{\mathit{labelidxs}}({{\mathit{labelidx}'}^\ast})`.

#. Let :math:`{\mathit{labelidx}}~{{\mathit{labelidx}'}^\ast}` be :math:`{l_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathit{labelidx}} - 1~{\mathrm{shift}}_{\mathit{labelidxs}}({{\mathit{labelidx}'}^\ast})`.


:math:`{\mathrm{free}}_{\mathit{instr}}({\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
..................................................................................................


1. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{nop}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{unreachable}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{drop}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{select}`, then:

  a. Let :math:`(\mathsf{select}~{({{\mathit{valtype}}^\ast})^?})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{opt}}({{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{valtype}}({\mathit{valtype}})^\ast})^?})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{block}`, then:

  a. Let :math:`(\mathsf{block}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_blocktype(blocktype) ++ $free_block(instr*{instr <- instr*})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{loop}`, then:

  a. Let :math:`(\mathsf{loop}~{\mathit{blocktype}}~{{\mathit{instr}}^\ast})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_blocktype(blocktype) ++ $free_block(instr*{instr <- instr*})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{if}`, then:

  a. Let :math:`(\mathsf{if}~{\mathit{blocktype}}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_blocktype(blocktype) ++ $free_block(instr_1*{instr_1 <- instr_1*}) ++ $free_block(instr_2*{instr_2 <- instr_2*})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{br}`, then:

  a. Let :math:`(\mathsf{br}~{\mathit{labelidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{br\_if}`, then:

  a. Let :math:`(\mathsf{br\_if}~{\mathit{labelidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{br\_table}`, then:

  a. Let :math:`(\mathsf{br\_table}~{{\mathit{labelidx}}^\ast}~{\mathit{labelidx}'})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_list($free_labelidx(labelidx)*{}) ++ $free_labelidx(labelidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{br\_on\_null}`, then:

  a. Let :math:`(\mathsf{br\_on\_null}~{\mathit{labelidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{br\_on\_non\_null}`, then:

  a. Let :math:`(\mathsf{br\_on\_non\_null}~{\mathit{labelidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{labelidx}}({\mathit{labelidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{br\_on\_cast}`, then:

  a. Let :math:`(\mathsf{br\_on\_cast}~{\mathit{labelidx}}~{\mathit{reftype}}_1~{\mathit{reftype}}_2)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{br\_on\_cast\_fail}`, then:

  a. Let :math:`(\mathsf{br\_on\_cast\_fail}~{\mathit{labelidx}}~{\mathit{reftype}}_1~{\mathit{reftype}}_2)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{call}`, then:

  a. Let :math:`(\mathsf{call}~{\mathit{funcidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{call\_ref}`, then:

  a. Let :math:`(\mathsf{call\_ref}~{\mathit{typeuse}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{call\_indirect}`, then:

  a. Let :math:`(\mathsf{call\_indirect}~{\mathit{tableidx}}~{\mathit{typeuse}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_tableidx(tableidx) ++ $free_typeuse(typeuse)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{return}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{return\_call}`, then:

  a. Let :math:`(\mathsf{return\_call}~{\mathit{funcidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{return\_call\_ref}`, then:

  a. Let :math:`(\mathsf{return\_call\_ref}~{\mathit{typeuse}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeuse}}({\mathit{typeuse}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{return\_call\_indirect}`, then:

  a. Let :math:`(\mathsf{return\_call\_indirect}~{\mathit{tableidx}}~{\mathit{typeuse}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_tableidx(tableidx) ++ $free_typeuse(typeuse)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{const}`, then:

  a. Let :math:`({\mathit{numtype}}{.}\mathsf{const}~{\mathit{numlit}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{unop}`, then:

  a. Let :math:`({\mathit{numtype}} {.} {\mathit{unop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{binop}`, then:

  a. Let :math:`({\mathit{numtype}} {.} {\mathit{binop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{testop}`, then:

  a. Let :math:`({\mathit{numtype}} {.} {\mathit{testop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{relop}`, then:

  a. Let :math:`({\mathit{numtype}} {.} {\mathit{relop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{numtype}}({\mathit{numtype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{cvtop}`, then:

  a. Let :math:`({\mathit{numtype}}_1 {.} {{\mathit{cvtop}}}{\mathsf{\_}}{{\mathit{numtype}}_2})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_numtype(numtype_1) ++ $free_numtype(numtype_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vconst}`, then:

  a. Let :math:`({\mathit{vectype}}{.}\mathsf{const}~{\mathit{veclit}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vvunop}`, then:

  a. Let :math:`({\mathit{vectype}} {.} {\mathit{vvunop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vvbinop}`, then:

  a. Let :math:`({\mathit{vectype}} {.} {\mathit{vvbinop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vvternop}`, then:

  a. Let :math:`({\mathit{vectype}} {.} {\mathit{vvternop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vvtestop}`, then:

  a. Let :math:`({\mathit{vectype}} {.} {\mathit{vvtestop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{vectype}}({\mathit{vectype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vunop}`, then:

  a. Let :math:`({\mathit{shape}} {.} {\mathit{vunop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vbinop}`, then:

  a. Let :math:`({\mathit{shape}} {.} {\mathit{vbinop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vternop}`, then:

  a. Let :math:`({\mathit{shape}} {.} {\mathit{vternop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vtestop}`, then:

  a. Let :math:`({\mathit{shape}} {.} {\mathit{vtestop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vrelop}`, then:

  a. Let :math:`({\mathit{shape}} {.} {\mathit{vrelop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vshiftop}`, then:

  a. Let :math:`({\mathit{ishape}} {.} {\mathit{vshiftop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{ishape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vbitmask}`, then:

  a. Let :math:`({\mathit{ishape}}{.}\mathsf{bitmask})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{ishape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vswizzlop}`, then:

  a. Let :math:`({\mathit{bshape}} {.} {\mathit{vswizzlop}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{bshape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vshuffle}`, then:

  a. Let :math:`({\mathit{bshape}}{.}\mathsf{shuffle}~{{\mathit{laneidx}}^\ast})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{bshape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vextunop}`, then:

  a. Let :math:`({\mathit{ishape}}_1 {.} {{\mathit{vextunop}}}{\mathsf{\_}}{{\mathit{ishape}}_2})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_shape(ishape_1) ++ $free_shape(ishape_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vextbinop}`, then:

  a. Let :math:`({\mathit{ishape}}_1 {.} {{\mathit{vextbinop}}}{\mathsf{\_}}{{\mathit{ishape}}_2})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_shape(ishape_1) ++ $free_shape(ishape_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vnarrow}`, then:

  a. Let :math:`({{\mathit{ishape}}_1{.}\mathsf{narrow}}{\mathsf{\_}}{{\mathit{ishape}}_2}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_shape(ishape_1) ++ $free_shape(ishape_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vcvtop}`, then:

  a. Let :math:`({\mathit{shape}}_1 {.} {{\mathit{vcvtop}}}{\mathsf{\_}}{{{\mathit{zero}}^?}}{\mathsf{\_}}{{\mathit{shape}}_2}{\mathsf{\_}}{{{\mathit{half}}^?}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_shape(shape_1) ++ $free_shape(shape_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vsplat}`, then:

  a. Let :math:`({\mathit{shape}}{.}\mathsf{splat})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vextract\_lane}`, then:

  a. Let :math:`({{\mathit{shape}}{.}\mathsf{extract\_lane}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~{\mathit{laneidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vreplace\_lane}`, then:

  a. Let :math:`({\mathit{shape}}{.}\mathsf{replace\_lane}~{\mathit{laneidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{shape}}({\mathit{shape}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}null}`, then:

  a. Let :math:`(\mathsf{ref{.}null}~{\mathit{heaptype}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{heaptype}}({\mathit{heaptype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ref{.}is\_null}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ref{.}as\_non\_null}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ref{.}eq}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}test}`, then:

  a. Let :math:`(\mathsf{ref{.}test}~{\mathit{reftype}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{reftype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}cast}`, then:

  a. Let :math:`(\mathsf{ref{.}cast}~{\mathit{reftype}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{reftype}}({\mathit{reftype}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref{.}func}`, then:

  a. Let :math:`(\mathsf{ref{.}func}~{\mathit{funcidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ref{.}i{\scriptstyle 31}}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{i{\scriptstyle 31}{.}get}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{struct{.}new}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{struct{.}new\_default}`, then:

  a. Let :math:`(\mathsf{struct{.}new\_default}~{\mathit{typeidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{struct{.}get}`, then:

  a. Let :math:`({\mathsf{struct{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~{\mathit{typeidx}}~{\mathit{u{\kern-0.1em\scriptstyle 32}}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{struct{.}set}`, then:

  a. Let :math:`(\mathsf{struct{.}set}~{\mathit{typeidx}}~{\mathit{u{\kern-0.1em\scriptstyle 32}}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{array{.}new}`, then:

  a. Let :math:`(\mathsf{array{.}new}~{\mathit{typeidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{array{.}new\_default}`, then:

  a. Let :math:`(\mathsf{array{.}new\_default}~{\mathit{typeidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{array{.}new\_fixed}`, then:

  a. Let :math:`(\mathsf{array{.}new\_fixed}~{\mathit{typeidx}}~{\mathit{u{\kern-0.1em\scriptstyle 32}}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{array{.}new\_data}`, then:

  a. Let :math:`(\mathsf{array{.}new\_data}~{\mathit{typeidx}}~{\mathit{dataidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_typeidx(typeidx) ++ $free_dataidx(dataidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{array{.}new\_elem}`, then:

  a. Let :math:`(\mathsf{array{.}new\_elem}~{\mathit{typeidx}}~{\mathit{elemidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_typeidx(typeidx) ++ $free_elemidx(elemidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{array{.}get}`, then:

  a. Let :math:`({\mathsf{array{.}get}}{\mathsf{\_}}{{{\mathit{sx}}^?}}~{\mathit{typeidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{array{.}set}`, then:

  a. Let :math:`(\mathsf{array{.}set}~{\mathit{typeidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{array{.}len}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{array{.}fill}`, then:

  a. Let :math:`(\mathsf{array{.}fill}~{\mathit{typeidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{array{.}copy}`, then:

  a. Let :math:`(\mathsf{array{.}copy}~{\mathit{typeidx}}_1~{\mathit{typeidx}}_2)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_typeidx(typeidx_1) ++ $free_typeidx(typeidx_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{array{.}init\_data}`, then:

  a. Let :math:`(\mathsf{array{.}init\_data}~{\mathit{typeidx}}~{\mathit{dataidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_typeidx(typeidx) ++ $free_dataidx(dataidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{array{.}init\_elem}`, then:

  a. Let :math:`(\mathsf{array{.}init\_elem}~{\mathit{typeidx}}~{\mathit{elemidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_typeidx(typeidx) ++ $free_elemidx(elemidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{extern{.}convert\_any}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{any{.}convert\_extern}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{local{.}get}`, then:

  a. Let :math:`(\mathsf{local{.}get}~{\mathit{localidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{local{.}set}`, then:

  a. Let :math:`(\mathsf{local{.}set}~{\mathit{localidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{local{.}tee}`, then:

  a. Let :math:`(\mathsf{local{.}tee}~{\mathit{localidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{localidx}}({\mathit{localidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{global{.}get}`, then:

  a. Let :math:`(\mathsf{global{.}get}~{\mathit{globalidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{global{.}set}`, then:

  a. Let :math:`(\mathsf{global{.}set}~{\mathit{globalidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{globalidx}}({\mathit{globalidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{table{.}get}`, then:

  a. Let :math:`(\mathsf{table{.}get}~{\mathit{tableidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{table{.}set}`, then:

  a. Let :math:`(\mathsf{table{.}set}~{\mathit{tableidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{table{.}size}`, then:

  a. Let :math:`(\mathsf{table{.}size}~{\mathit{tableidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{table{.}grow}`, then:

  a. Let :math:`(\mathsf{table{.}grow}~{\mathit{tableidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{table{.}fill}`, then:

  a. Let :math:`(\mathsf{table{.}fill}~{\mathit{tableidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{tableidx}}({\mathit{tableidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{table{.}copy}`, then:

  a. Let :math:`(\mathsf{table{.}copy}~{\mathit{tableidx}}_1~{\mathit{tableidx}}_2)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_tableidx(tableidx_1) ++ $free_tableidx(tableidx_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{table{.}init}`, then:

  a. Let :math:`(\mathsf{table{.}init}~{\mathit{tableidx}}~{\mathit{elemidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_tableidx(tableidx) ++ $free_elemidx(elemidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{elem{.}drop}`, then:

  a. Let :math:`(\mathsf{elem{.}drop}~{\mathit{elemidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{elemidx}}({\mathit{elemidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{load}`, then:

  a. Let :math:`({{\mathit{numtype}}{.}\mathsf{load}}{{{\mathit{loadop}}^?}}~{\mathit{memidx}}~{\mathit{memarg}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_numtype(numtype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{store}`, then:

  a. Let :math:`({{\mathit{numtype}}{.}\mathsf{store}}{{{\mathit{storeop}}^?}}~{\mathit{memidx}}~{\mathit{memarg}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_numtype(numtype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vload}`, then:

  a. Let :math:`({{\mathit{vectype}}{.}\mathsf{load}}{{{\mathit{vloadop}}^?}}~{\mathit{memidx}}~{\mathit{memarg}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vload\_lane}`, then:

  a. Let :math:`({{\mathit{vectype}}{.}\mathsf{load}}{{\mathit{sz}}}{\mathsf{\_}}{\mathsf{lane}}~{\mathit{memidx}}~{\mathit{memarg}}~{\mathit{laneidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vstore}`, then:

  a. Let :math:`({\mathit{vectype}}{.}\mathsf{store}~{\mathit{memidx}}~{\mathit{memarg}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{vstore\_lane}`, then:

  a. Let :math:`({{\mathit{vectype}}{.}\mathsf{store}}{{\mathit{sz}}}{\mathsf{\_}}{\mathsf{lane}}~{\mathit{memidx}}~{\mathit{memarg}}~{\mathit{laneidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_vectype(vectype) ++ $free_memidx(memidx)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{memory{.}size}`, then:

  a. Let :math:`(\mathsf{memory{.}size}~{\mathit{memidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{memory{.}grow}`, then:

  a. Let :math:`(\mathsf{memory{.}grow}~{\mathit{memidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{memory{.}fill}`, then:

  a. Let :math:`(\mathsf{memory{.}fill}~{\mathit{memidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{free}}_{\mathit{memidx}}({\mathit{memidx}})`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{memory{.}copy}`, then:

  a. Let :math:`(\mathsf{memory{.}copy}~{\mathit{memidx}}_1~{\mathit{memidx}}_2)` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_memidx(memidx_1) ++ $free_memidx(memidx_2)`.

#. If :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{memory{.}init}`, then:

  a. Let :math:`(\mathsf{memory{.}init}~{\mathit{memidx}}~{\mathit{dataidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_memidx(memidx) ++ $free_dataidx(dataidx)`.

#. Assert: Due to validation, :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{data{.}drop}`.

#. Let :math:`(\mathsf{data{.}drop}~{\mathit{dataidx}})` be :math:`{\mathit{instr}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{\mathrm{free}}_{\mathit{dataidx}}({\mathit{dataidx}})`.


:math:`{\mathrm{free}}_{\mathit{block}}({{\mathit{instr}}^\ast})`
.................................................................


1. Let :math:`{\mathit{free}}` be :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{instr}}({\mathit{instr}})^\ast})`.

#. Return :math:`{\mathit{free}}{}[{.}\mathsf{labels} = {\mathrm{shift}}_{\mathit{labelidxs}}({\mathit{free}}{.}\mathsf{labels})]`.


:math:`{\mathrm{free}}_{\mathit{expr}}({{\mathit{instr}}^\ast})`
................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{instr}}({\mathit{instr}})^\ast})`.


:math:`{\mathrm{free}}_{\mathit{type}}((\mathsf{type}~{\mathit{rectype}}))`
...........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{rectype}}({\mathit{rectype}})`.


:math:`{\mathrm{free}}_{\mathit{local}}((\mathsf{local}~t))`
............................................................


1. Return :math:`{\mathrm{free}}_{\mathit{valtype}}(t)`.


:math:`{\mathrm{free}}_{\mathit{func}}((\mathsf{func}~{\mathit{typeidx}}~{{\mathit{local}}^\ast}~{\mathit{expr}}))`
...................................................................................................................


1. Return `$free_typeidx(typeidx) ++ $free_list($free_local(local)*{local <- local*}) ++ update($free_block(expr).LOCALS, [])`.


:math:`{\mathrm{free}}_{\mathit{global}}((\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}))`
..................................................................................................


1. Return `$free_globaltype(globaltype) ++ $free_expr(expr)`.


:math:`{\mathrm{free}}_{\mathit{table}}((\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}}))`
...............................................................................................


1. Return `$free_tabletype(tabletype) ++ $free_expr(expr)`.


:math:`{\mathrm{free}}_{\mathit{mem}}((\mathsf{memory}~{\mathit{memtype}}))`
............................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{memtype}}({\mathit{memtype}})`.


:math:`{\mathrm{free}}_{\mathit{tag}}((\mathsf{tag}~{\mathit{typeidx}}))`
.........................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{typeidx}}({\mathit{typeidx}})`.


:math:`{\mathrm{free}}_{\mathit{elemmode}}({\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
........................................................................................................


1. If :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{active}`, then:

  a. Let :math:`(\mathsf{active}~{\mathit{tableidx}}~{\mathit{expr}})` be :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_tableidx(tableidx) ++ $free_expr(expr)`.

#. If :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{passive}`, then:

  a. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.

#. Assert: Due to validation, :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{declare}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{elem}}((\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}^\ast}~{\mathit{elemmode}}))`
......................................................................................................................


1. Return `$free_reftype(reftype) ++ $free_list($free_expr(expr)*{expr <- expr*}) ++ $free_elemmode(elemmode)`.


:math:`{\mathrm{free}}_{\mathit{datamode}}({\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
........................................................................................................


1. If :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{active}`, then:

  a. Let :math:`(\mathsf{active}~{\mathit{memidx}}~{\mathit{expr}})` be :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return `$free_memidx(memidx) ++ $free_expr(expr)`.

#. Assert: Due to validation, :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{passive}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{locals}~\epsilon,\; \mathsf{labels}~\epsilon \}\end{array}`.


:math:`{\mathrm{free}}_{\mathit{data}}((\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}}))`
...................................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{datamode}}({\mathit{datamode}})`.


:math:`{\mathrm{free}}_{\mathit{start}}((\mathsf{start}~{\mathit{funcidx}}))`
.............................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{funcidx}}({\mathit{funcidx}})`.


:math:`{\mathrm{free}}_{\mathit{export}}((\mathsf{export}~{\mathit{name}}~{\mathit{externidx}}))`
.................................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{externidx}}({\mathit{externidx}})`.


:math:`{\mathrm{free}}_{\mathit{import}}((\mathsf{import}~{\mathit{name}}_1~{\mathit{name}}_2~{\mathit{externtype}}))`
......................................................................................................................


1. Return :math:`{\mathrm{free}}_{\mathit{externtype}}({\mathit{externtype}})`.


:math:`{\mathrm{free}}_{\mathit{module}}((\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast}))`
............................................................................................................................................................................................................................................................................................................................


1. Return `$free_list($free_type(type)*{type <- type*}) ++ $free_list($free_import(import)*{import <- import*}) ++ $free_list($free_func(func)*{func <- func*}) ++ $free_list($free_global(global)*{global <- global*}) ++ $free_list($free_table(table)*{table <- table*}) ++ $free_list($free_mem(mem)*{mem <- mem*}) ++ $free_list($free_tag(tag)*{tag <- tag*}) ++ $free_list($free_elem(elem)*{elem <- elem*}) ++ $free_list($free_data(data)*{data <- data*}) ++ $free_opt($free_start(start)?{start <- start?}) ++ $free_list($free_export(export)*{export <- export*})`.


:math:`{\mathrm{funcidx}}({\mathit{module}})`
.............................................


1. Return :math:`{\mathrm{free}}_{\mathit{module}}({\mathit{module}}){.}\mathsf{funcs}`.


:math:`{\mathrm{dataidx}}({{\mathit{func}}^\ast})`
..................................................


1. Return :math:`{\mathrm{free}}_{\mathit{list}}({{\mathrm{free}}_{\mathit{func}}({\mathit{func}})^\ast}){.}\mathsf{datas}`.


:math:`C{}[{.}\mathsf{local}{}[{{\mathit{localidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}] = {{{\mathit{lt}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}]`
.....................................................................................................................................................................


1. If :math:`{{\mathit{localidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon` and :math:`{{{\mathit{lt}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`C`.

#. Assert: Due to validation, :math:`{|{{{\mathit{lt}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{{\mathit{lt}}}_1~{{{\mathit{lt}}}^\ast}` be :math:`{{{\mathit{lt}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{localidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`x_1~{x^\ast}` be :math:`{{\mathit{localidx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`C{}[{.}\mathsf{locals}{}[x_1] = {{\mathit{lt}}}_1]{}[{.}\mathsf{local}{}[{x^\ast}] = {{{\mathit{lt}}}^\ast}]`.


:math:`{{{\mathrm{clos}}^\ast}}{({{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
................................................................................................


1. If :math:`{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{{\mathit{dt}}^\ast}~{\mathit{dt}}_n` be :math:`{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{{\mathit{dt}'}^\ast}` be :math:`{{{\mathrm{clos}}^\ast}}{({{\mathit{dt}}^\ast})}`.

#. Return :math:`{{\mathit{dt}'}^\ast}~{{\mathit{dt}}_n}{{}[ {:=}\, {{\mathit{dt}'}^\ast} ]}`.


:math:`{{\mathrm{clos}}}_{C}(t)`
................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{{{\mathrm{clos}}^\ast}}{(C{.}\mathsf{types})}`.

#. Return :math:`{t}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{clos}}}_{C}({\mathit{dt}})`
............................................


1. Let :math:`{{\mathit{dt}'}^\ast}` be :math:`{{{\mathrm{clos}}^\ast}}{(C{.}\mathsf{types})}`.

#. Return :math:`{{\mathit{dt}}}{{}[ {:=}\, {{\mathit{dt}'}^\ast} ]}`.


:math:`{{\mathrm{clos}}}_{C}({\mathit{mmt}})`
.............................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{{{\mathrm{clos}}^\ast}}{(C{.}\mathsf{types})}`.

#. Return :math:`{{\mathit{mmt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}} \prec x, i`
............................................................


1. If the type of :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is defined type, then:

  a. Return true.

#. If :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case , then:

  a. Let :math:`{\mathit{typeidx}}` be :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathit{typeidx}} < x`.

#. Assert: Due to validation, :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{rec}`.

#. Let :math:`(\mathsf{rec}~j)` be :math:`y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`j < i`.


:math:`{{\mathrm{unroll}}}_{C}({\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
......................................................................................


1. If the type of :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is defined type, then:

  a. Let :math:`{\mathit{deftype}}` be :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{unroll}}({\mathit{deftype}})`.

#. If :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case , then:

  a. Let :math:`{\mathit{typeidx}}` be :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathrm{unroll}}(C{.}\mathsf{types}{}[{\mathit{typeidx}}])`.

#. Assert: Due to validation, :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{rec}`.

#. Let :math:`(\mathsf{rec}~i)` be :math:`{\mathit{ht}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`C{.}\mathsf{recs}{}[i]`.


:math:`{{\mathrm{default}}}_{t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}`
........................................................................


1. If the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`({\mathsf{i}}{N}{.}\mathsf{const}~0)`.

#. If the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`({\mathsf{f}}{N}{.}\mathsf{const}~{+0})`.

#. If the type of :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Vnn, then:

  a. Let :math:`{\mathsf{v}}{N}` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`({\mathsf{v}}{N}{.}\mathsf{const}~0)`.

#. Assert: Due to validation, :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ref}`.

#. Let :math:`(\mathsf{ref}~{\mathit{NULL}}_{{\mathit{opt}}_0}~{\mathit{ht}})` be :math:`t_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{NULL}}_{{\mathit{opt}}_0} = \mathsf{null}`, then:

  a. Return :math:`(\mathsf{ref{.}null}~{\mathit{ht}})`.

#. Assert: Due to validation, :math:`{\mathit{NULL}}_{{\mathit{opt}}_0}` is not defined.

#. Return :math:`\epsilon`.


:math:`{\mathrm{funcidx}}(({{\mathit{global}}^\ast}, {{\mathit{table}}^\ast}, {{\mathit{mem}}^\ast}, {{\mathit{elem}}^\ast}, {{\mathit{data}}^\ast}))`
......................................................................................................................................................


1. Return :math:`{\mathrm{funcidx}}((\mathsf{module}~\epsilon~\epsilon~\epsilon~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~\epsilon~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~\epsilon~\epsilon))`.


:math:`{{\mathrm{relaxed}}(i)}{{}[ X_1, X_2 ]}`
...............................................


1. If :math:`{\mathrm{ND}}`, then:

  a. Return :math:`X_1~X_2{}[i]`.

#. Return :math:`X_1~X_2{}[0]`.


:math:`{{\mathrm{relaxed}}(i)}{{}[ X_1, X_2, X_3, X_4 ]}`
.........................................................


1. If :math:`{\mathrm{ND}}`, then:

  a. Return :math:`X_1~X_2~X_3~X_4{}[i]`.

#. Return :math:`X_1~X_2~X_3~X_4{}[0]`.


:math:`{{{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}^{{-1}}}}{({b^\ast})}`
...................................................................


1. Let :math:`n` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{i}}{N}}(n)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`n`.


:math:`{{{{\mathrm{bytes}}}_{{\mathsf{f}}{N}}^{{-1}}}}{({b^\ast})}`
...................................................................


1. Let :math:`p` be the result for which :math:`{{\mathrm{bytes}}}_{{\mathsf{f}}{N}}(p)` :math:`=` :math:`{b^\ast}`.

#. Return :math:`p`.


:math:`{{\mathrm{signed}}}_{N}(i)`
..................................


1. If :math:`i < {2^{N - 1}}`, then:

  a. Return :math:`i`.

#. Assert: Due to validation, :math:`{2^{N - 1}} \leq i`.

#. Assert: Due to validation, :math:`i < {2^{N}}`.

#. Return :math:`i - {2^{N}}`.


:math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{(i)}`
...............................................


1. Let :math:`j` be the result for which :math:`{{\mathrm{signed}}}_{N}(j)` :math:`=` :math:`i`.

#. Return :math:`j`.


:math:`{\mathrm{sx}}({\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
............................................................................


1. If the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is literal type, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Return :math:`\mathsf{s}`.


:math:`0`
.........


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Return :math:`0`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{+0}`.


:math:`\mathbb{B}(b_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
.............................................................


1. If :math:`b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is false, then:

  a. Return :math:`0`.

#. Assert: Due to validation, :math:`b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is true.

#. Return :math:`1`.


:math:`{{\mathrm{sat\_u}}}_{N}(i)`
..................................


1. If :math:`i < 0`, then:

  a. Return :math:`0`.

#. If :math:`i > {2^{N}} - 1`, then:

  a. Return :math:`{2^{N}} - 1`.

#. Return :math:`i`.


:math:`{{\mathrm{sat\_s}}}_{N}(i)`
..................................


1. If :math:`i < {-{2^{N - 1}}}`, then:

  a. Return :math:`{-{2^{N - 1}}}`.

#. If :math:`i > {2^{N - 1}} - 1`, then:

  a. Return :math:`{2^{N - 1}} - 1`.

#. Return :math:`i`.


:math:`{{\mathrm{ineg}}}_{N}(i_1)`
..................................


1. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({-{{\mathrm{signed}}}_{N}(i_1)})}`.


:math:`{{\mathrm{iabs}}}_{N}(i_1)`
..................................


1. If :math:`{{\mathrm{signed}}}_{N}(i_1) \geq 0`, then:

  a. Return :math:`i_1`.

#. Return :math:`{{\mathrm{ineg}}}_{N}(i_1)`.


:math:`{{{{\mathrm{iextend}}}_{N, M}^{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}}{(i)}`
....................................................................................................


1. If :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{u}`, then:

  a. Return :math:`i \mathbin{\mathrm{mod}} {2^{M}}`.

#. Assert: Due to validation, :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{s}`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({{\mathrm{signed}}}_{M}(i \mathbin{\mathrm{mod}} {2^{M}}))}`.


:math:`{{\mathrm{iadd}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`i_1 + i_2 \mathbin{\mathrm{mod}} {2^{N}}`.


:math:`{{\mathrm{isub}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`{2^{N}} + i_1 - i_2 \mathbin{\mathrm{mod}} {2^{N}}`.


:math:`{{\mathrm{imul}}}_{N}(i_1, i_2)`
.......................................


1. Return :math:`i_1 \cdot i_2 \mathbin{\mathrm{mod}} {2^{N}}`.


:math:`{{{{\mathrm{iadd\_sat}}}_{N}^{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}}{(i_1, i_2)}`
..........................................................................................................


1. If :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{u}`, then:

  a. Return :math:`{{\mathrm{sat\_u}}}_{N}(i_1 + i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{s}`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({{\mathrm{sat\_s}}}_{N}({{\mathrm{signed}}}_{N}(i_1) + {{\mathrm{signed}}}_{N}(i_2)))}`.


:math:`{{{{\mathrm{isub\_sat}}}_{N}^{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}}{(i_1, i_2)}`
..........................................................................................................


1. If :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{u}`, then:

  a. Return :math:`{{\mathrm{sat\_u}}}_{N}(i_1 - i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{s}`.

#. Return :math:`{{{{\mathrm{signed}}}_{N}^{{-1}}}}{({{\mathrm{sat\_s}}}_{N}({{\mathrm{signed}}}_{N}(i_1) - {{\mathrm{signed}}}_{N}(i_2)))}`.


:math:`{{\mathrm{ieqz}}}_{N}(i_1)`
..................................


1. Return :math:`\mathbb{B}(i_1 = 0)`.


:math:`{{\mathrm{inez}}}_{N}(i_1)`
..................................


1. Return :math:`\mathbb{B}(i_1 \neq 0)`.


:math:`{{\mathrm{ieq}}}_{N}(i_1, i_2)`
......................................


1. Return :math:`\mathbb{B}(i_1 = i_2)`.


:math:`{{\mathrm{ine}}}_{N}(i_1, i_2)`
......................................


1. Return :math:`\mathbb{B}(i_1 \neq i_2)`.


:math:`{{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}}{(i_1, i_2)}`
....................................................................................................


1. If :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{u}`, then:

  a. Return :math:`\mathbb{B}(i_1 < i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) < {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}}{(i_1, i_2)}`
....................................................................................................


1. If :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{u}`, then:

  a. Return :math:`\mathbb{B}(i_1 > i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) > {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}}{(i_1, i_2)}`
....................................................................................................


1. If :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{u}`, then:

  a. Return :math:`\mathbb{B}(i_1 \leq i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) \leq {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}}}{(i_1, i_2)}`
....................................................................................................


1. If :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{u}`, then:

  a. Return :math:`\mathbb{B}(i_1 \geq i_2)`.

#. Assert: Due to validation, :math:`{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{s}`.

#. Return :math:`\mathbb{B}({{\mathrm{signed}}}_{N}(i_1) \geq {{\mathrm{signed}}}_{N}(i_2))`.


:math:`{{\mathrm{pack}}}_{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(c)`
....................................................................................


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

  a. Return :math:`c`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{\mathrm{wrap}}}_{{|{\mathrm{unpack}}({\mathit{packtype}})|}, {|{\mathit{packtype}}|}}(c)`.


:math:`{{\mathrm{unpack}}}_{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(c)`
......................................................................................


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is number type, then:

  a. Return :math:`c`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{{{\mathrm{extend}}}_{{|{\mathit{packtype}}|}, {|{\mathrm{unpack}}({\mathit{packtype}})|}}^{\mathsf{u}}}}{(c)}`.


:math:`{{\mathrm{pack}}}_{{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(c)`
....................................................................................


1. If the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is literal type, then:

  a. Return :math:`c`.

#. Assert: Due to validation, the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{\mathrm{wrap}}}_{{|{\mathrm{unpack}}({\mathit{packtype}})|}, {|{\mathit{packtype}}|}}(c)`.


:math:`{{\mathrm{unpack}}}_{{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(c)`
......................................................................................


1. If the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is literal type, then:

  a. Return :math:`c`.

#. Assert: Due to validation, the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{{{\mathrm{extend}}}_{{|{\mathit{packtype}}|}, {|{\mathrm{unpack}}({\mathit{packtype}})|}}^{\mathsf{u}}}}{(c)}`.


:math:`{{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(i_{\mathit{u{\kern-0.1em\scriptstyle 1}}})}`
........................................................................................................................................................................


1. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`i` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{clz}`, then:

    1) Return :math:`{{\mathrm{iclz}}}_{N}(i)`.

  #. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ctz}`, then:

    1) Return :math:`{{\mathrm{ictz}}}_{N}(i)`.

  #. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{popcnt}`, then:

    1) Return :math:`{{\mathrm{ipopcnt}}}_{N}(i)`.

  #. Assert: Due to validation, :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{extend}`.

  #. Let :math:`({\mathsf{extend}}{M}{\mathsf{\_}}{\mathsf{s}})` be :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{{{{\mathrm{iextend}}}_{N, M}^{\mathsf{s}}}}{(i)}`.

#. Assert: Due to validation, the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`f` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{abs}`, then:

  a. Return :math:`{{\mathrm{fabs}}}_{N}(f)`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{neg}`, then:

  a. Return :math:`{{\mathrm{fneg}}}_{N}(f)`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sqrt}`, then:

  a. Return :math:`{{\mathrm{fsqrt}}}_{N}(f)`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ceil}`, then:

  a. Return :math:`{{\mathrm{fceil}}}_{N}(f)`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{floor}`, then:

  a. Return :math:`{{\mathrm{ffloor}}}_{N}(f)`.

#. If :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{trunc}`, then:

  a. Return :math:`{{\mathrm{ftrunc}}}_{N}(f)`.

#. Assert: Due to validation, :math:`{\mathit{unop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{nearest}`.

#. Return :math:`{{\mathrm{fnearest}}}_{N}(f)`.


:math:`{{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, i_{\mathit{u{\kern-0.1em\scriptstyle 2}}})}`
....................................................................................................................................................................................................................


1. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`i_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`i_2` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

    1) Return :math:`{{\mathrm{iadd}}}_{N}(i_1, i_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

    1) Return :math:`{{\mathrm{isub}}}_{N}(i_1, i_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

    1) Return :math:`{{\mathrm{imul}}}_{N}(i_1, i_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{div}`, then:

    1) Let :math:`({\mathsf{div}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{idiv}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{rem}`, then:

    1) Let :math:`({\mathsf{rem}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{irem}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{and}`, then:

    1) Return :math:`{{\mathrm{iand}}}_{N}(i_1, i_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{or}`, then:

    1) Return :math:`{{\mathrm{ior}}}_{N}(i_1, i_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{xor}`, then:

    1) Return :math:`{{\mathrm{ixor}}}_{N}(i_1, i_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{shl}`, then:

    1) Return :math:`{{\mathrm{ishl}}}_{N}(i_1, i_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{shr}`, then:

    1) Let :math:`({\mathsf{shr}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{ishr}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{rotl}`, then:

    1) Return :math:`{{\mathrm{irotl}}}_{N}(i_1, i_2)`.

  #. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{rotr}`, then:

    1) Return :math:`{{\mathrm{irotr}}}_{N}(i_1, i_2)`.

#. Assert: Due to validation, the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`f_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`f_2` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

  a. Return :math:`{{\mathrm{fadd}}}_{N}(f_1, f_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

  a. Return :math:`{{\mathrm{fsub}}}_{N}(f_1, f_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

  a. Return :math:`{{\mathrm{fmul}}}_{N}(f_1, f_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{div}`, then:

  a. Return :math:`{{\mathrm{fdiv}}}_{N}(f_1, f_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{min}`, then:

  a. Return :math:`{{\mathrm{fmin}}}_{N}(f_1, f_2)`.

#. If :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{max}`, then:

  a. Return :math:`{{\mathrm{fmax}}}_{N}(f_1, f_2)`.

#. Assert: Due to validation, :math:`{\mathit{binop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{copysign}`.

#. Return :math:`{{\mathrm{fcopysign}}}_{N}(f_1, f_2)`.


:math:`{\mathsf{eqz}}{{}_{{\mathsf{i}}{N}}(i)}`
...............................................


1. Return :math:`{{\mathrm{ieqz}}}_{N}(i)`.


:math:`{{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, i_{\mathit{u{\kern-0.1em\scriptstyle 2}}})}`
....................................................................................................................................................................................................................


1. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`i_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`i_2` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

  #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

    1) Return :math:`{{\mathrm{ieq}}}_{N}(i_1, i_2)`.

  #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

    1) Return :math:`{{\mathrm{ine}}}_{N}(i_1, i_2)`.

  #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{lt}`, then:

    1) Let :math:`({\mathsf{lt}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{ilt}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`.

  #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{gt}`, then:

    1) Let :math:`({\mathsf{gt}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{igt}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`.

  #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{le}`, then:

    1) Let :math:`({\mathsf{le}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{ile}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`.

  #. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ge}`, then:

    1) Let :math:`({\mathsf{ge}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{{{\mathrm{ige}}}_{N}^{{\mathit{sx}}}}}{(i_1, i_2)}`.

#. Assert: Due to validation, the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`f_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`f_2` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

  a. Return :math:`{{\mathrm{feq}}}_{N}(f_1, f_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

  a. Return :math:`{{\mathrm{fne}}}_{N}(f_1, f_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{lt}`, then:

  a. Return :math:`{{\mathrm{flt}}}_{N}(f_1, f_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{gt}`, then:

  a. Return :math:`{{\mathrm{fgt}}}_{N}(f_1, f_2)`.

#. If :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{le}`, then:

  a. Return :math:`{{\mathrm{fle}}}_{N}(f_1, f_2)`.

#. Assert: Due to validation, :math:`{\mathit{relop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ge}`.

#. Return :math:`{{\mathrm{fge}}}_{N}(f_1, f_2)`.


:math:`{{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, {\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}}(i_{\mathit{u{\kern-0.1em\scriptstyle 1}}})}`
................................................................................................................................................................................................................................


1. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{{\mathsf{i}}{N}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Inn, then:

    1) Let :math:`{{\mathsf{i}}{N}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{extend}`, then:

      a) Let :math:`({\mathsf{extend}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`i_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(i_1)}`.

    #) Let :math:`i_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{wrap}`, then:

      a) Return :math:`{{\mathrm{wrap}}}_{N_1, N_2}(i_1)`.

#. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{N}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Inn, then:

    1) Let :math:`{{\mathsf{i}}{N}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{trunc}`, then:

      a) Let :math:`({\mathsf{trunc}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`f_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{trunc}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(f_1)}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{trunc\_sat}`, then:

      a) Let :math:`({\mathsf{trunc\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`f_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(f_1)}`.

#. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{{\mathsf{i}}{N}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Fnn, then:

    1) Let :math:`{{\mathsf{f}}{N}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{convert}`, then:

      a) Let :math:`({\mathsf{convert}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`i_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Return :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(i_1)}`.

#. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{{\mathsf{f}}{N}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Fnn, then:

    1) Let :math:`{{\mathsf{f}}{N}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

    #) Let :math:`f_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{promote}`, then:

      a) Return :math:`{{\mathrm{promote}}}_{N_1, N_2}(f_1)`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{demote}`, then:

      a) Return :math:`{{\mathrm{demote}}}_{N_1, N_2}(f_1)`.

#. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{{\mathsf{i}}{N}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Fnn, then:

    1) Let :math:`{{\mathsf{f}}{N}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

    #) Let :math:`i_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) If :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{reinterpret}` and :math:`{|{{\mathsf{i}}{N}}_1|} = {|{{\mathsf{f}}{N}}_2|}`, then:

      a) Return :math:`{{\mathrm{reinterpret}}}_{{{\mathsf{i}}{N}}_1, {{\mathsf{f}}{N}}_2}(i_1)`.

#. Assert: Due to validation, the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{{\mathsf{f}}{N}}_1` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, the type of :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Inn.

#. Let :math:`{{\mathsf{i}}{N}}_2` be :math:`{\mathit{nt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

#. Let :math:`f_1` be :math:`i_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, :math:`{\mathit{cvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{reinterpret}`.

#. Assert: Due to validation, :math:`{|{{\mathsf{f}}{N}}_1|} = {|{{\mathsf{i}}{N}}_2|}`.

#. Return :math:`{{\mathrm{reinterpret}}}_{{{\mathsf{f}}{N}}_1, {{\mathsf{i}}{N}}_2}(f_1)`.


:math:`{{{{\mathrm{lanes}}}_{{\mathit{sh}}}^{{-1}}}}{({c^\ast})}`
.................................................................


1. Let :math:`{\mathit{vc}}` be the result for which :math:`{{\mathrm{lanes}}}_{{\mathit{sh}}}({\mathit{vc}})` :math:`=` :math:`{c^\ast}`.

#. Return :math:`{\mathit{vc}}`.


:math:`{\mathrm{half}}({\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, i, j)`
......................................................................................


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn and the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is Jnn, then:

  a. If :math:`{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{low}`, then:

    1) Return :math:`i`.

  #. If :math:`{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{high}`, then:

    1) Return :math:`j`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 2}}}` is Fnn.

#. Assert: Due to validation, :math:`{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{low}`.

#. Return :math:`i`.


:math:`{{\mathrm{iswizzle}}_{{\mathit{lane}}}}_{N}({c^\ast}, i)`
................................................................


1. If :math:`i < {|{c^\ast}|}`, then:

  a. Return :math:`{c^\ast}{}[i]`.

#. Return :math:`0`.


:math:`{{\mathrm{irelaxed}}_{{\mathit{swizzle}}_{{\mathit{lane}}}}}_{N}({c^\ast}, i)`
.....................................................................................


1. If :math:`i < {|{c^\ast}|}`, then:

  a. Return :math:`{c^\ast}{}[i]`.

#. If :math:`{{\mathrm{signed}}}_{N}(i) < 0`, then:

  a. Return :math:`0`.

#. Return :math:`{{\mathrm{relaxed}}({\mathrm{R}}_{\mathit{swizzle}})}{{}[ 0, {c^\ast}{}[i \mathbin{\mathrm{mod}} {|{c^\ast}|}] ]}`.


:math:`{{\mathrm{ivunop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1)`
.................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}(c_1)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1)`
.................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{f}}}_{N}(c_1)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{ivbinop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}(c_1, c_2)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{sx}}, v_1, v_2)`
........................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}({\mathit{sx}}, c_1, c_2)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivbinopsxnd}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{sx}}, v_1, v_2)`
..........................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{f}}}_{N}({\mathit{sx}}, c_1, c_2)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{f}}}_{N}(c_1, c_2)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{ivternopnd}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2, v_3)`
...............................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c_3^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_3)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{f}}}_{N}(c_1, c_2, c_3)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{fvternop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2, v_3)`
.............................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c_3^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_3)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{f}}}_{N}(c_1, c_2, c_3)^\ast}`.

#. Return :math:`{{{{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.


:math:`{{\mathrm{ivtestop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1)`
...................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}(c_1)^\ast}`.

#. Return :math:`{\Pi}\, {c^\ast}`.


:math:`{{\mathrm{fvtestop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1)`
...................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}(c_1)^\ast}`.

#. Return :math:`{\Pi}\, {c^\ast}`.


:math:`{{\mathrm{ivrelop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{f}}}_{N}(c_1, c_2))}^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivrelopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{sx}}, v_1, v_2)`
........................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{f}}}_{N}({\mathit{sx}}, c_1, c_2))}^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Assert: Due to validation, the type of :math:`{\mathit{fresh}}` for which :math:`{|{\mathit{fresh}}|}` :math:`=` :math:`{|{\mathsf{f}}{N}|}` is Inn.

#. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`{|{\mathsf{i}}{N}|}` :math:`=` :math:`{|{\mathsf{f}}{N}|}`.

#. Let :math:`{c^\ast}` be :math:`{{{{{\mathrm{extend}}}_{1, N}^{\mathsf{s}}}}{({{\mathrm{f}}}_{N}(c_1, c_2))}^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivshiftop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, i)`
.......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}(c_1, i)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivshiftopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, {\mathit{sx}}, v_1, i)`
........................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}({\mathit{sx}}, c_1, i)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivbitmaskop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`
........................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`c` be the result for which :math:`{{\mathrm{bits}}}_{{\mathsf{i}}{32}}(c)` :math:`=` :math:`{{{{{\mathrm{ilt}}}_{{|{\mathsf{i}}{N}|}}^{\mathsf{s}}}}{(c_1, 0)}^\ast}`.

#. Return :math:`c`.


:math:`{{\mathrm{ivswizzlop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{f}}, v_1, v_2)`
..........................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`{{{\mathrm{f}}}_{N}({c_1^\ast}, c_2)^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivshufflop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({i^\ast}, v_1, v_2)`
......................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v_2)`.

#. Let :math:`{c^\ast}` be :math:`{{c_1^\ast}~{c_2^\ast}{}[i]^\ast}`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}`.


:math:`{\mathsf{not}}{{}_{{\mathsf{v}}{N}}(v)}`
...............................................


1. Return :math:`{{\mathrm{inot}}}_{N}(v)`.


:math:`{{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathsf{v}}{N}}(v_1, v_2)}`
....................................................................................................


1. If :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{and}`, then:

  a. Return :math:`{{\mathrm{iand}}}_{N}(v_1, v_2)`.

#. If :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{andnot}`, then:

  a. Return :math:`{{\mathrm{iandnot}}}_{N}(v_1, v_2)`.

#. If :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{or}`, then:

  a. Return :math:`{{\mathrm{ior}}}_{N}(v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{vvbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{xor}`.

#. Return :math:`{{\mathrm{ixor}}}_{N}(v_1, v_2)`.


:math:`{\mathsf{bitselect}}{{}_{{\mathsf{v}}{N}}(v_1, v_2, v_3)}`
.................................................................


1. Return :math:`{{\mathrm{ibitselect}}}_{N}(v_1, v_2, v_3)`.


:math:`{{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}(v)}`
..................................................................................................................................................


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

  a. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{abs}`, then:

    1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fabs}}, v)`.

  #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{neg}`, then:

    1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fneg}}, v)`.

  #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sqrt}`, then:

    1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fsqrt}}, v)`.

  #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ceil}`, then:

    1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fceil}}, v)`.

  #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{floor}`, then:

    1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{ffloor}}, v)`.

  #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{trunc}`, then:

    1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{ftrunc}}, v)`.

  #. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{nearest}`, then:

    1) Return :math:`{{\mathrm{fvunop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fnearest}}, v)`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn.

#. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{abs}`, then:

  a. Return :math:`{{\mathrm{ivunop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{iabs}}, v)`.

#. If :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{neg}`, then:

  a. Return :math:`{{\mathrm{ivunop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ineg}}, v)`.

#. Assert: Due to validation, :math:`{\mathit{vunop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{popcnt}`.

#. Return :math:`{{\mathrm{ivunop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ipopcnt}}, v)`.


:math:`{{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}(v_1, v_2)}`
..........................................................................................................................................................


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

    1) Return :math:`{{\mathrm{ivbinop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{iadd}}, v_1, v_2)`.

  #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

    1) Return :math:`{{\mathrm{ivbinop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{isub}}, v_1, v_2)`.

  #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

    1) Return :math:`{{\mathrm{ivbinop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{imul}}, v_1, v_2)`.

  #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{add\_sat}`, then:

    1) Let :math:`({\mathsf{add\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{iadd}}_{{\mathit{sat}}}, {\mathit{sx}}, v_1, v_2)`.

  #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{sub\_sat}`, then:

    1) Let :math:`({\mathsf{sub\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{isub}}_{{\mathit{sat}}}, {\mathit{sx}}, v_1, v_2)`.

  #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{min}`, then:

    1) Let :math:`({\mathsf{min}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{imin}}, {\mathit{sx}}, v_1, v_2)`.

  #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{max}`, then:

    1) Let :math:`({\mathsf{max}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{imax}}, {\mathit{sx}}, v_1, v_2)`.

  #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = `, then:

    1) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{iavgr}}, \mathsf{u}, v_1, v_2)`.

  #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = `, then:

    1) Return :math:`{{\mathrm{ivbinopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{iq{\kern-0.1em\scriptstyle 15\kern-0.1em}mulr}}_{{\mathit{sat}}}, \mathsf{s}, v_1, v_2)`.

  #. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = `, then:

    1) Return :math:`{{\mathrm{ivbinopsxnd}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{irelaxed}}_{{\mathit{q{\kern-0.1em\scriptstyle 15\kern-0.1em}mulr}}}, \mathsf{s}, v_1, v_2)`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{add}`, then:

  a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fadd}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{sub}`, then:

  a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fsub}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{mul}`, then:

  a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fmul}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{div}`, then:

  a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fdiv}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{min}`, then:

  a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fmin}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{max}`, then:

  a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fmax}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{pmin}`, then:

  a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fpmin}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{pmax}`, then:

  a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fpmax}}, v_1, v_2)`.

#. If :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{relaxed\_min}`, then:

  a. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{frelaxed}}_{{\mathit{min}}}, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{vbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{relaxed\_max}`.

#. Return :math:`{{\mathrm{fvbinop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{frelaxed}}_{{\mathit{max}}}, v_1, v_2)`.


:math:`{{\mathit{vternop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}(v_1, v_2, v_3)}`
................................................................................................................................................................


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{\mathit{vternop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{relaxed\_laneselect}`, then:

    1) Return :math:`{{\mathrm{ivternopnd}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{irelaxed}}_{{\mathit{laneselect}}}, v_1, v_2, v_3)`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{vternop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{relaxed\_madd}`, then:

  a. Return :math:`{{\mathrm{fvternop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{frelaxed}}_{{\mathit{madd}}}, v_1, v_2, v_3)`.

#. Assert: Due to validation, :math:`{\mathit{vternop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{relaxed\_nmadd}`.

#. Return :math:`{{\mathrm{fvternop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{frelaxed}}_{{\mathit{nmadd}}}, v_1, v_2, v_3)`.


:math:`{\mathsf{all\_true}}{{}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v)}`
......................................................................


1. Return :math:`{{\mathrm{ivtestop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{inez}}, v)`.


:math:`{{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M}}(v_1, v_2)}`
..........................................................................................................................................................


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

  a. Let :math:`{\mathsf{i}}{N}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

    1) Return :math:`{{\mathrm{ivrelop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ieq}}, v_1, v_2)`.

  #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

    1) Return :math:`{{\mathrm{ivrelop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ine}}, v_1, v_2)`.

  #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{lt}`, then:

    1) Let :math:`({\mathsf{lt}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ilt}}, {\mathit{sx}}, v_1, v_2)`.

  #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{gt}`, then:

    1) Let :math:`({\mathsf{gt}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{igt}}, {\mathit{sx}}, v_1, v_2)`.

  #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{le}`, then:

    1) Let :math:`({\mathsf{le}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ile}}, {\mathit{sx}}, v_1, v_2)`.

  #. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{ge}`, then:

    1) Let :math:`({\mathsf{ge}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Return :math:`{{\mathrm{ivrelopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ige}}, {\mathit{sx}}, v_1, v_2)`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{\mathsf{f}}{N}` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{eq}`, then:

  a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{feq}}, v_1, v_2)`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ne}`, then:

  a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fne}}, v_1, v_2)`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{lt}`, then:

  a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{flt}}, v_1, v_2)`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{gt}`, then:

  a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fgt}}, v_1, v_2)`.

#. If :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{le}`, then:

  a. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fle}}, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{vrelop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{ge}`.

#. Return :math:`{{\mathrm{fvrelop}}}_{{{\mathsf{f}}{N}}{\mathsf{x}}{M}}({\mathrm{fge}}, v_1, v_2)`.


:math:`{{\mathrm{lcvtop}}}_{{{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}}{\mathsf{x}}{M_1}, {{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}, c_1)`
................................................................................................................................................................................................................................................


1. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Jnn, then:

  a. Let :math:`{{\mathsf{i}}{N}}_1` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

  #. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Jnn, then:

    1) Let :math:`{{\mathsf{i}}{N}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{extend}`, then:

      a) Let :math:`({\mathsf{extend}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`c` be :math:`{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}`.

      #) Return :math:`c`.

  #. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn, then:

    1) Let :math:`{{\mathsf{f}}{N}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{convert}`, then:

      a) Let :math:`({\mathsf{convert}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

      #) Let :math:`c` be :math:`{{{{\mathrm{convert}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}`.

      #) Return :math:`c`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}` is Fnn.

#. Let :math:`{{\mathsf{f}}{N}}_1` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 3}}}`.

#. If the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Inn, then:

  a. Let :math:`{{\mathsf{i}}{N}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{trunc\_sat}`, then:

    1) Let :math:`({\mathsf{trunc\_sat}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Let :math:`{c^?}` be :math:`{{{{\mathrm{trunc\_sat}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}`.

    #) Return :math:`{c^?}`.

  #. If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{relaxed\_trunc}`, then:

    1) Let :math:`({\mathsf{relaxed\_trunc}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

    #) Let :math:`{c^?}` be :math:`{{{{\mathrm{relaxed\_trunc}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}`.

    #) Return :math:`{c^?}`.

#. Assert: Due to validation, the type of :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is Fnn.

#. Let :math:`{{\mathsf{f}}{N}}_2` be :math:`{\mathit{lt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. If :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{demote}`, then:

  a. Let :math:`{c^\ast}` be :math:`{{\mathrm{demote}}}_{N_1, N_2}(c_1)`.

  #. Return :math:`{c^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{vcvtop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{promote}`.

#. Let :math:`{c^\ast}` be :math:`{{\mathrm{promote}}}_{N_1, N_2}(c_1)`.

#. Return :math:`{c^\ast}`.


:math:`{{\mathrm{vcvtop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{n_{\mathit{u{\kern-0.1em\scriptstyle 2}}}}}({\mathit{vcvtop}}, {{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}, {{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}, v_1)`
..........................................................................................................................................................................................................................................................................................................................................


1. Let :math:`M` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`{{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined and :math:`{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined and :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = M`, then:

  a. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M}}(v_1)`.

  #. Let :math:`{{c^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{lcvtop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M}}({\mathit{vcvtop}}, c_1)^\ast}`.

  #. Let :math:`v` be an element of :math:`{{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M}}^{{-1}}}}{({c^\ast})}^\ast}`.

  #. Return :math:`v`.

#. Let :math:`M_1` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Let :math:`M_2` be :math:`n_{\mathit{u{\kern-0.1em\scriptstyle 2}}}`.

#. If :math:`{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined and :math:`{{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined, then:

  a. Let :math:`{\mathit{half}}` be :math:`{{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

  #. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_1){}[{\mathrm{half}}({\mathit{half}}, 0, M_2) : M_2]`.

  #. Let :math:`{{c^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{lcvtop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}, c_1)^\ast}`.

  #. Let :math:`v` be an element of :math:`{{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({c^\ast})}^\ast}`.

  #. Return :math:`v`.

#. Assert: Due to validation, :math:`{{\mathit{half}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined.

#. Assert: Due to validation, :math:`{{\mathit{zero}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined.

#. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_1)`.

#. Let :math:`{{c^\ast}^\ast}` be :math:`\Large\times~{{{\mathrm{lcvtop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathit{vcvtop}}, c_1)^\ast}~{0^{M_1}}`.

#. Let :math:`v` be an element of :math:`{{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({c^\ast})}^\ast}`.

#. Return :math:`v`.


:math:`{{\mathit{vshiftop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}}{(v, i)}`
....................................................................................................................


1. If :math:`{\mathit{vshiftop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{shl}`, then:

  a. Return :math:`{{\mathrm{ivshiftop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ishl}}, v, i)`.

#. Assert: Due to validation, :math:`{\mathit{vshiftop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{shr}`.

#. Let :math:`({\mathsf{shr}}{\mathsf{\_}}{{\mathit{sx}}})` be :math:`{\mathit{vshiftop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{\mathrm{ivshiftopsx}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}({\mathrm{ishr}}, {\mathit{sx}}, v, i)`.


:math:`{\mathsf{vbitmask}}{{}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v)}`
.....................................................................


1. Return :math:`{{\mathrm{ivbitmaskop}}}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}}(v)`.


:math:`{{\mathit{swizzlop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}(v_1, v_2)}`
.................................................................................................................................


1. If :math:`{\mathit{swizzlop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{swizzle}`, then:

  a. Return :math:`{{\mathrm{ivswizzlop}}}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}({\mathrm{iswizzle}}_{{\mathit{lane}}}, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{swizzlop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{relaxed\_swizzle}`.

#. Return :math:`{{\mathrm{ivswizzlop}}}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}({\mathrm{irelaxed}}_{{\mathit{swizzle}}_{{\mathit{lane}}}}, v_1, v_2)`.


:math:`{\mathsf{vshuffle}}{{}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}({i^\ast}, v_1, v_2)}`
.................................................................................................


1. Return :math:`{{\mathrm{ivshufflop}}}_{{\mathsf{i{\scriptstyle 8}}}{\mathsf{x}}{M}}({i^\ast}, v_1, v_2)`.


:math:`{\mathsf{vnarrow}}{{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{\mathit{sx}}}}}{(v_1, v_2)}`
.............................................................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_1)`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_2)`.

#. Let :math:`{{c'}_1^\ast}` be :math:`{{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{N}}_1|}, {|{{\mathsf{i}}{N}}_2|}}^{{\mathit{sx}}}}}{c_1}^\ast}`.

#. Let :math:`{{c'}_2^\ast}` be :math:`{{{{{\mathrm{narrow}}}_{{|{{\mathsf{i}}{N}}_1|}, {|{{\mathsf{i}}{N}}_2|}}^{{\mathit{sx}}}}}{c_2}^\ast}`.

#. Let :math:`v` be :math:`{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({{c'}_1^\ast}~{{c'}_2^\ast})}`.

#. Return :math:`v`.


:math:`{{\mathrm{ivadd\_pairwise}}}_{N}({i^\ast})`
..................................................


1. Let :math:`{j_1~j_2^\ast}` be the result for which :math:`{\bigoplus}\, {j_1~j_2^\ast}` :math:`=` :math:`{i^\ast}`.

#. Return :math:`{{{\mathrm{iadd}}}_{N}(j_1, j_2)^\ast}`.


:math:`{{\mathrm{ivextunop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{f}}, {\mathit{sx}}, v_1)`
.................................................................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_1)`.

#. Let :math:`{{c'}_1^\ast}` be :math:`{{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}}}}{(c_1)}^\ast}`.

#. Let :math:`{c^\ast}` be :math:`{{\mathrm{f}}}_{N_2}({{c'}_1^\ast})`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({c^\ast})}`.


:math:`{({\mathsf{extadd\_pairwise}}{\mathsf{\_}}{{\mathit{sx}}})}{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}(v_1)}`
.............................................................................................................................................................


1. Return :math:`{{\mathrm{ivextunop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{ivadd}}_{{\mathit{pairwise}}}, {\mathit{sx}}, v_1)`.


:math:`{{\mathrm{ivdot}}}_{N}({i_1^\ast}, {i_2^\ast})`
......................................................


1. Let :math:`{j_1~j_2^\ast}` be the result for which :math:`{\bigoplus}\, {j_1~j_2^\ast}` :math:`=` :math:`{{{\mathrm{imul}}}_{N}(i_1, i_2)^\ast}`.

#. Return :math:`{{{\mathrm{iadd}}}_{N}(j_1, j_2)^\ast}`.


:math:`{{\mathrm{ivdot\_sat}}}_{N}({i_1^\ast}, {i_2^\ast})`
...........................................................


1. Let :math:`{j_1~j_2^\ast}` be the result for which :math:`{\bigoplus}\, {j_1~j_2^\ast}` :math:`=` :math:`{{{\mathrm{imul}}}_{N}(i_1, i_2)^\ast}`.

#. Return :math:`{{{{{\mathrm{iadd\_sat}}}_{N}^{\mathsf{s}}}}{(j_1, j_2)}^\ast}`.


:math:`{{\mathrm{ivextbinop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{f}}, {\mathit{sx}}_1, {\mathit{sx}}_2, i, k, v_1, v_2)`
................................................................................................................................................................................


1. Let :math:`{c_1^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_1){}[i : k]`.

#. Let :math:`{c_2^\ast}` be :math:`{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}}(v_2){}[i : k]`.

#. Let :math:`{{c'}_1^\ast}` be :math:`{{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}_1}}}{(c_1)}^\ast}`.

#. Let :math:`{{c'}_2^\ast}` be :math:`{{{{{\mathrm{extend}}}_{N_1, N_2}^{{\mathit{sx}}_2}}}{(c_2)}^\ast}`.

#. Let :math:`{c^\ast}` be :math:`{{\mathrm{f}}}_{N_2}({{c'}_1^\ast}, {{c'}_2^\ast})`.

#. Return :math:`{{{{\mathrm{lanes}}}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}^{{-1}}}}{({c^\ast})}`.


:math:`{{\mathrm{ivmul}}}_{N}({i_1^\ast}, {i_2^\ast})`
......................................................


1. Return :math:`{{{\mathrm{imul}}}_{N}(i_1, i_2)^\ast}`.


:math:`{{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}(v_1, v_2)}`
.....................................................................................................................................................................


1. If :math:`{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{extmul}`, then:

  a. Let :math:`({\mathsf{extmul}}{\mathsf{\_}}{{\mathit{sx}}}{\mathsf{\_}}{{\mathit{half}}})` be :math:`{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Let :math:`i` be :math:`{\mathrm{half}}({\mathit{half}}, 0, M_2)`.

  #. Return :math:`{{\mathrm{ivextbinop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{ivmul}}, {\mathit{sx}}, {\mathit{sx}}, i, M_2, v_1, v_2)`.

#. If :math:`{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = `, then:

  a. Return :math:`{{\mathrm{ivextbinop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{ivdot}}, \mathsf{s}, \mathsf{s}, 0, M_1, v_1, v_2)`.

#. Assert: Due to validation, :math:`{\mathit{vextbinop}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = `.

#. Return :math:`{{\mathrm{ivextbinop}}}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({\mathrm{ivdot}}_{{\mathit{sat}}}, \mathsf{s}, {{\mathrm{relaxed}}({\mathrm{R}}_{\mathit{idot}})}{{}[ \mathsf{s}, \mathsf{u} ]}, 0, M_1, v_1, v_2)`.


:math:`{}{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}(c_1, c_2, c_3)}`
..............................................................................................................


1. Let :math:`M` be :math:`2 \, M_2`.

#. Assert: Due to validation, the type of :math:`N` for which :math:`N` :math:`=` :math:`2 \cdot N_1` is Jnn.

#. Let :math:`{\mathsf{i}}{N}` be the result for which :math:`N` :math:`=` :math:`2 \cdot N_1`.

#. Let :math:`{c'}` be :math:`{}{{}_{{{{\mathsf{i}}{N}}_1}{\mathsf{x}}{M_1}, {{\mathsf{i}}{N}}{\mathsf{x}}{M}}(c_1, c_2)}`.

#. Let :math:`{c''}` be :math:`{({\mathsf{extadd\_pairwise}}{\mathsf{\_}}{\mathsf{s}})}{{}_{{{\mathsf{i}}{N}}{\mathsf{x}}{M}, {{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({c'})}`.

#. Let :math:`c` be an element of :math:`{\mathsf{add}}{{}_{{{{\mathsf{i}}{N}}_2}{\mathsf{x}}{M_2}}({c''}, c_3)}`.

#. Return :math:`c`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}(t)`
....................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{t}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{rt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{rt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{gt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{gt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{tt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{tt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{{\mathrm{inst}}}_{{\mathit{moduleinst}}}({\mathit{mt}})`
................................................................


1. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{\mathit{moduleinst}}{.}\mathsf{types}`.

#. Return :math:`{{\mathit{mt}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}`.


:math:`{\mathrm{Ki}}`
.....................


1. Return :math:`1024`.


:math:`{{\mathrm{pack}}}_{{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}(v_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
............................................................................................................................


1. If the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is value type, then:

  a. Let :math:`{\mathit{val}}` be :math:`v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`{\mathit{val}}`.

#. Assert: Due to validation, the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is packed type.

#. Let :math:`{\mathit{packtype}}` be :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, :math:`v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{const}`.

#. Let :math:`({\mathit{numtype}}_0{.}\mathsf{const}~i)` be :math:`v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, :math:`{\mathit{numtype}}_0 = \mathsf{i{\scriptstyle 32}}`.

#. Return :math:`({\mathit{packtype}}{.}\mathsf{pack}~{{\mathrm{wrap}}}_{32, {|{\mathit{packtype}}|}}(i))`.


:math:`{{{{\mathrm{unpack}}}_{{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}}^{{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}}}}{({\mathit{fv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})}`
............................................................................................................................................................................................................


1. If the type of :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is value type and the type of :math:`{\mathit{fv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is value, then:

  a. Let :math:`{\mathit{val}}` be :math:`{\mathit{fv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. If :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is not defined, then:

    1) Return :math:`{\mathit{val}}`.

#. Assert: Due to validation, :math:`{\mathit{fv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{pack}`.

#. Let :math:`({\mathit{packtype}}{.}\mathsf{pack}~i)` be :math:`{\mathit{fv}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Assert: Due to validation, :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}` is defined.

#. Let :math:`{\mathit{sx}}` be :math:`{{\mathit{sx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^?}`.

#. Assert: Due to validation, :math:`{\mathit{zt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = {\mathit{packtype}}`.

#. Return :math:`(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~{{{{\mathrm{extend}}}_{{|{\mathit{packtype}}|}, 32}^{{\mathit{sx}}}}}{(i)})`.


:math:`{\mathrm{funcs}}({{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
......................................................................................


1. If :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~a)` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`a~{\mathrm{funcs}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{funcs}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{globals}}({{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
........................................................................................


1. If :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~a)` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`a~{\mathrm{globals}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{globals}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{tables}}({{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.......................................................................................


1. If :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~a)` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`a~{\mathrm{tables}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tables}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{mems}}({{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~a)` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`a~{\mathrm{mems}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{mems}}({{\mathit{xa}}^\ast})`.


:math:`{\mathrm{tags}}({{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})`
.....................................................................................


1. If :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{externaddr}}_0~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. If :math:`{\mathit{externaddr}}_0` is of the case :math:`\mathsf{tag}`, then:

  a. Let :math:`(\mathsf{tag}~a)` be :math:`{\mathit{externaddr}}_0`.

  #. Return :math:`a~{\mathrm{tags}}({{\mathit{xa}}^\ast})`.

#. Let :math:`{\mathit{externaddr}}~{{\mathit{xa}}^\ast}` be :math:`{{\mathit{xa}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Return :math:`{\mathrm{tags}}({{\mathit{xa}}^\ast})`.


:math:`z{.}\mathsf{store}`
..........................


1. Return.


:math:`z{.}\mathsf{frame}`
..........................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`f`.


:math:`z{.}\mathsf{tags}`
.........................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`f{.}\mathsf{module}{.}\mathsf{tags}`.


:math:`z{.}\mathsf{module}`
...........................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`f{.}\mathsf{module}`.


:math:`z{.}\mathsf{funcs}`
..........................


1. Return :math:`s{.}\mathsf{funcs}`.


:math:`z{.}\mathsf{globals}`
............................


1. Return :math:`s{.}\mathsf{globals}`.


:math:`z{.}\mathsf{tables}`
...........................


1. Return :math:`s{.}\mathsf{tables}`.


:math:`z{.}\mathsf{mems}`
.........................


1. Return :math:`s{.}\mathsf{mems}`.


:math:`z{.}\mathsf{tags}`
.........................


1. Return :math:`s{.}\mathsf{tags}`.


:math:`z{.}\mathsf{elems}`
..........................


1. Return :math:`s{.}\mathsf{elems}`.


:math:`z{.}\mathsf{datas}`
..........................


1. Return :math:`s{.}\mathsf{datas}`.


:math:`z{.}\mathsf{structs}`
............................


1. Return :math:`s{.}\mathsf{structs}`.


:math:`z{.}\mathsf{arrays}`
...........................


1. Return :math:`s{.}\mathsf{arrays}`.


:math:`z{.}\mathsf{exns}`
.........................


1. Return :math:`s{.}\mathsf{exns}`.


:math:`z{.}\mathsf{types}{}[x]`
...............................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`f{.}\mathsf{module}{.}\mathsf{types}{}[x]`.


:math:`z{.}\mathsf{funcs}{}[x]`
...............................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`s{.}\mathsf{funcs}{}[f{.}\mathsf{module}{.}\mathsf{funcs}{}[x]]`.


:math:`z{.}\mathsf{globals}{}[x]`
.................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]`.


:math:`z{.}\mathsf{tables}{}[x]`
................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]`.


:math:`z{.}\mathsf{mems}{}[x]`
..............................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]`.


:math:`z{.}\mathsf{tags}{}[x]`
..............................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`s{.}\mathsf{tags}{}[f{.}\mathsf{module}{.}\mathsf{tags}{}[x]]`.


:math:`z{.}\mathsf{elems}{}[x]`
...............................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]`.


:math:`z{.}\mathsf{datas}{}[x]`
...............................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]`.


:math:`z{.}\mathsf{locals}{}[x]`
................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Return :math:`f{.}\mathsf{locals}{}[x]`.


:math:`z{}[{.}\mathsf{locals}{}[x] = v]`
........................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`f{.}\mathsf{locals}{}[x]` with :math:`v`.


:math:`z{}[{.}\mathsf{globals}{}[x]{.}\mathsf{value} = v]`
..........................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`s{.}\mathsf{globals}{}[f{.}\mathsf{module}{.}\mathsf{globals}{}[x]]{.}\mathsf{value}` with :math:`v`.


:math:`z{}[{.}\mathsf{tables}{}[x]{.}\mathsf{refs}{}[i] = r]`
.............................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]{.}\mathsf{refs}{}[i]` with :math:`r`.


:math:`z{}[{.}\mathsf{tables}{}[x] = {\mathit{ti}}]`
....................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`s{.}\mathsf{tables}{}[f{.}\mathsf{module}{.}\mathsf{tables}{}[x]]` with :math:`{\mathit{ti}}`.


:math:`z{}[{.}\mathsf{mems}{}[x]{.}\mathsf{bytes}{}[i : j] = {b^\ast}]`
.......................................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]{.}\mathsf{bytes}{}[i : j]` with :math:`{b^\ast}`.


:math:`z{}[{.}\mathsf{mems}{}[x] = {\mathit{mi}}]`
..................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`s{.}\mathsf{mems}{}[f{.}\mathsf{module}{.}\mathsf{mems}{}[x]]` with :math:`{\mathit{mi}}`.


:math:`z{}[{.}\mathsf{elems}{}[x]{.}\mathsf{refs} = {r^\ast}]`
..............................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`s{.}\mathsf{elems}{}[f{.}\mathsf{module}{.}\mathsf{elems}{}[x]]{.}\mathsf{refs}` with :math:`{r^\ast}`.


:math:`z{}[{.}\mathsf{datas}{}[x]{.}\mathsf{bytes} = {b^\ast}]`
...............................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~f~\})` be the current :math:`\mathsf{frame}` context.

#. Replace :math:`s{.}\mathsf{datas}{}[f{.}\mathsf{module}{.}\mathsf{datas}{}[x]]{.}\mathsf{bytes}` with :math:`{b^\ast}`.


:math:`z{}[{.}\mathsf{structs}{}[a]{.}\mathsf{fields}{}[i] = {\mathit{fv}}]`
............................................................................


1. Replace :math:`s{.}\mathsf{structs}{}[a]{.}\mathsf{fields}{}[i]` with :math:`{\mathit{fv}}`.


:math:`z{}[{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}{}[i] = {\mathit{fv}}]`
...........................................................................


1. Replace :math:`s{.}\mathsf{arrays}{}[a]{.}\mathsf{fields}{}[i]` with :math:`{\mathit{fv}}`.


:math:`z{}[{.}\mathsf{structs} \mathrel{{=}{\oplus}} {{\mathit{si}}^\ast}]`
...........................................................................


1. Append :math:`{{\mathit{si}}^\ast}` to :math:`s{.}\mathsf{structs}`.


:math:`z{}[{.}\mathsf{arrays} \mathrel{{=}{\oplus}} {{\mathit{ai}}^\ast}]`
..........................................................................


1. Append :math:`{{\mathit{ai}}^\ast}` to :math:`s{.}\mathsf{arrays}`.


:math:`z{}[{.}\mathsf{exns} \mathrel{{=}{\oplus}} {{\mathit{exn}}^\ast}]`
.........................................................................


1. Append :math:`{{\mathit{exn}}^\ast}` to :math:`s{.}\mathsf{exns}`.


:math:`{\mathrm{growtable}}({\mathit{tableinst}}, n, r)`
........................................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({\mathit{at}}, ({}[~i~..~j~]), {\mathit{rt}}),\; \mathsf{refs}~{{r'}^\ast} \}\end{array}` be :math:`{\mathit{tableinst}}`.

#. If :math:`{|{{r'}^\ast}|} + n \leq j`, then:

  a. Let :math:`{i'}` be :math:`{|{{r'}^\ast}|} + n`.

  #. Let :math:`{\mathit{tableinst}'}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({\mathit{at}}, ({}[~{i'}~..~j~]), {\mathit{rt}}),\; \mathsf{refs}~{{r'}^\ast}~{r^{n}} \}\end{array}`.

  #. Return :math:`{\mathit{tableinst}'}`.


:math:`{\mathrm{growmem}}({\mathit{meminst}}, n)`
.................................................


1. Let :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({\mathit{at}}~({}[~i~..~j~])~\mathsf{page}),\; \mathsf{bytes}~{b^\ast} \}\end{array}` be :math:`{\mathit{meminst}}`.

#. If :math:`{|{b^\ast}|} / 64 \, {\mathrm{Ki}} + n \leq j`, then:

  a. Let :math:`{i'}` be :math:`{|{b^\ast}|} / 64 \, {\mathrm{Ki}} + n`.

  #. Let :math:`{\mathit{meminst}'}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({\mathit{at}}~({}[~{i'}~..~j~])~\mathsf{page}),\; \mathsf{bytes}~{b^\ast}~{\mathtt{0x00}^{n \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

  #. Return :math:`{\mathit{meminst}'}`.


:math:`{{\mathrm{blocktype}}}_{z}({\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}})`
.........................................................................................


1. If :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case , then:

  a. Let :math:`x` be :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Assert: Due to validation, :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])` is of the case :math:`\mathsf{func}`.

  #. Let :math:`(\mathsf{func}~{\mathit{ft}})` be :math:`{\mathrm{expand}}(z{.}\mathsf{types}{}[x])`.

  #. Return :math:`{\mathit{ft}}`.

#. Assert: Due to validation, :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case .

#. Let :math:`{t^?}` be :math:`{\mathit{bt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`\epsilon~\rightarrow~{t^?}`.


:math:`{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
.......................................................................................................


1. If :math:`{{\mathit{type}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{{\mathit{type}'}^\ast}~{\mathit{type}}` be :math:`{{\mathit{type}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{\mathit{type}}` is of the case :math:`\mathsf{type}`.

#. Let :math:`(\mathsf{type}~{\mathit{rectype}})` be :math:`{\mathit{type}}`.

#. Let :math:`{{\mathit{deftype}'}^\ast}` be :math:`{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}'}^\ast})}`.

#. Let :math:`x` be :math:`{|{{\mathit{deftype}'}^\ast}|}`.

#. Let :math:`{{\mathit{deftype}}^\ast}` be :math:`{{{{{\mathrm{roll}}}_{x}^\ast}}{({\mathit{rectype}})}}{{}[ {:=}\, {{\mathit{deftype}'}^\ast} ]}`.

#. Return :math:`{{\mathit{deftype}'}^\ast}~{{\mathit{deftype}}^\ast}`.


:math:`{\mathrm{allocfunc}}(s, {\mathit{deftype}}, {\mathit{code}}, {\mathit{moduleinst}})`
...........................................................................................


1. Let :math:`{\mathit{funcinst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{deftype}},\; \mathsf{module}~{\mathit{moduleinst}},\; \mathsf{code}~{\mathit{code}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{funcs}|}`.

#. Append :math:`{\mathit{funcinst}}` to :math:`s{.}\mathsf{funcs}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocfunc}}^\ast}}{(s, {{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {{{\mathit{code}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {{\mathit{moduleinst}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
................................................................................................................................................................................................................................................


1. If :math:`{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Assert: Due to validation, :math:`{{{\mathit{code}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`.

  #. Assert: Due to validation, :math:`{{\mathit{moduleinst}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`.

  #. Return :math:`\epsilon`.

#. Else:

  a. Let :math:`{\mathit{dt}}~{{\mathit{dt}'}^\ast}` be :math:`{{\mathit{dt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

  #. Assert: Due to validation, :math:`{|{{{\mathit{code}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

  #. Let :math:`{\mathit{code}}~{{{\mathit{code}}'}^\ast}` be :math:`{{{\mathit{code}}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

  #. Assert: Due to validation, :math:`{|{{\mathit{moduleinst}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

  #. Let :math:`{\mathit{moduleinst}}~{{\mathit{moduleinst}'}^\ast}` be :math:`{{\mathit{moduleinst}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

  #. Let :math:`{\mathit{fa}}` be :math:`{\mathrm{allocfunc}}(s, {\mathit{dt}}, {\mathit{code}}, {\mathit{moduleinst}})`.

  #. Let :math:`{{\mathit{fa}'}^\ast}` be :math:`{{{\mathrm{allocfunc}}^\ast}}{(s, {{\mathit{dt}'}^\ast}, {{{\mathit{code}}'}^\ast}, {{\mathit{moduleinst}'}^\ast})}`.

  #. Return :math:`{\mathit{fa}}~{{\mathit{fa}'}^\ast}`.


:math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`
........................................................................


1. Let :math:`{\mathit{globalinst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{globaltype}},\; \mathsf{value}~{\mathit{val}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{globals}|}`.

#. Append :math:`{\mathit{globalinst}}` to :math:`s{.}\mathsf{globals}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocglobal}}^\ast}}{(s, {{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
............................................................................................................................................................


1. If :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Assert: Due to validation, :math:`{v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`.

  #. Return :math:`\epsilon`.

#. Else:

  a. Let :math:`{\mathit{globaltype}}~{{\mathit{globaltype}'}^\ast}` be :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

  #. Assert: Due to validation, :math:`{|{v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

  #. Let :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}` be :math:`{v_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

  #. Let :math:`{\mathit{ga}}` be :math:`{\mathrm{allocglobal}}(s, {\mathit{globaltype}}, {\mathit{val}})`.

  #. Let :math:`{{\mathit{ga}'}^\ast}` be :math:`{{{\mathrm{allocglobal}}^\ast}}{(s, {{\mathit{globaltype}'}^\ast}, {{\mathit{val}'}^\ast})}`.

  #. Return :math:`{\mathit{ga}}~{{\mathit{ga}'}^\ast}`.


:math:`{\mathrm{alloctable}}(s, ({\mathit{at}}, ({}[~i~..~j~]), {\mathit{rt}}), {\mathit{ref}})`
................................................................................................


1. Let :math:`{\mathit{tableinst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({\mathit{at}}, ({}[~i~..~j~]), {\mathit{rt}}),\; \mathsf{refs}~{{\mathit{ref}}^{i}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{tables}|}`.

#. Append :math:`{\mathit{tableinst}}` to :math:`s{.}\mathsf{tables}`.

#. Return :math:`a`.


:math:`{{{\mathrm{alloctable}}^\ast}}{(s, {{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
...........................................................................................................................................................


1. If :math:`{{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon` and :math:`{r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{ref}}~{{\mathit{ref}'}^\ast}` be :math:`{r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{tabletype}}~{{\mathit{tabletype}'}^\ast}` be :math:`{{\mathit{tt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{ta}}` be :math:`{\mathrm{alloctable}}(s, {\mathit{tabletype}}, {\mathit{ref}})`.

#. Let :math:`{{\mathit{ta}'}^\ast}` be :math:`{{{\mathrm{alloctable}}^\ast}}{(s, {{\mathit{tabletype}'}^\ast}, {{\mathit{ref}'}^\ast})}`.

#. Return :math:`{\mathit{ta}}~{{\mathit{ta}'}^\ast}`.


:math:`{\mathrm{allocmem}}(s, ({\mathit{at}}~({}[~i~..~j~])~\mathsf{page}))`
............................................................................


1. Let :math:`{\mathit{meminst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~({\mathit{at}}~({}[~i~..~j~])~\mathsf{page}),\; \mathsf{bytes}~{\mathtt{0x00}^{i \cdot 64 \, {\mathrm{Ki}}}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{mems}|}`.

#. Append :math:`{\mathit{meminst}}` to :math:`s{.}\mathsf{mems}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocmem}}^\ast}}{(s, {{\mathit{mt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
.......................................................................................................


1. If :math:`{{\mathit{mt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{memtype}}~{{\mathit{memtype}'}^\ast}` be :math:`{{\mathit{mt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{ma}}` be :math:`{\mathrm{allocmem}}(s, {\mathit{memtype}})`.

#. Let :math:`{{\mathit{ma}'}^\ast}` be :math:`{{{\mathrm{allocmem}}^\ast}}{(s, {{\mathit{memtype}'}^\ast})}`.

#. Return :math:`{\mathit{ma}}~{{\mathit{ma}'}^\ast}`.


:math:`{\mathrm{alloctag}}(s, {\mathit{tagtype}})`
..................................................


1. Let :math:`{\mathit{taginst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{tagtype}} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{tags}|}`.

#. Append :math:`{\mathit{taginst}}` to :math:`s{.}\mathsf{tags}`.

#. Return :math:`a`.


:math:`{{{\mathrm{alloctag}}^\ast}}{(s, {{\mathit{jt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
.......................................................................................................


1. If :math:`{{\mathit{jt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Let :math:`{\mathit{jt}}~{{\mathit{jt}'}^\ast}` be :math:`{{\mathit{jt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{ja}}` be :math:`{\mathrm{alloctag}}(s, {\mathit{jt}})`.

#. Let :math:`{{\mathit{ja}'}^\ast}` be :math:`{{{\mathrm{alloctag}}^\ast}}{(s, {{\mathit{jt}'}^\ast})}`.

#. Return :math:`{\mathit{ja}}~{{\mathit{ja}'}^\ast}`.


:math:`{\mathrm{allocelem}}(s, {\mathit{elemtype}}, {{\mathit{ref}}^\ast})`
...........................................................................


1. Let :math:`{\mathit{eleminst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{type}~{\mathit{elemtype}},\; \mathsf{refs}~{{\mathit{ref}}^\ast} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{elems}|}`.

#. Append :math:`{\mathit{eleminst}}` to :math:`s{.}\mathsf{elems}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocelem}}^\ast}}{(s, {{\mathit{elemtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
................................................................................................................................................................


1. If :math:`{{\mathit{elemtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon` and :math:`{r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{{\mathit{ref}}^\ast}~{{{\mathit{ref}'}^\ast}^\ast}` be :math:`{r_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{elemtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{rt}}~{{\mathit{rt}'}^\ast}` be :math:`{{\mathit{elemtype}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{ea}}` be :math:`{\mathrm{allocelem}}(s, {\mathit{rt}}, {{\mathit{ref}}^\ast})`.

#. Let :math:`{{\mathit{ea}'}^\ast}` be :math:`{{{\mathrm{allocelem}}^\ast}}{(s, {{\mathit{rt}'}^\ast}, {{{\mathit{ref}'}^\ast}^\ast})}`.

#. Return :math:`{\mathit{ea}}~{{\mathit{ea}'}^\ast}`.


:math:`{\mathrm{allocdata}}(s, \mathsf{ok}, {{\mathit{byte}}^\ast})`
....................................................................


1. Let :math:`{\mathit{datainst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{bytes}~{{\mathit{byte}}^\ast} \}\end{array}`.

#. Let :math:`a` be :math:`{|s{.}\mathsf{datas}|}`.

#. Append :math:`{\mathit{datainst}}` to :math:`s{.}\mathsf{datas}`.

#. Return :math:`a`.


:math:`{{{\mathrm{allocdata}}^\ast}}{(s, {{\mathit{ok}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
..........................................................................................................................................................


1. If :math:`{{\mathit{ok}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon` and :math:`{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{b^\ast}~{{{b'}^\ast}^\ast}` be :math:`{b_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{ok}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{ok}}~{{\mathit{ok}'}^\ast}` be :math:`{{\mathit{ok}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`{\mathit{da}}` be :math:`{\mathrm{allocdata}}(s, {\mathit{ok}}, {b^\ast})`.

#. Let :math:`{{\mathit{da}'}^\ast}` be :math:`{{{\mathrm{allocdata}}^\ast}}{(s, {{\mathit{ok}'}^\ast}, {{{b'}^\ast}^\ast})}`.

#. Return :math:`{\mathit{da}}~{{\mathit{da}'}^\ast}`.


:math:`{\mathrm{allocexport}}({\mathit{moduleinst}}, (\mathsf{export}~{\mathit{name}}~{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}))`
..............................................................................................................................................


1. If :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{func}`, then:

  a. Let :math:`(\mathsf{func}~x)` be :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{func}~{\mathit{moduleinst}}{.}\mathsf{funcs}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{global}`, then:

  a. Let :math:`(\mathsf{global}~x)` be :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{global}~{\mathit{moduleinst}}{.}\mathsf{globals}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{table}`, then:

  a. Let :math:`(\mathsf{table}~x)` be :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{table}~{\mathit{moduleinst}}{.}\mathsf{tables}{}[x]) \}\end{array}`.

#. If :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{mem}`, then:

  a. Let :math:`(\mathsf{mem}~x)` be :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

  #. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{mem}~{\mathit{moduleinst}}{.}\mathsf{mems}{}[x]) \}\end{array}`.

#. Assert: Due to validation, :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{tag}`.

#. Let :math:`(\mathsf{tag}~x)` be :math:`{\mathit{xx}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{name}~{\mathit{name}},\; \mathsf{addr}~(\mathsf{tag}~{\mathit{moduleinst}}{.}\mathsf{tags}{}[x]) \}\end{array}`.


:math:`{{{\mathrm{allocexport}}^\ast}}{({\mathit{moduleinst}}, {{\mathit{export}}^\ast})}`
..........................................................................................


1. Return :math:`{{\mathrm{allocexport}}({\mathit{moduleinst}}, {\mathit{export}})^\ast}`.


:math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}_{\mathsf{g}}^\ast}, {{\mathit{ref}}_{\mathsf{t}}^\ast}, {{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast})`
.....................................................................................................................................................................................................


1. Assert: Due to validation, :math:`{\mathit{module}}` is of the case :math:`\mathsf{module}`.

#. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be :math:`{\mathit{module}}`.

#. Let :math:`{{\mathit{fa}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ga}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{globals}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{aa}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{tags}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ma}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{mems}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{ta}}_{\mathsf{i}}^\ast}` be :math:`{\mathrm{tables}}({{\mathit{externaddr}}^\ast})`.

#. Let :math:`{{\mathit{fa}}^\ast}` be :math:`{({|s{.}\mathsf{funcs}|} + i_{\mathsf{f}})^{i_{\mathsf{f}}<{|{{\mathit{func}}^\ast}|}}}`.

#. Let :math:`{{\mathit{ga}}^\ast}` be :math:`{({|s{.}\mathsf{globals}|} + i_{\mathsf{g}})^{i_{\mathsf{g}}<{|{{\mathit{global}}^\ast}|}}}`.

#. Let :math:`{{\mathit{ta}}^\ast}` be :math:`{({|s{.}\mathsf{tables}|} + i_{\mathsf{t}})^{i_{\mathsf{t}}<{|{{\mathit{table}}^\ast}|}}}`.

#. Let :math:`{{\mathit{aa}}^\ast}` be :math:`{({|s{.}\mathsf{tags}|} + i_{\mathsf{a}})^{i_{\mathsf{a}}<{|{{\mathit{tag}}^\ast}|}}}`.

#. Let :math:`{{\mathit{ma}}^\ast}` be :math:`{({|s{.}\mathsf{mems}|} + i_{\mathsf{m}})^{i_{\mathsf{m}}<{|{{\mathit{mem}}^\ast}|}}}`.

#. Let :math:`{{\mathit{ea}}^\ast}` be :math:`{({|s{.}\mathsf{elems}|} + i_{\mathsf{e}})^{i_{\mathsf{e}}<{|{{\mathit{elem}}^\ast}|}}}`.

#. Let :math:`{{\mathit{da}}^\ast}` be :math:`{({|s{.}\mathsf{datas}|} + i_{\mathsf{d}})^{i_{\mathsf{d}}<{|{{\mathit{data}}^\ast}|}}}`.

#. Assert: Due to validation, for all :math:`{\mathit{mem}}` in :math:`{{\mathit{mem}}^\ast}`, :math:`{\mathit{mem}}` is of the case :math:`\mathsf{memory}`.

#. Let :math:`{(\mathsf{memory}~{\mathit{memtype}})^\ast}` be :math:`{{\mathit{mem}}^\ast}`.

#. Let :math:`{{\mathit{dt}}^\ast}` be :math:`{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}}^\ast})}`.

#. Assert: Due to validation, for all :math:`{\mathit{tag}}` in :math:`{{\mathit{tag}}^\ast}`, :math:`{\mathit{tag}}` is of the case :math:`\mathsf{tag}`.

#. Let :math:`{(\mathsf{tag}~y)^\ast}` be :math:`{{\mathit{tag}}^\ast}`.

#. Assert: Due to validation, for all :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}`, :math:`{\mathit{data}}` is of the case :math:`\mathsf{data}`.

#. Let :math:`{(\mathsf{data}~{{\mathit{byte}}^\ast}~{\mathit{datamode}})^\ast}` be :math:`{{\mathit{data}}^\ast}`.

#. Assert: Due to validation, for all :math:`{\mathit{global}}` in :math:`{{\mathit{global}}^\ast}`, :math:`{\mathit{global}}` is of the case :math:`\mathsf{global}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})^\ast}` be :math:`{{\mathit{global}}^\ast}`.

#. Assert: Due to validation, for all :math:`{\mathit{table}}` in :math:`{{\mathit{table}}^\ast}`, :math:`{\mathit{table}}` is of the case :math:`\mathsf{table}`.

#. Let :math:`{(\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}}_{\mathsf{t}})^\ast}` be :math:`{{\mathit{table}}^\ast}`.

#. Assert: Due to validation, for all :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}`, :math:`{\mathit{elem}}` is of the case :math:`\mathsf{elem}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{elemtype}}~{{\mathit{expr}}_{\mathsf{e}}^\ast}~{\mathit{elemmode}})^\ast}` be :math:`{{\mathit{elem}}^\ast}`.

#. Assert: Due to validation, for all :math:`{\mathit{func}}` in :math:`{{\mathit{func}}^\ast}`, :math:`{\mathit{func}}` is of the case :math:`\mathsf{func}`.

#. Let :math:`{(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}}_{\mathsf{f}})^\ast}` be :math:`{{\mathit{func}}^\ast}`.

#. Let :math:`{{\mathit{xi}}^\ast}` be :math:`{{{\mathrm{allocexport}}^\ast}}{(\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~{{\mathit{fa}}_{\mathsf{i}}^\ast}~{{\mathit{fa}}^\ast},\; \mathsf{globals}~{{\mathit{ga}}_{\mathsf{i}}^\ast}~{{\mathit{ga}}^\ast},\; \mathsf{tables}~{{\mathit{ta}}_{\mathsf{i}}^\ast}~{{\mathit{ta}}^\ast},\; \mathsf{mems}~{{\mathit{ma}}_{\mathsf{i}}^\ast}~{{\mathit{ma}}^\ast},\; \mathsf{tags}~{{\mathit{aa}}_{\mathsf{i}}^\ast}~{{\mathit{aa}}^\ast},\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{exports}~\epsilon \}\end{array}, {{\mathit{export}}^\ast})}`.

#. Let :math:`{\mathit{moduleinst}}` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{\mathit{dt}}^\ast},\; \mathsf{funcs}~{{\mathit{fa}}_{\mathsf{i}}^\ast}~{{\mathit{fa}}^\ast},\; \mathsf{globals}~{{\mathit{ga}}_{\mathsf{i}}^\ast}~{{\mathit{ga}}^\ast},\; \mathsf{tables}~{{\mathit{ta}}_{\mathsf{i}}^\ast}~{{\mathit{ta}}^\ast},\; \mathsf{mems}~{{\mathit{ma}}_{\mathsf{i}}^\ast}~{{\mathit{ma}}^\ast},\; \mathsf{tags}~{{\mathit{aa}}_{\mathsf{i}}^\ast}~{{\mathit{aa}}^\ast},\; \mathsf{elems}~{{\mathit{ea}}^\ast},\; \mathsf{datas}~{{\mathit{da}}^\ast},\; \mathsf{exports}~{{\mathit{xi}}^\ast} \}\end{array}`.

#. Let :math:`{{\mathit{funcaddr}}_0^\ast}` be :math:`{{{\mathrm{allocfunc}}^\ast}}{(s, {{{\mathit{dt}}^\ast}{}[x]^\ast}, {(\mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}}_{\mathsf{f}})^\ast}, {{\mathit{moduleinst}}^{{|{{\mathit{func}}^\ast}|}}})}`.

#. Assert: Due to validation, :math:`{{\mathit{funcaddr}}_0^\ast} = {{\mathit{fa}}^\ast}`.

#. Let :math:`{{\mathit{globaladdr}}_0^\ast}` be :math:`{{{\mathrm{allocglobal}}^\ast}}{(s, {{{\mathit{globaltype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}^\ast}, {{\mathit{val}}_{\mathsf{g}}^\ast})}`.

#. Assert: Due to validation, :math:`{{\mathit{globaladdr}}_0^\ast} = {{\mathit{ga}}^\ast}`.

#. Let :math:`{{\mathit{tableaddr}}_0^\ast}` be :math:`{{{\mathrm{alloctable}}^\ast}}{(s, {{{\mathit{tabletype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}^\ast}, {{\mathit{ref}}_{\mathsf{t}}^\ast})}`.

#. Assert: Due to validation, :math:`{{\mathit{tableaddr}}_0^\ast} = {{\mathit{ta}}^\ast}`.

#. Let :math:`{{\mathit{memaddr}}_0^\ast}` be :math:`{{{\mathrm{allocmem}}^\ast}}{(s, {{{\mathit{memtype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}^\ast})}`.

#. Assert: Due to validation, :math:`{{\mathit{memaddr}}_0^\ast} = {{\mathit{ma}}^\ast}`.

#. Let :math:`{{\mathit{tagaddr}}_0^\ast}` be :math:`{{{\mathrm{alloctag}}^\ast}}{(s, {{{\mathit{dt}}^\ast}{}[y]^\ast})}`.

#. Assert: Due to validation, :math:`{{\mathit{tagaddr}}_0^\ast} = {{\mathit{aa}}^\ast}`.

#. Let :math:`{{\mathit{elemaddr}}_0^\ast}` be :math:`{{{\mathrm{allocelem}}^\ast}}{(s, {{{\mathit{elemtype}}}{{}[ {:=}\, {{\mathit{dt}}^\ast} ]}^\ast}, {{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast})}`.

#. Assert: Due to validation, :math:`{{\mathit{elemaddr}}_0^\ast} = {{\mathit{ea}}^\ast}`.

#. Let :math:`{{\mathit{dataaddr}}_0^\ast}` be :math:`{{{\mathrm{allocdata}}^\ast}}{(s, {\mathsf{ok}^{{|{{\mathit{data}}^\ast}|}}}, {{{\mathit{byte}}^\ast}^\ast})}`.

#. Assert: Due to validation, :math:`{{\mathit{dataaddr}}_0^\ast} = {{\mathit{da}}^\ast}`.

#. Return :math:`{\mathit{moduleinst}}`.


:math:`{{\mathrm{runelem}}}_{x}((\mathsf{elem}~{\mathit{rt}}~{e^{n}}~{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}))`
...................................................................................................................................


1. If :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{passive}`, then:

  a. Return :math:`\epsilon`.

#. If :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{declare}`, then:

  a. Return :math:`(\mathsf{elem{.}drop}~x)`.

#. Assert: Due to validation, :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{active}`.

#. Let :math:`(\mathsf{active}~y~{{\mathit{instr}}^\ast})` be :math:`{\mathit{elemmode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{table{.}init}~y~x)~(\mathsf{elem{.}drop}~x)`.


:math:`{{\mathrm{rundata}}}_{x}((\mathsf{data}~{b^{n}}~{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}))`
.....................................................................................................................


1. If :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}} = \mathsf{passive}`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}` is of the case :math:`\mathsf{active}`.

#. Let :math:`(\mathsf{active}~y~{{\mathit{instr}}^\ast})` be :math:`{\mathit{datamode}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}`.

#. Return :math:`{{\mathit{instr}}^\ast}~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~0)~(\mathsf{i{\scriptstyle 32}}{.}\mathsf{const}~n)~(\mathsf{memory{.}init}~y~x)~(\mathsf{data{.}drop}~x)`.


:math:`{{{\mathrm{evalglobal}}^\ast}}{(z, {{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {e_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
...........................................................................................................................................................


1. Let :math:`({\mathsf{frame}}_{}\,\{~z~\})` be the current :math:`\mathsf{frame}` context.

#. If :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon` and :math:`{e_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Return :math:`\epsilon`.

#. Assert: Due to validation, :math:`{|{e_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{expr}}~{{\mathit{expr}'}^\ast}` be :math:`{e_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Assert: Due to validation, :math:`{|{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

#. Let :math:`{\mathit{gt}}~{{\mathit{gt}'}^\ast}` be :math:`{{\mathit{gt}}_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

#. Let :math:`f` be :math:`z`.

#. Let :math:`{\mathit{val}}` be :math:`{\mathrm{eval}}_{\mathit{expr}}({\mathit{expr}})`.

#. Let :math:`a` be :math:`{\mathrm{allocglobal}}(s, {\mathit{gt}}, {\mathit{val}})`.

#. Append :math:`a` to :math:`f{.}\mathsf{module}{.}\mathsf{globals}`.

#. Let :math:`{{\mathit{val}'}^\ast}` be :math:`{{{\mathrm{evalglobal}}^\ast}}{(z, {{\mathit{gt}'}^\ast}, {{\mathit{expr}'}^\ast})}`.

#. Return :math:`{\mathit{val}}~{{\mathit{val}'}^\ast}`.


:math:`{\mathrm{instantiate}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast})`
..................................................................................


1. If :math:`{\mathit{module}}` is not :ref:`valid <valid-val>`, then:

  a. Fail.

#. Let :math:`{{\mathit{xt}}_{\mathsf{i}}^\ast}~\rightarrow~{{\mathit{xt}}_{\mathsf{e}}^\ast}` be the type of :math:`{\mathit{module}}`.

#. Assert: Due to validation, :math:`{\mathit{module}}` is of the case :math:`\mathsf{module}`.

#. Let :math:`(\mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{import}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{global}}^\ast}~{{\mathit{table}}^\ast}~{{\mathit{mem}}^\ast}~{{\mathit{tag}}^\ast}~{{\mathit{elem}}^\ast}~{{\mathit{data}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast})` be :math:`{\mathit{module}}`.

#. If :math:`{|{{\mathit{externaddr}}^\ast}|} \neq {|{{\mathit{xt}}_{\mathsf{i}}^\ast}|}`, then:

  a. Fail.

#. For all :math:`{\mathit{externaddr}}`, and :math:`{\mathit{xt}}_{\mathsf{i}}` in :math:`{({\mathit{externaddr}}, {\mathit{xt}}_{\mathsf{i}})^\ast}`:

  a. If :math:`{\mathit{externaddr}}` is not :ref:`valid <valid-val>` with type :math:`{\mathit{xt}}_{\mathsf{i}}`, then:

    1) Fail.

#. Let :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}` be :math:`{\bigoplus}\, {{{\mathrm{rundata}}}_{i_{\mathsf{d}}}({{\mathit{data}}^\ast}{}[i_{\mathsf{d}}])^{i_{\mathsf{d}}<{|{{\mathit{data}}^\ast}|}}}`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}` be :math:`{\bigoplus}\, {{{\mathrm{runelem}}}_{i_{\mathsf{e}}}({{\mathit{elem}}^\ast}{}[i_{\mathsf{e}}])^{i_{\mathsf{e}}<{|{{\mathit{elem}}^\ast}|}}}`.

#. Assert: Due to validation, for all :math:`{\mathit{start}}` in :math:`{{\mathit{start}}^?}`, :math:`{\mathit{start}}` is of the case :math:`\mathsf{start}`.

#. Let :math:`{(\mathsf{start}~x)^?}` be :math:`{{\mathit{start}}^?}`.

#. Let :math:`{\mathit{moduleinst}}_0` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~{{{\mathrm{alloctype}}^\ast}}{({{\mathit{type}}^\ast})},\; \mathsf{funcs}~{\mathrm{funcs}}({{\mathit{externaddr}}^\ast})~{({|s{.}\mathsf{funcs}|} + i_{\mathsf{f}})^{i_{\mathsf{f}}<{|{{\mathit{func}}^\ast}|}}},\; \mathsf{globals}~{\mathrm{globals}}({{\mathit{externaddr}}^\ast}),\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{tags}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{exports}~\epsilon \}\end{array}`.

#. Assert: Due to validation, for all :math:`{\mathit{data}}` in :math:`{{\mathit{data}}^\ast}`, :math:`{\mathit{data}}` is of the case :math:`\mathsf{data}`.

#. Assert: Due to validation, for all :math:`{\mathit{table}}` in :math:`{{\mathit{table}}^\ast}`, :math:`{\mathit{table}}` is of the case :math:`\mathsf{table}`.

#. Let :math:`{(\mathsf{table}~{\mathit{tabletype}}~{\mathit{expr}}_{\mathsf{t}})^\ast}` be :math:`{{\mathit{table}}^\ast}`.

#. Assert: Due to validation, for all :math:`{\mathit{global}}` in :math:`{{\mathit{global}}^\ast}`, :math:`{\mathit{global}}` is of the case :math:`\mathsf{global}`.

#. Let :math:`{(\mathsf{global}~{\mathit{globaltype}}~{\mathit{expr}}_{\mathsf{g}})^\ast}` be :math:`{{\mathit{global}}^\ast}`.

#. Assert: Due to validation, for all :math:`{\mathit{elem}}` in :math:`{{\mathit{elem}}^\ast}`, :math:`{\mathit{elem}}` is of the case :math:`\mathsf{elem}`.

#. Let :math:`{(\mathsf{elem}~{\mathit{reftype}}~{{\mathit{expr}}_{\mathsf{e}}^\ast}~{\mathit{elemmode}})^\ast}` be :math:`{{\mathit{elem}}^\ast}`.

#. Let :math:`{{\mathit{instr}}_{\mathsf{s}}^?}` be :math:`{(\mathsf{call}~x)^?}`.

#. Let :math:`z` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~\epsilon,\; \mathsf{module}~{\mathit{moduleinst}}_0 \}\end{array}`.

#. Push the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~z~\})` to the stack.

#. Let :math:`{{\mathit{val}}_{\mathsf{g}}^\ast}` be :math:`{{{\mathrm{evalglobal}}^\ast}}{(z, {{\mathit{globaltype}}^\ast}, {{\mathit{expr}}_{\mathsf{g}}^\ast})}`.

#. Pop the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~{z'}~\})` from the stack.

#. Push the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~{z'}~\})` to the stack.

#. Let :math:`{{\mathit{ref}}_{\mathsf{t}}^\ast}` be :math:`{{\mathrm{eval}}_{\mathit{expr}}({\mathit{expr}}_{\mathsf{t}})^\ast}`.

#. Pop the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Push the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~{z'}~\})` to the stack.

#. Let :math:`{{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast}` be :math:`{{{\mathrm{eval}}_{\mathit{expr}}({\mathit{expr}}_{\mathsf{e}})^\ast}^\ast}`.

#. Pop the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Let :math:`{\mathit{moduleinst}}` be :math:`{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externaddr}}^\ast}, {{\mathit{val}}_{\mathsf{g}}^\ast}, {{\mathit{ref}}_{\mathsf{t}}^\ast}, {{{\mathit{ref}}_{\mathsf{e}}^\ast}^\ast})`.

#. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~\epsilon,\; \mathsf{module}~{\mathit{moduleinst}} \}\end{array}`.

#. Push the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~f~\})` to the stack.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{e}}^\ast}`.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{d}}^\ast}`.

#. Execute the sequence :math:`{{\mathit{instr}}_{\mathsf{s}}^?}`.

#. Pop the evaluation context :math:`({\mathsf{frame}}_{0}\,\{~f~\})` from the stack.

#. Return :math:`f{.}\mathsf{module}`.


:math:`{\mathrm{invoke}}(s, {\mathit{funcaddr}}, {{\mathit{val}}^\ast})`
........................................................................


1. Assert: Due to validation, :math:`{\mathrm{expand}}(s{.}\mathsf{funcs}{}[{\mathit{funcaddr}}]{.}\mathsf{type})` is of the case :math:`\mathsf{func}`.

#. Let :math:`(\mathsf{func}~{\mathit{functype}}_0)` be :math:`{\mathrm{expand}}(s{.}\mathsf{funcs}{}[{\mathit{funcaddr}}]{.}\mathsf{type})`.

#. Let :math:`{t_1^\ast}~\rightarrow~{t_2^\ast}` be :math:`{\mathit{functype}}_0`.

#. Let :math:`f` be :math:`\{ \begin{array}[t]{@{}l@{}}\mathsf{locals}~\epsilon,\; \mathsf{module}~\{ \begin{array}[t]{@{}l@{}}\mathsf{types}~\epsilon,\; \mathsf{funcs}~\epsilon,\; \mathsf{globals}~\epsilon,\; \mathsf{tables}~\epsilon,\; \mathsf{mems}~\epsilon,\; \mathsf{tags}~\epsilon,\; \mathsf{elems}~\epsilon,\; \mathsf{datas}~\epsilon,\; \mathsf{exports}~\epsilon \}\end{array} \}\end{array}`.

#. If :math:`{|{t_1^\ast}|} \neq {|{{\mathit{val}}^\ast}|}`, then:

  a. Fail.

#. For all :math:`t_1`, and :math:`{\mathit{val}}` in :math:`{(t_1, {\mathit{val}})^\ast}`:

  a. If :math:`{\mathit{val}}` is not :ref:`valid <valid-val>` with type :math:`t_1`, then:

    1) Fail.

#. Let :math:`k` be :math:`{|{t_2^\ast}|}`.

#. Push the evaluation context :math:`({\mathsf{frame}}_{k}\,\{~f~\})` to the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

#. Push the value :math:`(\mathsf{ref{.}func}~{\mathit{funcaddr}})` to the stack.

#. Execute the instruction :math:`(\mathsf{call\_ref}~s{.}\mathsf{funcs}{}[{\mathit{funcaddr}}]{.}\mathsf{type})`.

#. Pop all values :math:`{{\mathit{val}}^\ast}` from the top of the stack.

#. Pop the evaluation context :math:`({\mathsf{frame}}_{k}\,\{~f~\})` from the stack.

#. Push the values :math:`{{\mathit{val}}^\ast}` to the stack.

#. Pop the values :math:`{{\mathit{val}}^{k}}` from the stack.

#. Return :math:`{{\mathit{val}}^{k}}`.


:math:`{{{\mathrm{allocX}}^\ast}}{({\mathit{TODO}}, {X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}, {Y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast})}`
.........................................................................................................................................................


1. If :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`, then:

  a. Assert: Due to validation, :math:`{Y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast} = \epsilon`.

  #. Return :math:`\epsilon`.

#. Else:

  a. Let :math:`X~{{X'}^\ast}` be :math:`{X_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

  #. Assert: Due to validation, :math:`{|{Y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}|} \geq 1`.

  #. Let :math:`Y~{{Y'}^\ast}` be :math:`{Y_{\mathit{u{\kern-0.1em\scriptstyle 1}}}^\ast}`.

  #. Let :math:`a` be :math:`{\mathrm{allocX}}(s, {\mathit{TODO}}, {\mathit{TODO}}, X, Y)`.

  #. Let :math:`{{a'}^\ast}` be :math:`{{{\mathrm{allocX}}^\ast}}{({\mathit{TODO}}, {{X'}^\ast}, {{Y'}^\ast})}`.

  #. Return :math:`a~{{a'}^\ast}`.


:math:`{\mathit{TODO}}`
.......................


1. Return :math:`0`.


:math:`{\mathrm{eval}}_{\mathit{expr}}({{\mathit{instr}}^\ast})`
................................................................


1. Execute the instruction :math:`{{\mathit{instr}}^\ast}`.

#. Pop the value :math:`{\mathit{val}}` from the stack.

#. Return :math:`{\mathit{val}}`.


== Complete.
watsup 0.4 generator
== Parsing...
== Elaboration...
== IL Validation...
== Running pass sideconditions...
== IL Validation after pass sideconditions...
== Translating to AL...
== Prose Generation...
Untranslated relation Expand: `%~~%`(deftype, comptype)
Untranslated relation Nondefaultable: `|-%NONDEFAULTABLE`valtype
Numtype_ok
- the number type numtype is valid.

Vectype_ok
- the vector type vectype is valid.

Heaptype_ok
- the heap type ht_u1 is valid if:
  - Either:
    - ht_u1 is absheaptype.
  - Or:
    - ht_u1 is (_IDX typeidx).
    - the defined type C.TYPES[typeidx] exists.
    - C.TYPES[typeidx] is dt.
  - Or:
    - ht_u1 is (REC i).
    - the sub type C.RECS[i] exists.
    - C.RECS[i] is st.

Heaptype_ok/abs
- the heap type absheaptype is valid.

Heaptype_ok/typeidx
- the heap type (_IDX typeidx) is valid if:
  - the defined type C.TYPES[typeidx] exists.
  - C.TYPES[typeidx] is dt.

Heaptype_ok/rec
- the heap type (REC i) is valid if:
  - the sub type C.RECS[i] exists.
  - C.RECS[i] is st.

Reftype_ok
- the reference type (REF NULL? heaptype) is valid if:
  - the heap type heaptype is valid.

Valtype_ok
- the value type t_u1 is valid if:
  - Either:
    - t_u1 is numtype.
    - the number type numtype is valid.
  - Or:
    - t_u1 is vectype.
    - the vector type vectype is valid.
  - Or:
    - t_u1 is reftype.
    - the reference type reftype is valid.
  - Or:
    - t_u1 is BOT.

Valtype_ok/num
- the value type numtype is valid if:
  - numtype is valid.

Valtype_ok/vec
- the value type vectype is valid if:
  - vectype is valid.

Valtype_ok/ref
- the value type reftype is valid if:
  - reftype is valid.

Valtype_ok/bot
- the value type BOT is valid.

Resulttype_ok
- the result type t* is valid if:
  - For all t in t*:
    - the value type t is valid.

Instrtype_ok
- the instruction type t_1* ->_ x* t_2* is valid if:
  - the result type t_1* is valid.
  - the result type t_2* is valid.
  - |x*| is |lct*|.
  - For all x in x*:
    - the local type C.LOCALS[x] exists.
  - For all lct in lct* and x in x*:
    - C.LOCALS[x] is lct.

Packtype_ok
- the packed type packtype is valid.

Storagetype_ok
- the storage type zt_u1 is valid if:
  - Either:
    - zt_u1 is valtype.
    - the value type valtype is valid.
  - Or:
    - zt_u1 is packtype.
    - the packed type packtype is valid.

Storagetype_ok/val
- the storage type valtype is valid if:
  - valtype is valid.

Storagetype_ok/pack
- the storage type packtype is valid if:
  - packtype is valid.

Fieldtype_ok
- the field type (MUT?, storagetype) is valid if:
  - the storage type storagetype is valid.

Functype_ok
- the function type t_1* -> t_2* is valid if:
  - the result type t_1* is valid.
  - the result type t_2* is valid.

Comptype_ok
- the composite type ct_u1 is valid if:
  - Either:
    - ct_u1 is (STRUCT fieldtype*).
    - For all fieldtype in fieldtype*:
      - the field type fieldtype is valid.
  - Or:
    - ct_u1 is (ARRAY fieldtype).
    - fieldtype is valid.
  - Or:
    - ct_u1 is (FUNC functype).
    - the function type functype is valid.

Comptype_ok/struct
- the composite type (STRUCT fieldtype*) is valid if:
  - For all fieldtype in fieldtype*:
    - the field type fieldtype is valid.

Comptype_ok/array
- the composite type (ARRAY fieldtype) is valid if:
  - the field type fieldtype is valid.

Comptype_ok/func
- the composite type (FUNC functype) is valid if:
  - the function type functype is valid.

Packtype_sub
- the packed type packtype matches itself.

Numtype_sub
- the number type numtype matches itself.

Deftype_sub
- the defined type deftype_1 matches the defined type deftype_2 if:
  - Either:
    - the defined type $clos_deftype(C, deftype_1) is $clos_deftype(C, deftype_2).
  - Or:
    - the sub type $unrolldt(deftype_1) is (SUB fin typeuse* ct).
    - |typeuse*| is greater than i.
    - the type use typeuse*[i] matches deftype_2.

Deftype_sub/refl
- the defined type deftype_1 matches the defined type deftype_2 if:
  - the defined type $clos_deftype(C, deftype_1) is $clos_deftype(C, deftype_2).

Deftype_sub/super
- the defined type deftype_1 matches the defined type deftype_2 if:
  - the sub type $unrolldt(deftype_1) is (SUB fin typeuse* ct).
  - |typeuse*| is greater than i.
  - the type use typeuse*[i] matches deftype_2.

Heaptype_sub
- the heap type ht_u1 matches the heap type ht_u2 if:
  - Either:
    - ht_u1 is heaptype.
    - ht_u2 is heaptype.
  - Or:
    - ht_u1 is heaptype_1.
    - ht_u2 is heaptype_2.
    - the heap type heaptype' is valid.
    - the heap type heaptype_1 matches heaptype'.
    - heaptype' matches the heap type heaptype_2.
  - Or:
    - ht_u1 is EQ.
    - ht_u2 is ANY.
  - Or:
    - ht_u1 is I31.
    - ht_u2 is EQ.
  - Or:
    - ht_u1 is STRUCT.
    - ht_u2 is EQ.
  - Or:
    - ht_u1 is ARRAY.
    - ht_u2 is EQ.
  - Or:
    - ht_u1 is deftype.
    - ht_u2 is STRUCT.
    - The :ref:`expansion <aux-expand-deftype>` of the defined type deftype is the composite type (STRUCT fieldtype*).
  - Or:
    - ht_u1 is deftype.
    - ht_u2 is ARRAY.
    - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (ARRAY fieldtype).
  - Or:
    - ht_u1 is deftype.
    - ht_u2 is FUNC.
    - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (FUNC functype).
  - Or:
    - ht_u1 is deftype_1.
    - ht_u2 is deftype_2.
    - the defined type deftype_1 matches the defined type deftype_2.
  - Or:
    - ht_u1 is (_IDX typeidx).
    - ht_u2 is heaptype.
    - the defined type C.TYPES[typeidx] exists.
    - C.TYPES[typeidx] matches the heap type heaptype.
  - Or:
    - ht_u1 is heaptype.
    - ht_u2 is (_IDX typeidx).
    - C.TYPES[typeidx] exists.
    - heaptype matches C.TYPES[typeidx].
  - Or:
    - ht_u1 is (REC i).
    - ht_u2 is typeuse*[j].
    - |typeuse*| is greater than j.
    - the sub type C.RECS[i] exists.
    - C.RECS[i] is (SUB fin typeuse* ct).
  - Or:
    - ht_u1 is NONE.
    - ht_u2 is heaptype.
    - heaptype matches the heap type ANY.
  - Or:
    - ht_u1 is NOFUNC.
    - ht_u2 is heaptype.
    - heaptype matches the heap type FUNC.
  - Or:
    - ht_u1 is NOEXTERN.
    - ht_u2 is heaptype.
    - heaptype matches the heap type EXTERN.
  - Or:
    - ht_u1 is BOT.
    - ht_u2 is heaptype.

Heaptype_sub/refl
- heaptype matches itself.

Heaptype_sub/trans
- the heap type heaptype_1 matches the heap type heaptype_2 if:
  - the heap type heaptype' is valid.
  - heaptype_1 matches heaptype'.
  - heaptype' matches heaptype_2.

Heaptype_sub/eq
- the heap type EQ matches the heap type ANY.

Heaptype_sub/i31
- the heap type I31 matches EQ.

Heaptype_sub/struct
- the heap type STRUCT matches EQ.

Heaptype_sub/array
- the heap type ARRAY matches EQ.

Heaptype_sub/struct
- the heap type deftype matches the heap type STRUCT if:
  - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (STRUCT fieldtype*).

Heaptype_sub/array
- the heap type deftype matches the heap type ARRAY if:
  - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (ARRAY fieldtype).

Heaptype_sub/func
- the heap type deftype matches the heap type FUNC if:
  - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (FUNC functype).

Heaptype_sub/def
- the heap type deftype_1 matches the heap type deftype_2 if:
  - deftype_1 matches deftype_2.

Heaptype_sub/typeidx
- the heap type (_IDX typeidx) matches the heap type heaptype if:
  - the defined type C.TYPES[typeidx] exists.
  - C.TYPES[typeidx] matches heaptype.

Heaptype_sub/typeidx
- the heap type heaptype matches the heap type (_IDX typeidx) if:
  - the defined type C.TYPES[typeidx] exists.
  - heaptype matches C.TYPES[typeidx].

Heaptype_sub/rec
- the heap type (REC i) matches the type use typeuse*[j] if:
  - |typeuse*| is greater than j.
  - the sub type C.RECS[i] exists.
  - C.RECS[i] is (SUB fin typeuse* ct).

Heaptype_sub/none
- the heap type NONE matches the heap type heaptype if:
  - heaptype matches the heap type ANY.

Heaptype_sub/nofunc
- the heap type NOFUNC matches the heap type heaptype if:
  - heaptype matches the heap type FUNC.

Heaptype_sub/noextern
- the heap type NOEXTERN matches the heap type heaptype if:
  - heaptype matches the heap type EXTERN.

Heaptype_sub/bot
- the heap type BOT matches heaptype.

Reftype_sub
- the reference type (REF nul_u1 ht_1) matches the reference type (REF nul_u2 ht_2) if:
  - the heap type ht_1 matches the heap type ht_2.
  - Either:
    - nul_u1 is ?().
    - nul_u2 is ?().
  - Or:
    - nul_u1 is NULL?.
    - nul_u2 is ?(NULL).

Reftype_sub/nonnull
- the reference type (REF ?() ht_1) matches the reference type (REF ?() ht_2) if:
  - the heap type ht_1 matches the heap type ht_2.

Reftype_sub/null
- the reference type (REF NULL? ht_1) matches the reference type (REF ?(NULL) ht_2) if:
  - the heap type ht_1 matches the heap type ht_2.

Vectype_sub
- the vector type vectype matches itself.

Valtype_sub
- the value type t_u1 matches the value type t_u2 if:
  - Either:
    - t_u1 is numtype_1.
    - t_u2 is numtype_2.
    - the number type numtype_1 matches the number type numtype_2.
  - Or:
    - t_u1 is vectype_1.
    - t_u2 is vectype_2.
    - the vector type vectype_1 matches the vector type vectype_2.
  - Or:
    - t_u1 is reftype_1.
    - t_u2 is reftype_2.
    - the reference type reftype_1 matches the reference type reftype_2.
  - Or:
    - t_u1 is BOT.
    - t_u2 is valtype.

Valtype_sub/num
- the value type numtype_1 matches the value type numtype_2 if:
  - numtype_1 matches numtype_2.

Valtype_sub/vec
- the value type vectype_1 matches the value type vectype_2 if:
  - vectype_1 matches vectype_2.

Valtype_sub/ref
- the value type reftype_1 matches the value type reftype_2 if:
  - reftype_1 matches reftype_2.

Valtype_sub/bot
- the value type BOT matches the value type valtype.

Storagetype_sub
- the storage type zt_u1 matches the storage type zt_u2 if:
  - Either:
    - zt_u1 is valtype_1.
    - zt_u2 is valtype_2.
    - the value type valtype_1 matches the value type valtype_2.
  - Or:
    - zt_u1 is packtype_1.
    - zt_u2 is packtype_2.
    - the packed type packtype_1 matches the packed type packtype_2.

Storagetype_sub/val
- the storage type valtype_1 matches the storage type valtype_2 if:
  - valtype_1 matches valtype_2.

Storagetype_sub/pack
- the storage type packtype_1 matches the storage type packtype_2 if:
  - packtype_1 matches packtype_2.

Fieldtype_sub
- the field type (mut_u1, zt_1) matches the field type (mut_u2, zt_2) if:
  - the storage type zt_1 matches the storage type zt_2.
  - Either:
    - mut_u1 is ?().
    - mut_u2 is ?().
  - Or:
    - mut_u1 is ?(MUT).
    - mut_u2 is ?(MUT).
    - zt_2 matches zt_1.

Fieldtype_sub/const
- the field type (?(), zt_1) matches the field type (?(), zt_2) if:
  - the storage type zt_1 matches the storage type zt_2.

Fieldtype_sub/var
- the field type (?(MUT), zt_1) matches the field type (?(MUT), zt_2) if:
  - the storage type zt_1 matches the storage type zt_2.
  - zt_2 matches zt_1.

Resulttype_sub
- the value type sequence t_1* matches the value type sequence t_2* if:
  - |t_2*| is |t_1*|.
  - For all t_1 in t_1* and t_2 in t_2*:
    - the value type t_1 matches the value type t_2.

Functype_sub
- the function type t_11* -> t_12* matches the function type t_21* -> t_22* if:
  - the value type sequence t_21* matches the value type sequence t_11*.
  - the value type sequence t_12* matches the value type sequence t_22*.

Comptype_sub
- the composite type ct_u1 matches the composite type ct_u2 if:
  - Either:
    - ct_u1 is (STRUCT yt_1* :: [yt'_1]).
    - ct_u2 is (STRUCT yt_2*).
    - |yt_2*| is |yt_1*|.
    - For all yt_1 in yt_1* and yt_2 in yt_2*:
      - the field type yt_1 matches the field type yt_2.
  - Or:
    - ct_u1 is (ARRAY yt_1).
    - ct_u2 is (ARRAY yt_2).
    - yt_1 matches yt_2.
  - Or:
    - ct_u1 is (FUNC ft_1).
    - ct_u2 is (FUNC ft_2).
    - the function type ft_1 matches the function type ft_2.

Comptype_sub/struct
- the composite type (STRUCT yt_1* :: [yt'_1]) matches the composite type (STRUCT yt_2*) if:
  - |yt_2*| is |yt_1*|.
  - For all yt_1 in yt_1* and yt_2 in yt_2*:
    - the field type yt_1 matches the field type yt_2.

Comptype_sub/array
- the composite type (ARRAY yt_1) matches the composite type (ARRAY yt_2) if:
  - the field type yt_1 matches the field type yt_2.

Comptype_sub/func
- the composite type (FUNC ft_1) matches the composite type (FUNC ft_2) if:
  - the function type ft_1 matches the function type ft_2.

Subtype_ok
- the sub type (SUB FINAL? (_IDX x)* comptype) is valid with (OK x_0) if:
  - |x*| is less than or equal to 1.
  - For all x in x*:
    - the index x is less than x_0.
  - |x*| is |comptype'*|.
  - |x'**| is |comptype'*|.
  - For all x in x*:
    - the defined type C.TYPES[x] exists.
  - For all comptype' in comptype'* and x in x* and x'* in x'**:
    - the sub type $unrolldt(C.TYPES[x]) is (SUB ?() (_IDX x')* comptype').
  - the composite type comptype is valid.
  - For all comptype' in comptype'*:
    - comptype matches the composite type comptype'.

Subtype_ok2
- the sub type (SUB FINAL? typeuse* compttype) is valid with (OK x i) if:
  - |typeuse*| is less than or equal to 1.
  - For all typeuse in typeuse*:
    - $before(typeuse, x, i) is true.
  - |typeuse*| is |comptype'*|.
  - |typeuse'**| is |comptype'*|.
  - For all comptype' in comptype'* and typeuse in typeuse* and typeuse'* in typeuse'**:
    - the sub type $unrollht(C, typeuse) is (SUB ?() typeuse'* comptype').
  - the composite type comptype is valid.
  - For all comptype' in comptype'*:
    - comptype matches the composite type comptype'.

Rectype_ok2
- the recursive type (REC st_u1*) is valid with (OK x i) if:
  - Either:
    - the sub type sequence st_u1* is [].
  - Or:
    - st_u1* is [subtype_1] :: subtype*.
    - the sub type subtype_1 is valid with (OK x i).
    - the recursive type (REC subtype*) is valid with (OK (x + 1) (i + 1)).

Rectype_ok2/empty
- the recursive type (REC []) is valid with (OK x i).

Rectype_ok2/cons
- the recursive type (REC [subtype_1] :: subtype*) is valid with (OK x i) if:
  - the sub type subtype_1 is valid with (OK x i).
  - the recursive type (REC subtype*) is valid with (OK (x + 1) (i + 1)).

Rectype_ok
- the recursive type (REC st_u1*) is valid with (OK x) if:
  - Either:
    - the sub type sequence st_u1* is [].
  - Or:
    - st_u1* is [subtype_1] :: subtype*.
    - the sub type subtype_1 is valid with (OK x).
    - the recursive type (REC subtype*) is valid with (OK (x + 1)).
  - Or:
    - st_u1* is subtype*.
    - the context C' is the context C with .RECS prepended by subtype*.
    - Under the context C', (REC subtype*) is valid with (OK x 0).

Rectype_ok/empty
- the recursive type (REC []) is valid with (OK x).

Rectype_ok/cons
- the recursive type (REC [subtype_1] :: subtype*) is valid with (OK x) if:
  - the sub type subtype_1 is valid with (OK x).
  - the recursive type (REC subtype*) is valid with (OK (x + 1)).

Rectype_ok/rec2
- the recursive type (REC subtype*) is valid with (OK x) if:
  - the context C' is the context C with .RECS prepended by subtype*.
  - Under the context C', (REC subtype*) is valid with (OK x 0).

Deftype_ok
- the defined type (DEF rectype i) is valid if:
  - the recursive type rectype is valid with (OK x).
  - rectype is (REC subtype^n).
  - i is less than n.

Limits_ok
- the limits ([ n .. m ]) is valid with k if:
  - n is less than or equal to m.
  - m is less than or equal to k.

Globaltype_ok
- the global type (MUT?, t) is valid if:
  - the value type t is valid.

Tabletype_ok
- the table type (addrtype, limits, reftype) is valid if:
  - the limits limits is valid with ((2 ^ 32) - 1).
  - the reference type reftype is valid.

Memtype_ok
- the memory type addrtype limits PAGE is valid if:
  - the limits limits is valid with (2 ^ 16).

Tagtype_ok
- the tag type deftype is valid if:
  - deftype is valid.
  - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (FUNC functype).

Externtype_ok
- the external type xt_u1 is valid if:
  - Either:
    - xt_u1 is (FUNC deftype).
    - the defined type deftype is valid.
    - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (FUNC functype).
  - Or:
    - xt_u1 is (GLOBAL globaltype).
    - the global type globaltype is valid.
  - Or:
    - xt_u1 is (TABLE tabletype).
    - the table type tabletype is valid.
  - Or:
    - xt_u1 is (MEM memtype).
    - the memory type memtype is valid.
  - Or:
    - xt_u1 is (TAG tagtype).
    - the tag type tagtype is valid.

Externtype_ok/func
- the external type (FUNC deftype) is valid if:
  - the defined type deftype is valid.
  - The :ref:`expansion <aux-expand-deftype>` of deftype is the composite type (FUNC functype).

Externtype_ok/global
- the external type (GLOBAL globaltype) is valid if:
  - the global type globaltype is valid.

Externtype_ok/table
- the external type (TABLE tabletype) is valid if:
  - the table type tabletype is valid.

Externtype_ok/mem
- the external type (MEM memtype) is valid if:
  - the memory type memtype is valid.

Externtype_ok/tag
- the external type (TAG tagtype) is valid if:
  - the tag type tagtype is valid.

Instrtype_sub
- the instruction type t_11* ->_ x_1* t_12* matches the instruction type t_21* ->_ x_2* t_22* if:
  - the value type sequence t_21* matches the value type sequence t_11*.
  - the value type sequence t_12* matches the value type sequence t_22*.
  - the local index sequence x* is $setminus_(localidx, x_2*, x_1*).
  - |x*| is |t*|.
  - For all x in x*:
    - the local type C.LOCALS[x] exists.
  - For all t in t* and x in x*:
    - C.LOCALS[x] is (SET, t).

Limits_sub
- the limits ([ n_1 .. m_1 ]) matches the limits ([ n_2 .. m_2 ]) if:
  - n_1 is greater than or equal to n_2.
  - m_1 is less than or equal to m_2.

Globaltype_sub
- the global type (mut_u1, valtype_1) matches the global type (mut_u2, valtype_2) if:
  - the value type valtype_1 matches the value type valtype_2.
  - Either:
    - mut_u1 is ?().
    - mut_u2 is ?().
  - Or:
    - mut_u1 is ?(MUT).
    - mut_u2 is ?(MUT).
    - valtype_2 matches valtype_1.

Globaltype_sub/const
- the global type (?(), valtype_1) matches the global type (?(), valtype_2) if:
  - the value type valtype_1 matches the value type valtype_2.

Globaltype_sub/var
- the global type (?(MUT), valtype_1) matches the global type (?(MUT), valtype_2) if:
  - the value type valtype_1 matches the value type valtype_2.
  - valtype_2 matches valtype_1.

Tabletype_sub
- the table type (addrtype, limits_1, reftype_1) matches the table type (addrtype, limits_2, reftype_2) if:
  - the limits limits_1 matches the limits limits_2.
  - the reference type reftype_1 matches the reference type reftype_2.
  - reftype_2 matches reftype_1.

Memtype_sub
- the memory type addrtype limits_1 PAGE matches the memory type addrtype limits_2 PAGE if:
  - the limits limits_1 matches the limits limits_2.

Tagtype_sub
- the tag type deftype_1 matches the tag type deftype_2 if:
  - deftype_1 matches deftype_2.
  - deftype_2 matches deftype_1.

Externtype_sub
- the external type xt_u1 matches the external type xt_u2 if:
  - Either:
    - xt_u1 is (FUNC deftype_1).
    - xt_u2 is (FUNC deftype_2).
    - the defined type deftype_1 matches the defined type deftype_2.
  - Or:
    - xt_u1 is (GLOBAL globaltype_1).
    - xt_u2 is (GLOBAL globaltype_2).
    - the global type globaltype_1 matches the global type globaltype_2.
  - Or:
    - xt_u1 is (TABLE tabletype_1).
    - xt_u2 is (TABLE tabletype_2).
    - the table type tabletype_1 matches the table type tabletype_2.
  - Or:
    - xt_u1 is (MEM memtype_1).
    - xt_u2 is (MEM memtype_2).
    - the memory type memtype_1 matches the memory type memtype_2.
  - Or:
    - xt_u1 is (TAG tagtype_1).
    - xt_u2 is (TAG tagtype_2).
    - the tag type tagtype_1 matches the tag type tagtype_2.

Externtype_sub/func
- the external type (FUNC deftype_1) matches the external type (FUNC deftype_2) if:
  - the defined type deftype_1 matches the defined type deftype_2.

Externtype_sub/global
- the external type (GLOBAL globaltype_1) matches the external type (GLOBAL globaltype_2) if:
  - the global type globaltype_1 matches the global type globaltype_2.

Externtype_sub/table
- the external type (TABLE tabletype_1) matches the external type (TABLE tabletype_2) if:
  - the table type tabletype_1 matches the table type tabletype_2.

Externtype_sub/mem
- the external type (MEM memtype_1) matches the external type (MEM memtype_2) if:
  - the memory type memtype_1 matches the memory type memtype_2.

Externtype_sub/tag
- the external type (TAG tagtype_1) matches the external type (TAG tagtype_2) if:
  - the tag type tagtype_1 matches the tag type tagtype_2.

Blocktype_ok
- the block type bt_u1 is valid with the instruction type t_u1* -> t_u2* if:
  - Either:
    - bt_u1 is (_RESULT valtype?).
    - the value type sequence t_u1* is [].
    - the value type sequence t_u2* is valtype?.
    - If valtype is defined, then:
      - the value type valtype is valid.
  - Or:
    - bt_u1 is (_IDX typeidx).
    - t_u1* is t_1*.
    - t_u2* is t_2*.
    - the defined type C.TYPES[typeidx] exists.
    - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[typeidx] is the composite type (FUNC t_1* -> t_2*).

Blocktype_ok/valtype
- the block type (_RESULT valtype?) is valid with the instruction type [] -> valtype? if:
  - If valtype is defined, then:
    - the value type valtype is valid.

Blocktype_ok/typeidx
- the block type (_IDX typeidx) is valid with the instruction type t_1* -> t_2* if:
  - the defined type C.TYPES[typeidx] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[typeidx] is the composite type (FUNC t_1* -> t_2*).

Catch_ok
- the catch clause catch_u1 is valid if:
  - the result type C.LABELS[l] exists.
  - Either:
    - catch_u1 is (CATCH x l).
    - the tag type C.TAGS[x] exists.
    - The :ref:`expansion <aux-expand-deftype>` of C.TAGS[x] is the composite type (FUNC t* -> []).
    - the value type sequence t* matches C.LABELS[l].
  - Or:
    - catch_u1 is (CATCH_REF x l).
    - C.TAGS[x] exists.
    - The :ref:`expansion <aux-expand-deftype>` of C.TAGS[x] is (FUNC t* -> []).
    - the value type sequence t* :: [(REF ?() EXN)] matches C.LABELS[l].
  - Or:
    - catch_u1 is (CATCH_ALL l).
    - the value type sequence [] matches C.LABELS[l].
  - Or:
    - catch_u1 is (CATCH_ALL_REF l).
    - the value type sequence [(REF ?() EXN)] matches C.LABELS[l].

Catch_ok/catch
- the catch clause (CATCH x l) is valid if:
  - the tag type C.TAGS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TAGS[x] is the composite type (FUNC t* -> []).
  - the result type C.LABELS[l] exists.
  - the value type sequence t* matches C.LABELS[l].

Catch_ok/catch_ref
- the catch clause (CATCH_REF x l) is valid if:
  - the tag type C.TAGS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TAGS[x] is the composite type (FUNC t* -> []).
  - the result type C.LABELS[l] exists.
  - the value type sequence t* :: [(REF ?() EXN)] matches C.LABELS[l].

Catch_ok/catch_all
- the catch clause (CATCH_ALL l) is valid if:
  - the result type C.LABELS[l] exists.
  - the value type sequence [] matches C.LABELS[l].

Catch_ok/catch_all_ref
- the catch clause (CATCH_ALL_REF l) is valid if:
  - the result type C.LABELS[l] exists.
  - the value type sequence [(REF ?() EXN)] matches C.LABELS[l].

Defaultable
- the value type t is defaultable if:
  - the value $default_(t) is different from ?().

Instr_ok/nop
- the instruction NOP is valid with the instruction type [] -> [].

Instr_ok/unreachable
- the instruction UNREACHABLE is valid with the instruction type t_1* -> t_2* if:
  - t_1* -> t_2* is valid.

Instr_ok/drop
- the instruction DROP is valid with the instruction type [t] -> [] if:
  - the value type t is valid.

Instr_ok/select
- the instruction (SELECT t_u1?) is valid with the instruction type [t, t, I32] -> [t] if:
  - the value type t is valid.
  - Either:
    - the value type sequence t_u1? is ?([t]).
  - Or:
    - t_u1? is ?().
    - t matches the value type t'.
    - t' is numtype or t' is vectype.

Instr_ok/block
- the instruction (BLOCK bt instr*) is valid with the instruction type t_1* -> t_2* if:
  - the block type bt is valid with t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr* is valid with the instruction type t_1* ->_ x* t_2*.

Instr_ok/loop
- the instruction (LOOP bt instr*) is valid with the instruction type t_1* -> t_2* if:
  - the block type bt is valid with t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_1*].
  - Under the context C', the instruction sequence instr* is valid with the instruction type t_1* ->_ x* t_2*.

Instr_ok/if
- the instruction (IF bt instr_1* ELSE instr_2*) is valid with the instruction type t_1* :: [I32] -> t_2* if:
  - the block type bt is valid with the instruction type t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr_1* is valid with the instruction type t_1* ->_ x_1* t_2*.
  - Under the context C', the instruction sequence instr_2* is valid with the instruction type t_1* ->_ x_2* t_2*.

Instr_ok/br
- the instruction (BR l) is valid with the instruction type t_1* :: t* -> t_2* if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t*.
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/br_if
- the instruction (BR_IF l) is valid with the instruction type t* :: [I32] -> t* if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t*.

Instr_ok/br_table
- the instruction (BR_TABLE l* l') is valid with the instruction type t_1* :: t* :: [I32] -> t_2* if:
  - For all l in l*:
    - the result type C.LABELS[l] exists.
  - For all l in l*:
    - the value type sequence t* matches C.LABELS[l].
  - the result type C.LABELS[l'] exists.
  - t* matches C.LABELS[l'].
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/br_on_null
- the instruction (BR_ON_NULL l) is valid with the instruction type t* :: [(REF ?(NULL) ht)] -> t* :: [(REF ?() ht)] if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t*.
  - the heap type ht is valid.

Instr_ok/br_on_non_null
- the instruction (BR_ON_NON_NULL l) is valid with the instruction type t* :: [(REF ?(NULL) ht)] -> t* if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t* :: [(REF ?() ht)].

Instr_ok/br_on_cast
- the instruction (BR_ON_CAST l rt_1 rt_2) is valid with the instruction type t* :: [rt_1] -> t* :: [t'] if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t* :: [rt].
  - the reference type rt_1 is valid.
  - the reference type rt_2 is valid.
  - rt_2 matches rt_1.
  - rt_2 matches the reference type rt.
  - Let t' be the reference type $diffrt(rt_1, rt_2).

Instr_ok/br_on_cast_fail
- the instruction (BR_ON_CAST_FAIL l rt_1 rt_2) is valid with the instruction type t* :: [rt_1] -> t* :: [rt_2] if:
  - the result type C.LABELS[l] exists.
  - C.LABELS[l] is t* :: [rt].
  - the reference type rt_1 is valid.
  - the reference type rt_2 is valid.
  - rt_2 matches rt_1.
  - the reference type $diffrt(rt_1, rt_2) matches the reference type rt.

Instr_ok/call
- the instruction (CALL x) is valid with the instruction type t_1* -> t_2* if:
  - the defined type C.FUNCS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.FUNCS[x] is the composite type (FUNC t_1* -> t_2*).

Instr_ok/call_ref
- the instruction (CALL_REF (_IDX x)) is valid with the instruction type t_1* :: [(REF ?(NULL) (_IDX x))] -> t_2* if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (FUNC t_1* -> t_2*).

Instr_ok/call_indirect
- the instruction (CALL_INDIRECT x (_IDX y)) is valid with the instruction type t_1* :: [at] -> t_2* if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (at, lim, rt).
  - the reference type rt matches the reference type (REF ?(NULL) FUNC).
  - the defined type C.TYPES[y] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[y] is the composite type (FUNC t_1* -> t_2*).

Instr_ok/return
- the instruction RETURN is valid with the instruction type t_1* :: t* -> t_2* if:
  - the result type C.RETURN is ?(t*).
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/return_call
- the instruction (RETURN_CALL x) is valid with the instruction type t_3* :: t_1* -> t_4* if:
  - the defined type C.FUNCS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.FUNCS[x] is the composite type (FUNC t_1* -> t_2*).
  - the result type C.RETURN is ?(t'_2*).
  - the value type sequence t_2* matches the value type sequence t'_2*.
  - the instruction type t_3* -> t_4* is valid.

Instr_ok/return_call_ref
- the instruction (RETURN_CALL_REF (_IDX x)) is valid with the instruction type t_3* :: t_1* :: [(REF ?(NULL) (_IDX x))] -> t_4* if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (FUNC t_1* -> t_2*).
  - the result type C.RETURN is ?(t'_2*).
  - the value type sequence t_2* matches the value type sequence t'_2*.
  - the instruction type t_3* -> t_4* is valid.

Instr_ok/return_call_indirect
- the instruction (RETURN_CALL_INDIRECT x (_IDX y)) is valid with the instruction type t_3* :: t_1* :: [at] -> t_4* if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (at, lim, rt).
  - the reference type rt matches the reference type (REF ?(NULL) FUNC).
  - the defined type C.TYPES[y] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[y] is the composite type (FUNC t_1* -> t_2*).
  - the result type C.RETURN is ?(t'_2*).
  - the value type sequence t_2* matches the value type sequence t'_2*.
  - the instruction type t_3* -> t_4* is valid.

Instr_ok/throw
- the instruction (THROW x) is valid with the instruction type t_1* :: t* -> t_2* if:
  - the tag type C.TAGS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TAGS[x] is the composite type (FUNC t* -> []).
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/throw_ref
- the instruction THROW_REF is valid with the instruction type t_1* :: [(REF ?(NULL) EXN)] -> t_2* if:
  - the instruction type t_1* -> t_2* is valid.

Instr_ok/try_table
- the instruction (TRY_TABLE bt catch* instr*) is valid with the instruction type t_1* -> t_2* if:
  - the block type bt is valid with t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr* is valid with the instruction type t_1* ->_ x* t_2*.
  - For all catch in catch*:
    - the catch clause catch is valid.

Instr_ok/const
- the instruction (nt.CONST c_nt) is valid with the instruction type [] -> [nt].

Instr_ok/unop
- the instruction (UNOP nt unop_nt) is valid with the instruction type [nt] -> [nt].

Instr_ok/binop
- the instruction (BINOP nt binop_nt) is valid with the instruction type [nt, nt] -> [nt].

Instr_ok/testop
- the instruction (TESTOP nt testop_nt) is valid with the instruction type [nt] -> [I32].

Instr_ok/relop
- the instruction (RELOP nt relop_nt) is valid with the instruction type [nt, nt] -> [I32].

Instr_ok/cvtop
- the instruction (CVTOP nt_1 nt_2 cvtop) is valid with the instruction type [nt_2] -> [nt_1].

Instr_ok/ref.null
- the instruction (REF.NULL ht) is valid with the instruction type [] -> [(REF ?(NULL) ht)] if:
  - the heap type ht is valid.

Instr_ok/ref.func
- the instruction (REF.FUNC x) is valid with the instruction type [] -> [(REF ?() dt)] if:
  - the defined type C.FUNCS[x] exists.
  - C.FUNCS[x] is dt.
  - the index C.REFS[0] exists.
  - x is contained in C.REFS.

Instr_ok/ref.i31
- the instruction REF.I31 is valid with the instruction type [I32] -> [(REF ?() I31)].

Instr_ok/ref.is_null
- the instruction REF.IS_NULL is valid with the instruction type [(REF ?(NULL) ht)] -> [I32] if:
  - the heap type ht is valid.

Instr_ok/ref.as_non_null
- the instruction REF.AS_NON_NULL is valid with the instruction type [(REF ?(NULL) ht)] -> [(REF ?() ht)] if:
  - the heap type ht is valid.

Instr_ok/ref.eq
- the instruction REF.EQ is valid with the instruction type [(REF ?(NULL) EQ), (REF ?(NULL) EQ)] -> [I32].

Instr_ok/ref.test
- the instruction (REF.TEST rt) is valid with the instruction type [rt'] -> [I32] if:
  - the reference type rt is valid.
  - the reference type rt' is valid.
  - rt matches rt'.

Instr_ok/ref.cast
- the instruction (REF.CAST rt) is valid with the instruction type [rt'] -> [rt] if:
  - the reference type rt is valid.
  - the reference type rt' is valid.
  - rt matches rt'.

Instr_ok/i31.get
- the instruction (I31.GET sx) is valid with the instruction type [(REF ?(NULL) I31)] -> [I32].

Instr_ok/struct.new
- the instruction (STRUCT.NEW x) is valid with the instruction type t* -> [(REF ?() (_IDX x))] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (STRUCT (mut, zt)*).
  - Let t* be the value type sequence $unpack(zt)*.

Instr_ok/struct.new_default
- the instruction (STRUCT.NEW_DEFAULT x) is valid with the instruction type [] -> [(REF ?() (_IDX x))] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (STRUCT (mut, zt)*).
  - For all zt in zt*:
    - A :ref:`default value <default-val>` for value type the value type $unpack(zt) is defined.

Instr_ok/struct.get
- the instruction (STRUCT.GET sx? x i) is valid with the instruction type [(REF ?(NULL) (_IDX x))] -> [t] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (STRUCT yt*).
  - |yt*| is greater than i.
  - the field type yt*[i] is (mut, zt).
  - the signedness sx? is ?() if and only if the storage type zt is $unpack(zt).
  - Let t be the value type $unpack(zt).

Instr_ok/struct.set
- the instruction (STRUCT.SET x i) is valid with the instruction type [(REF ?(NULL) (_IDX x)), t] -> [] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (STRUCT yt*).
  - |yt*| is greater than i.
  - the field type yt*[i] is (?(MUT), zt).
  - Let t be the value type $unpack(zt).

Instr_ok/array.new
- the instruction (ARRAY.NEW x) is valid with the instruction type [t, I32] -> [(REF ?() (_IDX x))] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (mut, zt)).
  - Let t be the value type $unpack(zt).

Instr_ok/array.new_default
- the instruction (ARRAY.NEW_DEFAULT x) is valid with the instruction type [I32] -> [(REF ?() (_IDX x))] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (mut, zt)).
  - A :ref:`default value <default-val>` for value type the value type $unpack(zt) is defined.

Instr_ok/array.new_fixed
- the instruction (ARRAY.NEW_FIXED x n) is valid with the instruction type t^n -> [(REF ?() (_IDX x))] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (mut, zt)).
  - Let t be the value type $unpack(zt).

Instr_ok/array.new_elem
- the instruction (ARRAY.NEW_ELEM x y) is valid with the instruction type [I32, I32] -> [(REF ?() (_IDX x))] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (mut, rt)).
  - the element type C.ELEMS[y] exists.
  - C.ELEMS[y] matches the reference type rt.

Instr_ok/array.new_data
- the instruction (ARRAY.NEW_DATA x y) is valid with the instruction type [I32, I32] -> [(REF ?() (_IDX x))] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (mut, zt)).
  - $unpack(zt) is numtype or the value type $unpack(zt) is vectype.
  - the data type C.DATAS[y] exists.
  - C.DATAS[y] is OK.

Instr_ok/array.get
- the instruction (ARRAY.GET sx? x) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32] -> [t] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (mut, zt)).
  - the signedness sx? is ?() if and only if the storage type zt is $unpack(zt).
  - Let t be the value type $unpack(zt).

Instr_ok/array.set
- the instruction (ARRAY.SET x) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32, t] -> [] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (?(MUT), zt)).
  - Let t be the value type $unpack(zt).

Instr_ok/array.len
- the instruction ARRAY.LEN is valid with the instruction type [(REF ?(NULL) ARRAY)] -> [I32].

Instr_ok/array.fill
- the instruction (ARRAY.FILL x) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32, t, I32] -> [] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (?(MUT), zt)).
  - Let t be the value type $unpack(zt).

Instr_ok/array.copy
- the instruction (ARRAY.COPY x_1 x_2) is valid with the instruction type [(REF ?(NULL) (_IDX x_1)), I32, (REF ?(NULL) (_IDX x_2)), I32, I32] -> [] if:
  - the defined type C.TYPES[x_1] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x_1] is the composite type (ARRAY (?(MUT), zt_1)).
  - the defined type C.TYPES[x_2] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x_2] is the composite type (ARRAY (mut, zt_2)).
  - the storage type zt_2 matches the storage type zt_1.

Instr_ok/array.init_elem
- the instruction (ARRAY.INIT_ELEM x y) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32, I32, I32] -> [] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (?(MUT), zt)).
  - the element type C.ELEMS[y] exists.
  - C.ELEMS[y] matches the storage type zt.

Instr_ok/array.init_data
- the instruction (ARRAY.INIT_DATA x y) is valid with the instruction type [(REF ?(NULL) (_IDX x)), I32, I32, I32] -> [] if:
  - the defined type C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (ARRAY (?(MUT), zt)).
  - $unpack(zt) is numtype or the value type $unpack(zt) is vectype.
  - the data type C.DATAS[y] exists.
  - C.DATAS[y] is OK.

Instr_ok/extern.convert_any
- the instruction EXTERN.CONVERT_ANY is valid with the instruction type [(REF nul1 ANY)] -> [(REF nul2 EXTERN)] if:
  - nul1 is nul2.

Instr_ok/any.convert_extern
- the instruction ANY.CONVERT_EXTERN is valid with the instruction type [(REF nul1 EXTERN)] -> [(REF nul2 ANY)] if:
  - nul1 is nul2.

Instr_ok/vconst
- the instruction (V128.CONST c) is valid with the instruction type [] -> [V128].

Instr_ok/vvunop
- the instruction (VVUNOP V128 vvunop) is valid with the instruction type [V128] -> [V128].

Instr_ok/vvbinop
- the instruction (VVBINOP V128 vvbinop) is valid with the instruction type [V128, V128] -> [V128].

Instr_ok/vvternop
- the instruction (VVTERNOP V128 vvternop) is valid with the instruction type [V128, V128, V128] -> [V128].

Instr_ok/vvtestop
- the instruction (VVTESTOP V128 vvtestop) is valid with the instruction type [V128] -> [I32].

Instr_ok/vunop
- the instruction (VUNOP sh vunop) is valid with [V128] -> [V128].

Instr_ok/vbinop
- the instruction (VBINOP sh vbinop) is valid with [V128, V128] -> [V128].

Instr_ok/vternop
- the instruction (VTERNOP sh vternop) is valid with [V128, V128, V128] -> [V128].

Instr_ok/vtestop
- the instruction (VTESTOP sh vtestop) is valid with [V128] -> [I32].

Instr_ok/vrelop
- the instruction (VRELOP sh vrelop) is valid with [V128, V128] -> [V128].

Instr_ok/vshiftop
- the instruction (VSHIFTOP sh vshiftop) is valid with the instruction type [V128, I32] -> [V128].

Instr_ok/vbitmask
- the instruction (VBITMASK sh) is valid with [V128] -> [I32].

Instr_ok/vswizzlop
- the instruction (VSWIZZLOP sh vswizzlop) is valid with [V128, V128] -> [V128].

Instr_ok/vshuffle
- the instruction (VSHUFFLE sh i*) is valid with the instruction type [V128, V128] -> [V128] if:
  - For all i in i*:
    - the lane index i is less than (2 * $dim(sh)).

Instr_ok/vsplat
- the instruction (VSPLAT sh) is valid with the instruction type [t] -> [V128] if:
  - Let t be the number type $unpackshape(sh).

Instr_ok/vextract_lane
- the instruction (VEXTRACT_LANE sh sx? i) is valid with the instruction type [V128] -> [t] if:
  - the lane index i is less than $dim(sh).
  - Let t be the number type $unpackshape(sh).

Instr_ok/vreplace_lane
- the instruction (VREPLACE_LANE sh i) is valid with the instruction type [V128, t] -> [V128] if:
  - the lane index i is less than $dim(sh).
  - Let t be the number type $unpackshape(sh).

Instr_ok/vextunop
- the instruction (VEXTUNOP sh_1 sh_2 vextunop) is valid with the instruction type [V128] -> [V128].

Instr_ok/vextbinop
- the instruction (VEXTBINOP sh_1 sh_2 vextbinop) is valid with the instruction type [V128, V128] -> [V128].

Instr_ok/vextternop
- the instruction (VEXTTERNOP sh_1 sh_2 vextternop) is valid with the instruction type [V128, V128, V128] -> [V128].

Instr_ok/vnarrow
- the instruction (VNARROW sh_1 sh_2 sx) is valid with [V128, V128] -> [V128].

Instr_ok/vcvtop
- the instruction (VCVTOP sh_1 sh_2 vcvtop half? zero?) is valid with [V128] -> [V128].

Instr_ok/local.get
- the instruction (LOCAL.GET x) is valid with the instruction type [] -> [t] if:
  - the local type C.LOCALS[x] exists.
  - C.LOCALS[x] is (SET, t).

Instr_ok/local.set
- the instruction (LOCAL.SET x) is valid with the instruction type [t] ->_ [x] [] if:
  - the local type C.LOCALS[x] exists.
  - C.LOCALS[x] is (init, t).

Instr_ok/local.tee
- the instruction (LOCAL.TEE x) is valid with the instruction type [t] ->_ [x] [t] if:
  - the local type C.LOCALS[x] exists.
  - C.LOCALS[x] is (init, t).

Instr_ok/global.get
- the instruction (GLOBAL.GET x) is valid with the instruction type [] -> [t] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (mut, t).

Instr_ok/global.set
- the instruction (GLOBAL.SET x) is valid with the instruction type [t] -> [] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?(MUT), t).

Instr_ok/table.get
- the instruction (TABLE.GET x) is valid with the instruction type [at] -> [rt] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (at, lim, rt).

Instr_ok/table.set
- the instruction (TABLE.SET x) is valid with the instruction type [at, rt] -> [] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (at, lim, rt).

Instr_ok/table.size
- the instruction (TABLE.SIZE x) is valid with the instruction type [] -> [at] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (at, lim, rt).

Instr_ok/table.grow
- the instruction (TABLE.GROW x) is valid with the instruction type [rt, at] -> [at] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (at, lim, rt).

Instr_ok/table.fill
- the instruction (TABLE.FILL x) is valid with the instruction type [at, rt, at] -> [] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (at, lim, rt).

Instr_ok/table.copy
- the instruction (TABLE.COPY x_1 x_2) is valid with the instruction type [at_1, at_2, t] -> [] if:
  - the table type C.TABLES[x_1] exists.
  - C.TABLES[x_1] is (at_1, lim_1, rt_1).
  - the table type C.TABLES[x_2] exists.
  - C.TABLES[x_2] is (at_2, lim_2, rt_2).
  - the reference type rt_2 matches the reference type rt_1.
  - Let t be the address type $minat(at_1, at_2).

Instr_ok/table.init
- the instruction (TABLE.INIT x y) is valid with the instruction type [at, I32, I32] -> [] if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (at, lim, rt_1).
  - the element type C.ELEMS[y] exists.
  - C.ELEMS[y] is rt_2.
  - the reference type rt_2 matches the reference type rt_1.

Instr_ok/elem.drop
- the instruction (ELEM.DROP x) is valid with the instruction type [] -> [] if:
  - the element type C.ELEMS[x] exists.
  - C.ELEMS[x] is rt.

Instr_ok/memory.size
- the instruction (MEMORY.SIZE x) is valid with the instruction type [] -> [at] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.

Instr_ok/memory.grow
- the instruction (MEMORY.GROW x) is valid with the instruction type [at] -> [at] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.

Instr_ok/memory.fill
- the instruction (MEMORY.FILL x) is valid with the instruction type [at, I32, at] -> [] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.

Instr_ok/memory.copy
- the instruction (MEMORY.COPY x_1 x_2) is valid with the instruction type [at_1, at_2, t] -> [] if:
  - the memory type C.MEMS[x_1] exists.
  - C.MEMS[x_1] is at_1 lim_1 PAGE.
  - the memory type C.MEMS[x_2] exists.
  - C.MEMS[x_2] is at_2 lim_2 PAGE.
  - Let t be the address type $minat(at_1, at_2).

Instr_ok/memory.init
- the instruction (MEMORY.INIT x y) is valid with the instruction type [at, I32, I32] -> [] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - the data type C.DATAS[y] exists.
  - C.DATAS[y] is OK.

Instr_ok/data.drop
- the instruction (DATA.DROP x) is valid with the instruction type [] -> [] if:
  - the data type C.DATAS[x] exists.
  - C.DATAS[x] is OK.

Instr_ok/load
- the instruction (LOAD nt_u1 loadop_u1? x memarg) is valid with the instruction type [at] -> [t_u1] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - Either:
    - the number type nt_u1 is nt.
    - loadop_u1? is ?().
    - the value type t_u1 is nt.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - Or:
    - nt_u1 is Inn.
    - loadop_u1? is ?((M, sx)).
    - t_u1 is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store
- the instruction (STORE nt_u1 storeop_u1? x memarg) is valid with the instruction type [at, t_u1] -> [] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - Either:
    - the number type nt_u1 is nt.
    - storeop_u1? is ?().
    - the value type t_u1 is nt.
    - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).
  - Or:
    - nt_u1 is Inn.
    - storeop_u1? is ?(M).
    - t_u1 is Inn.
    - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/vload
- the instruction (VLOAD V128 vloadop_u1? x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - Either:
    - vloadop_u1? is ?().
    - (2 ^ memarg.ALIGN) is less than or equal to ($vsize(V128) / 8).
  - Or:
    - vloadop_u1? is ?((SHAPE M X N sx)).
    - (2 ^ memarg.ALIGN) is less than or equal to ((M / 8) * N).
  - Or:
    - vloadop_u1? is ?((SPLAT N)).
    - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).
  - Or:
    - vloadop_u1? is ?((ZERO N)).
    - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).

Instr_ok/vload_lane
- the instruction (VLOAD_LANE V128 N x memarg i) is valid with the instruction type [at, V128] -> [V128] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).
  - i is less than (128 / N).

Instr_ok/vstore
- the instruction (VSTORE V128 x memarg) is valid with the instruction type [at, V128] -> [] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ($vsize(V128) / 8).

Instr_ok/vstore_lane
- the instruction (VSTORE_LANE V128 N x memarg i) is valid with the instruction type [at, V128] -> [] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).
  - i is less than (128 / N).

Instr_ok/select-expl
- the instruction (SELECT ?([t])) is valid with the instruction type [t, t, I32] -> [t] if:
  - the value type t is valid.

Instr_ok/select-impl
- the instruction (SELECT ?()) is valid with the instruction type [t, t, I32] -> [t] if:
  - the value type t is valid.
  - t matches the value type t'.
  - t' is numtype or t' is vectype.

Instr_ok/load-val
- the instruction (LOAD nt ?() x memarg) is valid with the instruction type [at] -> [nt] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).

Instr_ok/load-pack
- the instruction (LOAD Inn ?((M, sx)) x memarg) is valid with the instruction type [at] -> [Inn] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/store-val
- the instruction (STORE nt ?() x memarg) is valid with the instruction type [at, nt] -> [] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ($size(nt) / 8).

Instr_ok/store-pack
- the instruction (STORE Inn ?(M) x memarg) is valid with the instruction type [at, Inn] -> [] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (M / 8).

Instr_ok/vload-val
- the instruction (VLOAD V128 ?() x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ($vsize(V128) / 8).

Instr_ok/vload-pack
- the instruction (VLOAD V128 ?((SHAPE M X N sx)) x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to ((M / 8) * N).

Instr_ok/vload-splat
- the instruction (VLOAD V128 ?((SPLAT N)) x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).

Instr_ok/vload-zero
- the instruction (VLOAD V128 ?((ZERO N)) x memarg) is valid with the instruction type [at] -> [V128] if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is at lim PAGE.
  - (2 ^ memarg.ALIGN) is less than or equal to (N / 8).

Instrs_ok
- the instruction sequence instr_u1* is valid with the instruction type instrtype_u1 if:
  - Either:
    - instr_u1* is [].
    - instrtype_u1 is [] -> [].
  - Or:
    - instr_u1* is [instr_1] :: instr_2*.
    - instrtype_u1 is t_1* ->_ x_1* :: x_2* t_3*.
    - the instruction instr_1 is valid with the instruction type t_1* ->_ x_1* t_2*.
    - |t*| is |init*|.
    - |x_1*| is |init*|.
    - For all x_1 in x_1*:
      - the local type C.LOCALS[x_1] exists.
    - For all init in init* and t in t* and x_1 in x_1*:
      - C.LOCALS[x_1] is (init, t).
    - Under the context $with_locals(C, x_1*, (SET, t)*), the instruction sequence instr_2* is valid with the instruction type t_2* ->_ x_2* t_3*.
  - Or:
    - instr_u1* is instr*.
    - instrtype_u1 is it'.
    - the instruction sequence instr* is valid with the instruction type it.
    - it matches the instruction type it'.
    - it' is valid.
  - Or:
    - instr_u1* is instr*.
    - instrtype_u1 is t* :: t_1* ->_ x* t* :: t_2*.
    - instr* is valid with the instruction type t_1* ->_ x* t_2*.
    - the result type t* is valid.

Instrs_ok/empty
- the instruction sequence [] is valid with the instruction type [] -> [].

Instrs_ok/seq
- the instruction sequence [instr_1] :: instr_2* is valid with the instruction type t_1* ->_ x_1* :: x_2* t_3* if:
  - the instruction instr_1 is valid with the instruction type t_1* ->_ x_1* t_2*.
  - |t*| is |init*|.
  - |x_1*| is |init*|.
  - For all x_1 in x_1*:
    - the local type C.LOCALS[x_1] exists.
  - For all init in init* and t in t* and x_1 in x_1*:
    - C.LOCALS[x_1] is (init, t).
  - Under the context $with_locals(C, x_1*, (SET, t)*), the instruction sequence instr_2* is valid with the instruction type t_2* ->_ x_2* t_3*.

Instrs_ok/sub
- the instruction sequence instr* is valid with the instruction type it' if:
  - instr* is valid with the instruction type it.
  - it matches it'.
  - it' is valid.

Instrs_ok/frame
- the instruction sequence instr* is valid with the instruction type t* :: t_1* ->_ x* t* :: t_2* if:
  - instr* is valid with the instruction type t_1* ->_ x* t_2*.
  - the result type t* is valid.

Expr_ok
- the expression instr* is valid with the result type t* if:
  - instr* is valid with the instruction type [] -> t*.

Instr_const
- the instruction instr_u1 is constant if:
  - Either:
    - instr_u1 is (nt.CONST c_nt).
  - Or:
    - instr_u1 is (vt.CONST c_vt).
  - Or:
    - instr_u1 is (REF.NULL ht).
  - Or:
    - instr_u1 is REF.I31.
  - Or:
    - instr_u1 is (REF.FUNC x).
  - Or:
    - instr_u1 is (STRUCT.NEW x).
  - Or:
    - instr_u1 is (STRUCT.NEW_DEFAULT x).
  - Or:
    - instr_u1 is (ARRAY.NEW x).
  - Or:
    - instr_u1 is (ARRAY.NEW_DEFAULT x).
  - Or:
    - instr_u1 is (ARRAY.NEW_FIXED x n).
  - Or:
    - instr_u1 is ANY.CONVERT_EXTERN.
  - Or:
    - instr_u1 is EXTERN.CONVERT_ANY.
  - Or:
    - instr_u1 is (GLOBAL.GET x).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is (?(), t).
  - Or:
    - instr_u1 is (BINOP Inn binop).
    - Inn is contained in [I32, I64].
    - binop is contained in [ADD, SUB, MUL].

Instr_const/const
- the instruction (nt.CONST c_nt) is constant.

Instr_const/vconst
- the instruction (vt.CONST c_vt) is constant.

Instr_const/ref.null
- the instruction (REF.NULL ht) is constant.

Instr_const/ref.i31
- the instruction REF.I31 is constant.

Instr_const/ref.func
- the instruction (REF.FUNC x) is constant.

Instr_const/struct.new
- the instruction (STRUCT.NEW x) is constant.

Instr_const/struct.new_default
- the instruction (STRUCT.NEW_DEFAULT x) is constant.

Instr_const/array.new
- the instruction (ARRAY.NEW x) is constant.

Instr_const/array.new_default
- the instruction (ARRAY.NEW_DEFAULT x) is constant.

Instr_const/array.new_fixed
- the instruction (ARRAY.NEW_FIXED x n) is constant.

Instr_const/any.convert_extern
- the instruction ANY.CONVERT_EXTERN is constant.

Instr_const/extern.convert_any
- the instruction EXTERN.CONVERT_ANY is constant.

Instr_const/global.get
- the instruction (GLOBAL.GET x) is constant if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (?(), t).

Instr_const/binop
- the instruction (BINOP Inn binop) is constant if:
  - Inn is contained in [I32, I64].
  - binop is contained in [ADD, SUB, MUL].

Expr_const
- the expression instr* is constant if:
  - For all instr in instr*:
    - the instruction instr is constant.

Type_ok
- the type definition (TYPE rectype) is valid with the defined type sequence dt* if:
  - |C.TYPES| is x.
  - dt* is $rolldt(x, rectype).
  - the context C' is the context C with .TYPES appended by dt*.
  - Under the context C', the recursive type rectype is valid with (OK x).

Local_ok
- the local (LOCAL t) is valid with the local type (init_u1, t) if:
  - Either:
    - the initialization status init_u1 is SET.
    - A :ref:`default value <default-val>` for value type the value type t is defined.
  - Or:
    - init_u1 is UNSET.
    - A :ref:`default value <default-val>` for value type t is not defined.

Local_ok/set
- the local (LOCAL t) is valid with the local type (SET, t) if:
  - A :ref:`default value <default-val>` for value type the value type t is defined.

Local_ok/unset
- the local (LOCAL t) is valid with the local type (UNSET, t) if:
  - A :ref:`default value <default-val>` for value type the value type t is not defined.

Func_ok
- the function (FUNC x local* expr) is valid with the defined type C.TYPES[x] if:
  - C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (FUNC t_1* -> t_2*).
  - |local*| is |lct*|.
  - For all lct in lct* and local in local*:
    - the local local is valid with the local type lct.
  - Under the context C with .LOCALS appended by (SET, t_1)* :: lct* with .LABELS appended by [t_2*] with .RETURN appended by ?(t_2*), the expression expr is valid with the result type t_2*.

Global_ok
- the global (GLOBAL globaltype expr) is valid with the global type globaltype if:
  - the global type gt is valid.
  - globaltype is (mut, t).
  - the expression expr is valid with the value type t.
  - expr is constant.

Table_ok
- the table (TABLE tabletype expr) is valid with the table type tabletype if:
  - the table type tt is valid.
  - tabletype is (at, lim, rt).
  - the expression expr is valid with the value type rt.
  - expr is constant.

Mem_ok
- the memory (MEMORY memtype) is valid with the memory type memtype if:
  - memtype is valid.

Tag_ok
- the tag (TAG x) is valid with the tag type C.TYPES[x] if:
  - C.TYPES[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.TYPES[x] is the composite type (FUNC functype).

Elemmode_ok
- the element mode elemmode_u1 is valid with the element type rt if:
  - Either:
    - elemmode_u1 is (ACTIVE x expr).
    - the table type C.TABLES[x] exists.
    - C.TABLES[x] is (at, lim, rt').
    - rt matches the reference type rt'.
    - the expression expr is valid with the value type I32.
    - expr is constant.
  - Or:
    - elemmode_u1 is PASSIVE.
  - Or:
    - elemmode_u1 is DECLARE.

Elemmode_ok/active
- the element mode (ACTIVE x expr) is valid with the element type rt if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is (at, lim, rt').
  - rt matches the reference type rt'.
  - the expression expr is valid with the value type I32.
  - expr is constant.

Elemmode_ok/passive
- the element mode PASSIVE is valid with rt.

Elemmode_ok/declare
- the element mode DECLARE is valid with rt.

Elem_ok
- the table segment (ELEM elemtype expr* elemmode) is valid with the element type elemtype if:
  - elemtype is valid.
  - For all expr in expr*:
    - the expression expr is valid with elemtype.
    - expr is constant.
  - the element mode elemmode is valid with elemtype.

Datamode_ok
- the data mode datamode_u1 is valid with the data type OK if:
  - Either:
    - datamode_u1 is (ACTIVE x expr).
    - the memory type C.MEMS[x] exists.
    - C.MEMS[x] is mt.
    - the expression expr is valid with the value type I32.
    - expr is constant.
  - Or:
    - datamode_u1 is PASSIVE.

Datamode_ok/active
- the data mode (ACTIVE x expr) is valid with the data type OK if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is mt.
  - the expression expr is valid with the value type I32.
  - expr is constant.

Datamode_ok/passive
- the data mode PASSIVE is valid with OK.

Data_ok
- the memory segment (DATA b* datamode) is valid with the data type OK if:
  - the data mode datamode is valid with OK.

Start_ok
- the start function (START x) is valid if:
  - the defined type C.FUNCS[x] exists.
  - The :ref:`expansion <aux-expand-deftype>` of C.FUNCS[x] is the composite type (FUNC [] -> []).

Import_ok
- the import (IMPORT name_1 name_2 xt) is valid with the external type xt if:
  - xt is valid.

Externidx_ok
- the external index xx_u1 is valid with the external type xt_u1 if:
  - Either:
    - xx_u1 is (FUNC x).
    - xt_u1 is (FUNC dt).
    - the defined type C.FUNCS[x] exists.
    - C.FUNCS[x] is dt.
  - Or:
    - xx_u1 is (GLOBAL x).
    - xt_u1 is (GLOBAL gt).
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is gt.
  - Or:
    - xx_u1 is (TABLE x).
    - xt_u1 is (TABLE tt).
    - the table type C.TABLES[x] exists.
    - C.TABLES[x] is tt.
  - Or:
    - xx_u1 is (MEM x).
    - xt_u1 is (MEM mt).
    - the memory type C.MEMS[x] exists.
    - C.MEMS[x] is mt.
  - Or:
    - xx_u1 is (TAG x).
    - xt_u1 is (TAG jt).
    - the tag type C.TAGS[x] exists.
    - C.TAGS[x] is jt.

Externidx_ok/func
- the external index (FUNC x) is valid with the external type (FUNC dt) if:
  - the defined type C.FUNCS[x] exists.
  - C.FUNCS[x] is dt.

Externidx_ok/global
- the external index (GLOBAL x) is valid with the external type (GLOBAL gt) if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is gt.

Externidx_ok/table
- the external index (TABLE x) is valid with the external type (TABLE tt) if:
  - the table type C.TABLES[x] exists.
  - C.TABLES[x] is tt.

Externidx_ok/mem
- the external index (MEM x) is valid with the external type (MEM mt) if:
  - the memory type C.MEMS[x] exists.
  - C.MEMS[x] is mt.

Externidx_ok/tag
- the external index (TAG x) is valid with the external type (TAG jt) if:
  - the tag type C.TAGS[x] exists.
  - C.TAGS[x] is jt.

Export_ok
- the export (EXPORT name externidx) is valid with the name name and the external type xt if:
  - the external index externidx is valid with xt.

Globals_ok
- the global sequence global_u1* is valid with the global type sequence gt_u1* if:
  - Either:
    - global_u1* is [].
    - gt_u1* is [].
  - Or:
    - global_u1* is [global_1] :: global*.
    - gt_u1* is [gt_1] :: gt*.
    - the global global_1 is valid with the global type gt_1.
    - the context C' is the context C with .GLOBALS appended by [gt_1].
    - Under the context C', the global sequence global* is valid with the global type sequence gt*.

Globals_ok/empty
- [] is valid with the global type sequence [].

Globals_ok/cons
- the global sequence [global_1] :: global* is valid with the global type sequence [gt_1] :: gt* if:
  - the global global_1 is valid with the global type gt_1.
  - the context C' is the context C with .GLOBALS appended by [gt_1].
  - Under the context C', the global sequence global* is valid with the global type sequence gt*.

Types_ok
- the type definition sequence type_u1* is valid with the defined type sequence dt_u1* if:
  - Either:
    - type_u1* is [].
    - dt_u1* is [].
  - Or:
    - type_u1* is [type_1] :: type*.
    - dt_u1* is dt_1* :: dt*.
    - the type definition type_1 is valid with the defined type sequence dt_1*.
    - the context C' is the context C with .TYPES appended by dt_1*.
    - Under the context C', the type definition sequence type* is valid with the defined type sequence dt*.

Types_ok/empty
- [] is valid with the defined type sequence [].

Types_ok/cons
- the type definition sequence [type_1] :: type* is valid with the defined type sequence dt_1* :: dt* if:
  - the type definition type_1 is valid with the defined type sequence dt_1*.
  - the context C' is the context C with .TYPES appended by dt_1*.
  - Under the context C', the type definition sequence type* is valid with the defined type sequence dt*.

Module_ok
- the module (MODULE type* import* func* global* table* mem* tag* elem* data* start? export*) is valid with the module type t if:
  - Under the context { TYPES: []; RECS: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; TAGS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; RETURN: ?(); REFS: []; }, the type definition sequence type* is valid with the defined type sequence dt'*.
  - |xt_I*| is |import*|.
  - For all import in import* and xt_I in xt_I*:
    - Under the context { TYPES: dt'*; RECS: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; TAGS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; RETURN: ?(); REFS: []; }, the import import is valid with the external type xt_I.
  - Under the context C', the global sequence global* is valid with the global type sequence gt*.
  - |tt*| is |table*|.
  - For all table in table* and tt in tt*:
    - Under the context C', the table table is valid with the table type tt.
  - |mt*| is |mem*|.
  - For all mem in mem* and mt in mt*:
    - Under the context C', the memory mem is valid with the memory type mt.
  - |tag*| is |jt*|.
  - For all jt in jt* and tag in tag*:
    - Under the context C', the tag tag is valid with the tag type jt.
  - |func*| is |dt*|.
  - For all dt in dt* and func in func*:
    - the function func is valid with the defined type dt.
  - |rt*| is |elem*|.
  - For all elem in elem* and rt in rt*:
    - the table segment elem is valid with the element type rt.
  - |ok*| is |data*|.
  - For all data in data* and ok in ok*:
    - the memory segment data is valid with the data type ok.
  - If start is defined, then:
    - the start function start is valid.
  - |nm*| is |export*|.
  - |xt_E*| is |export*|.
  - For all export in export* and nm in nm* and xt_E in xt_E*:
    - the export export is valid with the name nm and the external type xt_E.
  - $disjoint_(name, nm*) is true.
  - the context C is C' with .GLOBALS appended by gt* with .TABLES appended by tt_I* :: tt* with .MEMS appended by mt_I* :: mt* with .TAGS appended by jt_I* :: jt* with .ELEMS appended by rt* with .DATAS appended by ok*.
  - the context C' is { TYPES: dt'*; RECS: []; FUNCS: dt_I* :: dt*; GLOBALS: gt_I*; TABLES: []; MEMS: []; TAGS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; RETURN: ?(); REFS: x*; }.
  - the function index sequence x* is $funcidx_nonfuncs((global*, table*, mem*, elem*, data*)).
  - the defined type sequence dt_I* is $funcsxt(xt_I*).
  - the global type sequence gt_I* is $globalsxt(xt_I*).
  - the table type sequence tt_I* is $tablesxt(xt_I*).
  - the memory type sequence mt_I* is $memsxt(xt_I*).
  - the tag type sequence jt_I* is $tagsxt(xt_I*).
  - Let t be the module type $clos_moduletype(C, xt_I* -> xt_E*).

NotationTypingInstrScheme
- the instruction sequence [instr_u1] is valid with the function type t_u1* -> t_u3* if:
  - Either:
    - the instruction instr_u1 is (BINOP I32 ADD).
    - the value type sequence t_u1* is [I32, I32].
    - the value type sequence t_u3* is [I32].
  - Or:
    - instr_u1 is (GLOBAL.GET x).
    - t_u1* is [].
    - t_u3* is [t].
    - the global type C.GLOBALS[x] exists.
    - C.GLOBALS[x] is (mut, t).
  - Or:
    - instr_u1 is (BLOCK blocktype instr*).
    - t_u1* is t_1*.
    - t_u3* is t_2*.
    - the block type blocktype is valid with the instruction type t_1* -> t_2*.
    - the context C' is the context C with .LABELS prepended by [t_2*].
    - Under the context C', the instruction sequence instr* is valid with t_1* -> t_2*.

NotationTypingInstrScheme/i32.add
- the instruction sequence [(BINOP I32 ADD)] is valid with the function type [I32, I32] -> [I32].

NotationTypingInstrScheme/global.get
- the instruction sequence [(GLOBAL.GET x)] is valid with the function type [] -> [t] if:
  - the global type C.GLOBALS[x] exists.
  - C.GLOBALS[x] is (mut, t).

NotationTypingInstrScheme/block
- the instruction sequence [(BLOCK blocktype instr*)] is valid with the function type t_1* -> t_2* if:
  - the block type blocktype is valid with t_1* -> t_2*.
  - the context C' is the context C with .LABELS prepended by [t_2*].
  - Under the context C', the instruction sequence instr* is valid with t_1* -> t_2*.

Step_pure/unreachable
1. Trap.

Step_pure/nop
1. Do nothing.

Step_pure/drop
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Do nothing.

Step_pure/select t*?
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val_2 from the stack.
5. Assert: Due to validation, a value is on the top of the stack.
6. Pop the value val_1 from the stack.
7. If (c =/= 0), then:
  a. Push the value val_1 to the stack.
8. Else:
  a. Push the value val_2 to the stack.

Step_pure/if bt instr_1* instr_2*
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BLOCK bt instr_1*).
4. Else:
  a. Execute the instruction (BLOCK bt instr_2*).

Step_pure/label
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, the first non-value entry of the stack is a LABEL_.
3. Pop the current LABEL_ context from the stack.
4. Push the values val* to the stack.

Step_pure/br l
1. If the first non-value entry of the stack is a LABEL_, then:
  a. Let (LABEL_ n { instr'* }) be the current LABEL_ context.
  b. If (l = 0), then:
    1) Assert: Due to validation, there are at least n values on the top of the stack.
    2) Pop the values val^n from the stack.
    3) Pop all values val'* from the top of the stack.
    4) Pop the current LABEL_ context from the stack.
    5) Push the values val^n to the stack.
    6) Execute the instruction instr'*.
  c. Else:
    1) Pop all values val* from the top of the stack.
    2) If (l > 0), then:
      a) Pop the current LABEL_ context from the stack.
      b) Push the values val* to the stack.
      c) Execute the instruction (BR (l - 1)).
2. Else if the first non-value entry of the stack is a HANDLER_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the current HANDLER_ context from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction (BR l).

Step_pure/br_if l
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST c) from the stack.
3. If (c =/= 0), then:
  a. Execute the instruction (BR l).
4. Else:
  a. Do nothing.

Step_pure/br_table l* l'
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. If (i < |l*|), then:
  a. Execute the instruction (BR l*[i]).
4. Else:
  a. Execute the instruction (BR l').

Step_pure/br_on_null l
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. If val is of the case REF.NULL, then:
  a. Execute the instruction (BR l).
4. Else:
  a. Push the value val to the stack.

Step_pure/br_on_non_null l
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. If val is of the case REF.NULL, then:
  a. Do nothing.
4. Else:
  a. Push the value val to the stack.
  b. Execute the instruction (BR l).

Step_pure/call_indirect x yy
1. Execute the instruction (TABLE.GET x).
2. Execute the instruction (REF.CAST (REF ?(NULL) yy)).
3. Execute the instruction (CALL_REF yy).

Step_pure/return_call_indirect x yy
1. Execute the instruction (TABLE.GET x).
2. Execute the instruction (REF.CAST (REF ?(NULL) yy)).
3. Execute the instruction (RETURN_CALL_REF yy).

Step_pure/frame
1. Let (FRAME_ n { f }) be the current FRAME_ context.
2. Assert: Due to validation, there are at least n values on the top of the stack.
3. Assert: Due to validation, there are at least n values on the top of the stack.
4. Pop the values val^n from the stack.
5. Assert: Due to validation, the first non-value entry of the stack is a FRAME_.
6. Pop the current FRAME_ context from the stack.
7. Push the values val^n to the stack.

Step_pure/return
1. If the first non-value entry of the stack is a FRAME_, then:
  a. Let (FRAME_ n { f }) be the current FRAME_ context.
  b. Assert: Due to validation, there are at least n values on the top of the stack.
  c. Pop the values val^n from the stack.
  d. Pop all values val'* from the top of the stack.
  e. Pop the current FRAME_ context from the stack.
  f. Push the values val^n to the stack.
2. Else if the first non-value entry of the stack is a LABEL_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the current LABEL_ context from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction RETURN.
3. Else if the first non-value entry of the stack is a HANDLER_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the current HANDLER_ context from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction RETURN.

Step_pure/handler
1. Pop all values val* from the top of the stack.
2. Assert: Due to validation, the first non-value entry of the stack is a HANDLER_.
3. Pop the current HANDLER_ context from the stack.
4. Push the values val* to the stack.

Step_pure/unop nt unop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. If (|$unop_(nt, unop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $unop_(nt, unop, c_1).
5. Push the value (nt.CONST c) to the stack.

Step_pure/binop nt binop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type numtype_0 is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. If (|$binop_(nt, binop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $binop_(nt, binop, c_1, c_2).
7. Push the value (nt.CONST c) to the stack.

Step_pure/testop nt testop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. Let c be $testop_(nt, testop, c_1).
4. Push the value (I32.CONST c) to the stack.

Step_pure/relop nt relop
1. Assert: Due to validation, a value of value type nt is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type numtype_0 is on the top of the stack.
4. Pop the value (numtype_0.CONST c_1) from the stack.
5. Let c be $relop_(nt, relop, c_1, c_2).
6. Push the value (I32.CONST c) to the stack.

Step_pure/cvtop nt_2 nt_1 cvtop
1. Assert: Due to validation, a value of value type nt_1 is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. If (|$cvtop__(nt_1, nt_2, cvtop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $cvtop__(nt_1, nt_2, cvtop, c_1).
5. Push the value (nt_2.CONST c) to the stack.

Step_pure/ref.i31
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. Push the value (REF.I31_NUM $wrap__(32, 31, i)) to the stack.

Step_pure/ref.is_null
1. Assert: Due to validation, a value of value type ref is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is of the case REF.NULL, then:
  a. Push the value (I32.CONST 1) to the stack.
4. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/ref.as_non_null
1. Assert: Due to validation, a value of value type ref is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is of the case REF.NULL, then:
  a. Trap.
4. Push the value ref to the stack.

Step_pure/ref.eq
1. Assert: Due to validation, a value of value type ref is on the top of the stack.
2. Pop the value ref_2 from the stack.
3. Assert: Due to validation, a value of value type ref is on the top of the stack.
4. Pop the value ref_1 from the stack.
5. If ref_1 is of the case REF.NULL, then:
  a. If ref_2 is of the case REF.NULL, then:
    1) Push the value (I32.CONST 1) to the stack.
  b. Else if (ref_1 = ref_2), then:
    1) Push the value (I32.CONST 1) to the stack.
  c. Else:
    1) Push the value (I32.CONST 0) to the stack.
6. Else if (ref_1 = ref_2), then:
  a. Push the value (I32.CONST 1) to the stack.
7. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_pure/i31.get sx
1. Assert: Due to validation, a value of value type instr is on the top of the stack.
2. Pop the value instr_u1 from the stack.
3. If instr_u1 is of the case REF.NULL, then:
  a. Trap.
4. If instr_u1 is of the case REF.I31_NUM, then:
  a. Let (REF.I31_NUM i) be instr_u1.
  b. Push the value (I32.CONST $extend__(31, 32, sx, i)) to the stack.

Step_pure/array.new x
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST n) from the stack.
3. Assert: Due to validation, a value is on the top of the stack.
4. Pop the value val from the stack.
5. Push the values val^n to the stack.
6. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_pure/extern.convert_any
1. Assert: Due to validation, a value of value type instr is on the top of the stack.
2. Pop the value instr_u1 from the stack.
3. If instr_u1 is of the case REF.NULL, then:
  a. Push the value (REF.NULL EXTERN) to the stack.
4. If the type of instr_u1 is addrref, then:
  a. Let addrref be instr_u1.
  b. Push the value (REF.EXTERN addrref) to the stack.

Step_pure/any.convert_extern
1. Assert: Due to validation, a value of value type instr is on the top of the stack.
2. Pop the value instr_u1 from the stack.
3. If instr_u1 is of the case REF.NULL, then:
  a. Push the value (REF.NULL ANY) to the stack.
4. If instr_u1 is of the case REF.EXTERN, then:
  a. Let (REF.EXTERN addrref) be instr_u1.
  b. Push the value addrref to the stack.

Step_pure/vvunop V128 vvunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Assert: Due to validation, (|$vvunop_(V128, vvunop, c_1)| > 0).
4. Let c be an element of $vvunop_(V128, vvunop, c_1).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vvbinop V128 vvbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Assert: Due to validation, (|$vvbinop_(V128, vvbinop, c_1, c_2)| > 0).
6. Let c be an element of $vvbinop_(V128, vvbinop, c_1, c_2).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vvternop V128 vvternop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_3) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_2) from the stack.
5. Assert: Due to validation, a value of value type V128 is on the top of the stack.
6. Pop the value (V128.CONST c_1) from the stack.
7. Assert: Due to validation, (|$vvternop_(V128, vvternop, c_1, c_2, c_3)| > 0).
8. Let c be an element of $vvternop_(V128, vvternop, c_1, c_2, c_3).
9. Push the value (V128.CONST c) to the stack.

Step_pure/vvtestop V128 ANY_TRUE
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $ine_($vsize(V128), c_1, 0).
4. Push the value (I32.CONST c) to the stack.

Step_pure/vunop sh vunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (|$vunop_(sh, vunop, c_1)| <= 0), then:
  a. Trap.
4. Let c be an element of $vunop_(sh, vunop, c_1).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vbinop sh vbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. If (|$vbinop_(sh, vbinop, c_1, c_2)| <= 0), then:
  a. Trap.
6. Let c be an element of $vbinop_(sh, vbinop, c_1, c_2).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vternop sh vternop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_3) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_2) from the stack.
5. Assert: Due to validation, a value of value type V128 is on the top of the stack.
6. Pop the value (V128.CONST c_1) from the stack.
7. If (|$vternop_(sh, vternop, c_1, c_2, c_3)| <= 0), then:
  a. Trap.
8. Let c be an element of $vternop_(sh, vternop, c_1, c_2, c_3).
9. Push the value (V128.CONST c) to the stack.

Step_pure/vtestop sh vtestop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let i be $vtestop_(sh, vtestop, c_1).
4. Push the value (I32.CONST i) to the stack.

Step_pure/vrelop sh vrelop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vrelop_(sh, vrelop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vshiftop sh vshiftop
1. Assert: Due to validation, a value of value type I32 is on the top of the stack.
2. Pop the value (I32.CONST i) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vshiftop_(sh, vshiftop, c_1, i).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vbitmask sh
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vbitmaskop_(sh, c_1).
4. Push the value (I32.CONST c) to the stack.

Step_pure/vswizzlop sh swizzlop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vswizzlop_(sh, swizzlop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vshuffle sh i*
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vshufflop_(sh, i*, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vsplat Lnn X M
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_1) from the stack.
3. Assert: Due to validation, (numtype_0 = $lunpack(Lnn)).
4. Let c be $invlanes_(Lnn X M, $lpacknum_(Lnn, c_1)^M).
5. Push the value (V128.CONST c) to the stack.

Step_pure/vextract_lane lt_u1 X M sx_u1? i
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. If (sx_u1? is not defined /\ the type of lt_u1 is numtype), then:
  a. Let nt be lt_u1.
  b. If (i < |$lanes_(nt X M, c_1)|), then:
    1) Let c_2 be $lanes_(nt X M, c_1)[i].
    2) Push the value (nt.CONST c_2) to the stack.
4. If the type of lt_u1 is packtype, then:
  a. Let pt be lt_u1.
  b. If sx_u1? is defined, then:
    1) Let ?(sx) be sx_u1?.
    2) If (i < |$lanes_(pt X M, c_1)|), then:
      a) Let c_2 be $extend__($psize(pt), 32, sx, $lanes_(pt X M, c_1)[i]).
      b) Push the value (I32.CONST c_2) to the stack.

Step_pure/vreplace_lane Lnn X M i
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value (numtype_0.CONST c_2) from the stack.
3. Assert: Due to validation, (numtype_0 = $lunpack(Lnn)).
4. Assert: Due to validation, a value of value type V128 is on the top of the stack.
5. Pop the value (V128.CONST c_1) from the stack.
6. Let c be $invlanes_(Lnn X M, $lanes_(Lnn X M, c_1) with [i] replaced by $lpacknum_(Lnn, c_2)).
7. Push the value (V128.CONST c) to the stack.

Step_pure/vextunop sh_2 sh_1 vextunop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vextunop__(sh_1, sh_2, vextunop, c_1).
4. Push the value (V128.CONST c) to the stack.

Step_pure/vextbinop sh_2 sh_1 vextbinop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vextbinop__(sh_1, sh_2, vextbinop, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vextternop sh_2 sh_1 vextternop
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_3) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_2) from the stack.
5. Assert: Due to validation, a value of value type V128 is on the top of the stack.
6. Pop the value (V128.CONST c_1) from the stack.
7. Let c be $vextternop__(sh_1, sh_2, vextternop, c_1, c_2, c_3).
8. Push the value (V128.CONST c) to the stack.

Step_pure/vnarrow sh_2 sh_1 sx
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_2) from the stack.
3. Assert: Due to validation, a value of value type V128 is on the top of the stack.
4. Pop the value (V128.CONST c_1) from the stack.
5. Let c be $vnarrowop__(sh_1, sh_2, sx, c_1, c_2).
6. Push the value (V128.CONST c) to the stack.

Step_pure/vcvtop sh_2 sh_1 vcvtop half? zero?
1. Assert: Due to validation, a value of value type V128 is on the top of the stack.
2. Pop the value (V128.CONST c_1) from the stack.
3. Let c be $vcvtop__(sh_1, sh_2, vcvtop, half?, zero?, c_1).
4. Push the value (V128.CONST c) to the stack.

Step_pure/local.tee x
1. Assert: Due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Push the value val to the stack.
4. Push the value val to the stack.
5. Execute the instruction (LOCAL.SET x).

Step_read/block bt instr*
1. Let z be the current state.
2. Let t_1^m -> t_2^n be $blocktype_(z, bt).
3. Assert: Due to validation, there are at least m values on the top of the stack.
4. Pop the values val^m from the stack.
5. Enter val^m :: instr* with label (LABEL_ n { [] }).

Step_read/loop bt instr*
1. Let z be the current state.
2. Let t_1^m -> t_2^n be $blocktype_(z, bt).
3. Assert: Due to validation, there are at least m values on the top of the stack.
4. Pop the values val^m from the stack.
5. Enter val^m :: instr* with label (LABEL_ m { [(LOOP bt instr*)] }).

Step_read/br_on_cast l rt_1 rt_2
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt be $Ref_type(ref).
5. Push the value ref to the stack.
6. If rt does not match $inst_reftype(f.MODULE, rt_2), then:
  a. Do nothing.
7. Else:
  a. Execute the instruction (BR l).

Step_read/br_on_cast_fail l rt_1 rt_2
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt be $Ref_type(ref).
5. Push the value ref to the stack.
6. If rt matches $inst_reftype(f.MODULE, rt_2), then:
  a. Do nothing.
7. Else:
  a. Execute the instruction (BR l).

Step_read/call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$moduleinst(z).FUNCS|).
3. Let a be $moduleinst(z).FUNCS[x].
4. Assert: Due to validation, (a < |$funcinst(z)|).
5. Push the value (REF.FUNC_ADDR a) to the stack.
6. Execute the instruction (CALL_REF $funcinst(z)[a].TYPE).

Step_read/call_ref yy
1. Let z be the current state.
2. Assert: Due to validation, a value of value type instr is on the top of the stack.
3. Pop the value instr_u1 from the stack.
4. If instr_u1 is of the case REF.NULL, then:
  a. Trap.
5. If instr_u1 is of the case REF.FUNC_ADDR, then:
  a. Let (REF.FUNC_ADDR a) be instr_u1.
  b. If (a < |$funcinst(z)|), then:
    1) Let fi be $funcinst(z)[a].
    2) Assert: Due to validation, fi.CODE is of the case FUNC.
    3) Let (FUNC x local_0* instr*) be fi.CODE.
    4) If local_0 is of the case LOCAL*, then:
      a) Let (LOCAL t)* be local_0*.
      b) Assert: Due to validation, $expanddt(fi.TYPE) is of the case FUNC.
      c) Let (FUNC functype_0) be $expanddt(fi.TYPE).
      d) Let t_1^n -> t_2^m be functype_0.
      e) Assert: Due to validation, there are at least n values on the top of the stack.
      f) Pop the values val^n from the stack.
      g) Let f be { LOCALS: ?(val)^n :: $default_(t)*; MODULE: fi.MODULE; }.
      h) Push the evaluation context (FRAME_ m { f }) to the stack.
      i) Enter instr* with label (LABEL_ m { [] }).

Step_read/return_call x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$moduleinst(z).FUNCS|).
3. Let a be $moduleinst(z).FUNCS[x].
4. Assert: Due to validation, (a < |$funcinst(z)|).
5. Push the value (REF.FUNC_ADDR a) to the stack.
6. Execute the instruction (RETURN_CALL_REF $funcinst(z)[a].TYPE).

Step_read/return_call_ref yy
1. Let z be the current state.
2. If the first non-value entry of the stack is a LABEL_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the current LABEL_ context from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction (RETURN_CALL_REF yy).
3. Else if the first non-value entry of the stack is a HANDLER_, then:
  a. Pop all values val* from the top of the stack.
  b. Pop the current HANDLER_ context from the stack.
  c. Push the values val* to the stack.
  d. Execute the instruction (RETURN_CALL_REF yy).
4. Else if the first non-value entry of the stack is a FRAME_, then:
  a. Assert: Due to validation, a value of value type instr is on the top of the stack.
  b. Pop the value instr_u1 from the stack.
  c. If instr_u1 is of the case REF.NULL, then:
    1) Pop all values val* from the top of the stack.
    2) Pop the current FRAME_ context from the stack.
    3) Trap.
  d. If instr_u1 is of the case REF.FUNC_ADDR, then:
    1) Let (REF.FUNC_ADDR a) be instr_u1.
    2) If (a < |$funcinst(z)|), then:
      a) Assert: Due to validation, $expanddt($funcinst(z)[a].TYPE) is of the case FUNC.
      b) Let (FUNC functype_0) be $expanddt($funcinst(z)[a].TYPE).
      c) Let t_1^n -> t_2^m be functype_0.
      d) Assert: Due to validation, there are at least n values on the top of the stack.
      e) Pop the values val^n from the stack.
      f) Pop all values val'* from the top of the stack.
      g) Pop the current FRAME_ context from the stack.
      h) Push the values val^n to the stack.
      i) Push the value (REF.FUNC_ADDR a) to the stack.
      j) Execute the instruction (CALL_REF yy).

Step_read/throw_ref
1. Let z be the current state.
2. Assert: Due to validation, a value of value type instr is on the top of the stack.
3. Pop the value instr_u1 from the stack.
4. If instr_u1 is of the case REF.NULL, then:
  a. Trap.
5. If instr_u1 is of the case REF.EXN_ADDR, then:
  a. Let (REF.EXN_ADDR a) be instr_u1.
  b. Pop all values val* from the top of the stack.
  c. If (val* =/= []), then:
    1) Push the value (REF.EXN_ADDR a) to the stack.
    2) Execute the instruction THROW_REF.
  d. Else if the first non-value entry of the stack is a LABEL_, then:
    1) Pop the current LABEL_ context from the stack.
    2) Push the value (REF.EXN_ADDR a) to the stack.
    3) Execute the instruction THROW_REF.
  e. Else if the first non-value entry of the stack is a FRAME_, then:
    1) Pop the current FRAME_ context from the stack.
    2) Push the value (REF.EXN_ADDR a) to the stack.
    3) Execute the instruction THROW_REF.
  f. Else if not the first non-value entry of the stack is a HANDLER_, then:
    1) Throw the exception instr_u1 as a result.
  g. Else:
    1) Let (HANDLER_ n { catch_u1* }) be the current HANDLER_ context.
    2) If (catch_u1* = []), then:
      a) Pop the current HANDLER_ context from the stack.
      b) Push the value (REF.EXN_ADDR a) to the stack.
      c) Execute the instruction THROW_REF.
    3) Else if (a >= |$exninst(z)|), then:
      a) Let [catch_0] :: catch'* be catch_u1*.
      b) If catch_0 is of the case CATCH_ALL, then:
        1. Let (CATCH_ALL l) be catch_0.
        2. Pop the current HANDLER_ context from the stack.
        3. Execute the instruction (BR l).
      c) Else if catch_0 is not of the case CATCH_ALL_REF, then:
        1. Let [catch] :: catch'* be catch_u1*.
        2. Pop the current HANDLER_ context from the stack.
        3. Push the evaluation context (HANDLER_ n { catch'* }) to the stack.
        4. Push the value (REF.EXN_ADDR a) to the stack.
        5. Execute the instruction THROW_REF.
      d) Else:
        1. Let (CATCH_ALL_REF l) be catch_0.
        2. Pop the current HANDLER_ context from the stack.
        3. Push the value (REF.EXN_ADDR a) to the stack.
        4. Execute the instruction (BR l).
    4) Else:
      a) Let val* be $exninst(z)[a].FIELDS.
      b) Let [catch_0] :: catch'* be catch_u1*.
      c) If catch_0 is of the case CATCH, then:
        1. Let (CATCH x l) be catch_0.
        2. If ((x < |$tagaddr(z)|) /\ ($exninst(z)[a].TAG = $tagaddr(z)[x])), then:
          a. Pop the current HANDLER_ context from the stack.
          b. Push the values val* to the stack.
          c. Execute the instruction (BR l).
        3. Else:
          a. Let [catch] :: catch'* be catch_u1*.
          b. Pop the current HANDLER_ context from the stack.
          c. Push the evaluation context (HANDLER_ n { catch'* }) to the stack.
          d. Push the value (REF.EXN_ADDR a) to the stack.
          e. Execute the instruction THROW_REF.
      d) Else if catch_0 is of the case CATCH_REF, then:
        1. Let (CATCH_REF x l) be catch_0.
        2. If (x >= |$tagaddr(z)|), then:
          a. Let [catch] :: catch'* be catch_u1*.
          b. Pop the current HANDLER_ context from the stack.
          c. Push the evaluation context (HANDLER_ n { catch'* }) to the stack.
          d. Push the value (REF.EXN_ADDR a) to the stack.
          e. Execute the instruction THROW_REF.
        3. Else if ($exninst(z)[a].TAG =/= $tagaddr(z)[x]), then:
          a. Let [catch] :: catch'* be catch_u1*.
          b. Pop the current HANDLER_ context from the stack.
          c. Push the evaluation context (HANDLER_ n { catch'* }) to the stack.
          d. Push the value (REF.EXN_ADDR a) to the stack.
          e. Execute the instruction THROW_REF.
        4. Else:
          a. Pop the current HANDLER_ context from the stack.
          b. Push the values val* to the stack.
          c. Push the value (REF.EXN_ADDR a) to the stack.
          d. Execute the instruction (BR l).
      e) Else if catch_0 is of the case CATCH_ALL, then:
        1. Let (CATCH_ALL l) be catch_0.
        2. Pop the current HANDLER_ context from the stack.
        3. Execute the instruction (BR l).
      f) Else if catch_0 is not of the case CATCH_ALL_REF, then:
        1. Let [catch] :: catch'* be catch_u1*.
        2. Pop the current HANDLER_ context from the stack.
        3. Push the evaluation context (HANDLER_ n { catch'* }) to the stack.
        4. Push the value (REF.EXN_ADDR a) to the stack.
        5. Execute the instruction THROW_REF.
      g) Else:
        1. Let (CATCH_ALL_REF l) be catch_0.
        2. Pop the current HANDLER_ context from the stack.
        3. Push the value (REF.EXN_ADDR a) to the stack.
        4. Execute the instruction (BR l).
6. Else if ((not the first non-value entry of the stack is a LABEL_ /\ not the first non-value entry of the stack is a FRAME_) /\ not the first non-value entry of the stack is a HANDLER_), then:
  a. Throw the exception instr_u1 as a result.

Step_read/try_table bt catch* instr*
1. Let z be the current state.
2. Let t_1^m -> t_2^n be $blocktype_(z, bt).
3. Assert: Due to validation, there are at least m values on the top of the stack.
4. Pop the values val^m from the stack.
5. Push the evaluation context (HANDLER_ n { catch* }) to the stack.
6. Enter val^m :: instr* with label (LABEL_ n { [] }).

Step_read/ref.null (_IDX x)
1. Let z be the current state.
2. Push the value (REF.NULL $type(z, x)) to the stack.

Step_read/ref.func x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$moduleinst(z).FUNCS|).
3. Push the value (REF.FUNC_ADDR $moduleinst(z).FUNCS[x]) to the stack.

Step_read/ref.test rt
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt' be $Ref_type(ref).
5. If rt' matches $inst_reftype(f.MODULE, rt), then:
  a. Push the value (I32.CONST 1) to the stack.
6. Else:
  a. Push the value (I32.CONST 0) to the stack.

Step_read/ref.cast rt
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Let rt' be $Ref_type(ref).
5. If rt' does not match $inst_reftype(f.MODULE, rt), then:
  a. Trap.
6. Push the value ref to the stack.

Step_read/struct.new_default x
1. Let z be the current state.
2. Assert: Due to validation, $expanddt($type(z, x)) is of the case STRUCT.
3. Let (STRUCT structtype_0) be $expanddt($type(z, x)).
4. Let (mut, zt)* be structtype_0.
5. Assert: Due to validation, $default_($unpack(zt)) is defined*.
6. Let ?(val)* be $default_($unpack(zt))*.
7. Assert: Due to validation, (|val*| = |zt*|).
8. Push the values val* to the stack.
9. Execute the instruction (STRUCT.NEW x).

Step_read/struct.get sx? x i
1. Let z be the current state.
2. Assert: Due to validation, a value of value type instr is on the top of the stack.
3. Pop the value instr_u1 from the stack.
4. If instr_u1 is of the case REF.NULL, then:
  a. Trap.
5. If instr_u1 is of the case REF.STRUCT_ADDR, then:
  a. Let (REF.STRUCT_ADDR a) be instr_u1.
  b. If ((i < |$structinst(z)[a].FIELDS|) /\ (a < |$structinst(z)|)), then:
    1) Assert: Due to validation, $expanddt($type(z, x)) is of the case STRUCT.
    2) Let (STRUCT structtype_0) be $expanddt($type(z, x)).
    3) Let (mut, zt)* be structtype_0.
    4) If (i < |zt*|), then:
      a) Push the value $unpackfield_(zt*[i], sx?, $structinst(z)[a].FIELDS[i]) to the stack.

Step_read/array.new_default x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, $expanddt($type(z, x)) is of the case ARRAY.
5. Let (ARRAY arraytype_0) be $expanddt($type(z, x)).
6. Let (mut, zt) be arraytype_0.
7. Assert: Due to validation, $default_($unpack(zt)) is defined.
8. Let ?(val) be $default_($unpack(zt)).
9. Push the values val^n to the stack.
10. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_read/array.new_elem x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. If ((i + n) > |$elem(z, y).REFS|), then:
  a. Trap.
7. Assert: Due to validation, (|$elem(z, y).REFS[i : n]| = n).
8. Let ref* be $elem(z, y).REFS[i : n].
9. Push the values ref^n to the stack.
10. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_read/array.new_data x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, $expanddt($type(z, x)) is of the case ARRAY.
7. Let (ARRAY arraytype_0) be $expanddt($type(z, x)).
8. Let (mut, zt) be arraytype_0.
9. If ((i + ((n * $zsize(zt)) / 8)) > |$data(z, y).BYTES|), then:
  a. Trap.
10. Assert: Due to validation, (|$concatn__1^-1(byte, ($zsize(zt) / 8), $data(z, y).BYTES[i : ((n * $zsize(zt)) / 8)])| = n).
11. Let byte** be $concatn__1^-1(byte, ($zsize(zt) / 8), $data(z, y).BYTES[i : ((n * $zsize(zt)) / 8)]).
12. Let c* be $zbytes__1^-1(zt, byte*)*.
13. Push the values $const($cunpack(zt), $cunpacknum_(zt, c))^n to the stack.
14. Execute the instruction (ARRAY.NEW_FIXED x n).

Step_read/array.get sx? x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST i) from the stack.
4. Assert: Due to validation, a value of value type instr is on the top of the stack.
5. Pop the value instr_u1 from the stack.
6. If instr_u1 is of the case REF.NULL, then:
  a. Trap.
7. If instr_u1 is of the case REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be instr_u1.
  b. If ((a < |$arrayinst(z)|) /\ (i >= |$arrayinst(z)[a].FIELDS|)), then:
    1) Trap.
  c. If ((i < |$arrayinst(z)[a].FIELDS|) /\ (a < |$arrayinst(z)|)), then:
    1) Assert: Due to validation, $expanddt($type(z, x)) is of the case ARRAY.
    2) Let (ARRAY arraytype_0) be $expanddt($type(z, x)).
    3) Let (mut, zt) be arraytype_0.
    4) Push the value $unpackfield_(zt, sx?, $arrayinst(z)[a].FIELDS[i]) to the stack.

Step_read/array.len
1. Let z be the current state.
2. Assert: Due to validation, a value of value type instr is on the top of the stack.
3. Pop the value instr_u1 from the stack.
4. If instr_u1 is of the case REF.NULL, then:
  a. Trap.
5. If instr_u1 is of the case REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be instr_u1.
  b. If (a < |$arrayinst(z)|), then:
    1) Push the value (I32.CONST |$arrayinst(z)[a].FIELDS|) to the stack.

Step_read/array.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. Assert: Due to validation, a value of value type instr is on the top of the stack.
9. Pop the value instr_u1 from the stack.
10. If instr_u1 is of the case REF.NULL, then:
  a. Trap.
11. If instr_u1 is of the case REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be instr_u1.
  b. If (a >= |$arrayinst(z)|), then:
    1) Do nothing.
  c. Else if ((i + n) > |$arrayinst(z)[a].FIELDS|), then:
    1) Trap.
  d. If (n = 0), then:
    1) Do nothing.
  e. Else:
    1) Push the value (REF.ARRAY_ADDR a) to the stack.
    2) Push the value (I32.CONST i) to the stack.
    3) Push the value val to the stack.
    4) Execute the instruction (ARRAY.SET x).
    5) Push the value (REF.ARRAY_ADDR a) to the stack.
    6) Push the value (I32.CONST (i + 1)) to the stack.
    7) Push the value val to the stack.
    8) Push the value (I32.CONST (n - 1)) to the stack.
    9) Execute the instruction (ARRAY.FILL x).

Step_read/array.copy x_1 x_2
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i_2) from the stack.
6. Assert: Due to validation, a value of value type instr is on the top of the stack.
7. Pop the value instr_u1 from the stack.
8. Assert: Due to validation, a value of value type I32 is on the top of the stack.
9. Pop the value (I32.CONST i_1) from the stack.
10. Assert: Due to validation, a value of value type instr is on the top of the stack.
11. Pop the value instr_u2 from the stack.
12. If (instr_u2 is of the case REF.NULL /\ the type of instr_u1 is ref), then:
  a. Trap.
13. If (instr_u1 is of the case REF.NULL /\ the type of instr_u2 is ref), then:
  a. Trap.
14. If instr_u2 is of the case REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a_1) be instr_u2.
  b. If instr_u1 is of the case REF.ARRAY_ADDR, then:
    1) If ((a_1 < |$arrayinst(z)|) /\ ((i_1 + n) > |$arrayinst(z)[a_1].FIELDS|)), then:
      a) Trap.
    2) Let (REF.ARRAY_ADDR a_2) be instr_u1.
    3) If (a_2 >= |$arrayinst(z)|), then:
      a) Do nothing.
    4) Else if ((i_2 + n) > |$arrayinst(z)[a_2].FIELDS|), then:
      a) Trap.
    5) If (n = 0), then:
      a) Do nothing.
    6) Else if ((i_1 <= i_2) /\ $expanddt($type(z, x_2)) is of the case ARRAY), then:
      a) Let (ARRAY arraytype_0) be $expanddt($type(z, x_2)).
      b) Let (mut, zt_2) be arraytype_0.
      c) Let sx? be $sx(zt_2).
      d) Push the value (REF.ARRAY_ADDR a_1) to the stack.
      e) Push the value (I32.CONST i_1) to the stack.
      f) Push the value (REF.ARRAY_ADDR a_2) to the stack.
      g) Push the value (I32.CONST i_2) to the stack.
      h) Execute the instruction (ARRAY.GET sx? x_2).
      i) Execute the instruction (ARRAY.SET x_1).
      j) Push the value (REF.ARRAY_ADDR a_1) to the stack.
      k) Push the value (I32.CONST (i_1 + 1)) to the stack.
      l) Push the value (REF.ARRAY_ADDR a_2) to the stack.
      m) Push the value (I32.CONST (i_2 + 1)) to the stack.
      n) Push the value (I32.CONST (n - 1)) to the stack.
      o) Execute the instruction (ARRAY.COPY x_1 x_2).
    7) Else if $expanddt($type(z, x_2)) is of the case ARRAY, then:
      a) Let (ARRAY arraytype_0) be $expanddt($type(z, x_2)).
      b) Let (mut, zt_2) be arraytype_0.
      c) Let sx? be $sx(zt_2).
      d) Push the value (REF.ARRAY_ADDR a_1) to the stack.
      e) Push the value (I32.CONST ((i_1 + n) - 1)) to the stack.
      f) Push the value (REF.ARRAY_ADDR a_2) to the stack.
      g) Push the value (I32.CONST ((i_2 + n) - 1)) to the stack.
      h) Execute the instruction (ARRAY.GET sx? x_2).
      i) Execute the instruction (ARRAY.SET x_1).
      j) Push the value (REF.ARRAY_ADDR a_1) to the stack.
      k) Push the value (I32.CONST i_1) to the stack.
      l) Push the value (REF.ARRAY_ADDR a_2) to the stack.
      m) Push the value (I32.CONST i_2) to the stack.
      n) Push the value (I32.CONST (n - 1)) to the stack.
      o) Execute the instruction (ARRAY.COPY x_1 x_2).
  c. Else if (n =/= 0), then:
    1) Do nothing.

Step_read/array.init_elem x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. Assert: Due to validation, a value of value type instr is on the top of the stack.
9. Pop the value instr_u1 from the stack.
10. If instr_u1 is of the case REF.NULL, then:
  a. Trap.
11. If instr_u1 is of the case REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be instr_u1.
  b. If ((a < |$arrayinst(z)|) /\ ((i + n) > |$arrayinst(z)[a].FIELDS|)), then:
    1) Trap.
  c. If ((j + n) > |$elem(z, y).REFS|), then:
    1) Trap.
  d. If (n = 0), then:
    1) Do nothing.
  e. Else if (j < |$elem(z, y).REFS|), then:
    1) Let ref be $elem(z, y).REFS[j].
    2) Push the value (REF.ARRAY_ADDR a) to the stack.
    3) Push the value (I32.CONST i) to the stack.
    4) Push the value ref to the stack.
    5) Execute the instruction (ARRAY.SET x).
    6) Push the value (REF.ARRAY_ADDR a) to the stack.
    7) Push the value (I32.CONST (i + 1)) to the stack.
    8) Push the value (I32.CONST (j + 1)) to the stack.
    9) Push the value (I32.CONST (n - 1)) to the stack.
    10) Execute the instruction (ARRAY.INIT_ELEM x y).

Step_read/array.init_data x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type I32 is on the top of the stack.
7. Pop the value (I32.CONST i) from the stack.
8. Assert: Due to validation, a value of value type instr is on the top of the stack.
9. Pop the value instr_u1 from the stack.
10. If instr_u1 is of the case REF.NULL, then:
  a. Trap.
11. If instr_u1 is of the case REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be instr_u1.
  b. If ((a < |$arrayinst(z)|) /\ ((i + n) > |$arrayinst(z)[a].FIELDS|)), then:
    1) Trap.
  c. If $expanddt($type(z, x)) is of the case ARRAY, then:
    1) Let (ARRAY arraytype_0) be $expanddt($type(z, x)).
    2) Let (mut, zt) be arraytype_0.
    3) If ((j + ((n * $zsize(zt)) / 8)) > |$data(z, y).BYTES|), then:
      a) Trap.
    4) If (n = 0), then:
      a) Do nothing.
    5) Else:
      a) Let c be $zbytes__1^-1(zt, $data(z, y).BYTES[j : ($zsize(zt) / 8)]).
      b) Push the value (REF.ARRAY_ADDR a) to the stack.
      c) Push the value (I32.CONST i) to the stack.
      d) Push the value $const($cunpack(zt), $cunpacknum_(zt, c)) to the stack.
      e) Execute the instruction (ARRAY.SET x).
      f) Push the value (REF.ARRAY_ADDR a) to the stack.
      g) Push the value (I32.CONST (i + 1)) to the stack.
      h) Push the value (I32.CONST (j + ($zsize(zt) / 8))) to the stack.
      i) Push the value (I32.CONST (n - 1)) to the stack.
      j) Execute the instruction (ARRAY.INIT_DATA x y).
  d. Else if (n = 0), then:
    1) Do nothing.

Step_read/local.get x
1. Let z be the current state.
2. Assert: Due to validation, $local(z, x) is defined.
3. Let ?(val) be $local(z, x).
4. Push the value val to the stack.

Step_read/global.get x
1. Let z be the current state.
2. Let val be $global(z, x).VALUE.
3. Push the value val to the stack.

Step_read/table.get x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type at is on the top of the stack.
3. Pop the value (at.CONST i) from the stack.
4. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
5. Push the value $table(z, x).REFS[i] to the stack.

Step_read/table.size x
1. Let z be the current state.
2. Let (at, lim, rt) be $table(z, x).TYPE.
3. Let n be |$table(z, x).REFS|.
4. Push the value (at.CONST n) to the stack.

Step_read/table.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type at is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type at is on the top of the stack.
7. Pop the value (numtype_0.CONST i) from the stack.
8. If ((i + n) > |$table(z, x).REFS|), then:
  a. Trap.
9. If (n = 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (at.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (TABLE.SET x).
  d. Push the value (at.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (at.CONST (n - 1)) to the stack.
  g. Execute the instruction (TABLE.FILL x).

Step_read/table.copy x_1 x_2
1. Let z be the current state.
2. Assert: Due to validation, a value of value type at' is on the top of the stack.
3. Pop the value (at'.CONST n) from the stack.
4. Assert: Due to validation, a value of value type at_2 is on the top of the stack.
5. Pop the value (at_2.CONST i_2) from the stack.
6. Assert: Due to validation, a value of value type at_1 is on the top of the stack.
7. Pop the value (at_1.CONST i_1) from the stack.
8. If ((i_1 + n) > |$table(z, x_1).REFS|), then:
  a. Trap.
9. If ((i_2 + n) > |$table(z, x_2).REFS|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. If (i_1 <= i_2), then:
    1) Push the value (at_1.CONST i_1) to the stack.
    2) Push the value (at_2.CONST i_2) to the stack.
    3) Execute the instruction (TABLE.GET x_2).
    4) Execute the instruction (TABLE.SET x_1).
    5) Push the value (at_1.CONST (i_1 + 1)) to the stack.
    6) Push the value (at_2.CONST (i_2 + 1)) to the stack.
  b. Else:
    1) Push the value (at_1.CONST ((i_1 + n) - 1)) to the stack.
    2) Push the value (at_2.CONST ((i_2 + n) - 1)) to the stack.
    3) Execute the instruction (TABLE.GET x_2).
    4) Execute the instruction (TABLE.SET x_1).
    5) Push the value (at_1.CONST i_1) to the stack.
    6) Push the value (at_2.CONST i_2) to the stack.
  c. Push the value (at'.CONST (n - 1)) to the stack.
  d. Execute the instruction (TABLE.COPY x_1 x_2).

Step_read/table.init x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type at is on the top of the stack.
7. Pop the value (at.CONST i) from the stack.
8. If ((i + n) > |$table(z, x).REFS|), then:
  a. Trap.
9. If ((j + n) > |$elem(z, y).REFS|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else if (j < |$elem(z, y).REFS|), then:
  a. Push the value (at.CONST i) to the stack.
  b. Push the value $elem(z, y).REFS[j] to the stack.
  c. Execute the instruction (TABLE.SET x).
  d. Push the value (at.CONST (i + 1)) to the stack.
  e. Push the value (I32.CONST (j + 1)) to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (TABLE.INIT x y).

Step_read/load nt_u1 loadop_u1? x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type at is on the top of the stack.
3. Pop the value (at.CONST i) from the stack.
4. If loadop_u1? is not defined, then:
  a. Let nt be nt_u1.
  b. If (((i + ao.OFFSET) + ($size(nt) / 8)) > |$mem(z, x).BYTES|), then:
    1) Trap.
  c. Let c be $nbytes__1^-1(nt, $mem(z, x).BYTES[(i + ao.OFFSET) : ($size(nt) / 8)]).
  d. Push the value (nt.CONST c) to the stack.
5. If the type of nt_u1 is Inn, then:
  a. If loadop_u1? is defined, then:
    1) Let ?(loadop__0) be loadop_u1?.
    2) Let (n, sx) be loadop__0.
    3) If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
  b. Let Inn be nt_u1.
  c. If loadop_u1? is defined, then:
    1) Let ?(loadop__0) be loadop_u1?.
    2) Let (n, sx) be loadop__0.
    3) Let c be $ibytes__1^-1(n, $mem(z, x).BYTES[(i + ao.OFFSET) : (n / 8)]).
    4) Push the value (Inn.CONST $extend__(n, $size(Inn), sx, c)) to the stack.

Step_read/vload V128 vloadop_u1? x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type at is on the top of the stack.
3. Pop the value (at.CONST i) from the stack.
4. If ((((i + ao.OFFSET) + ($vsize(V128) / 8)) > |$mem(z, x).BYTES|) /\ vloadop_u1? is not defined), then:
  a. Trap.
5. If vloadop_u1? is not defined, then:
  a. Let c be $vbytes__1^-1(V128, $mem(z, x).BYTES[(i + ao.OFFSET) : ($vsize(V128) / 8)]).
  b. Push the value (V128.CONST c) to the stack.
6. Else:
  a. Let ?(vloadop__0) be vloadop_u1?.
  b. If vloadop__0 is of the case SHAPE, then:
    1) Let (SHAPE M X K sx) be vloadop__0.
    2) If (((i + ao.OFFSET) + ((M * K) / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
    3) Let j^K be $ibytes__1^-1(M, $mem(z, x).BYTES[((i + ao.OFFSET) + ((k * M) / 8)) : (M / 8)])^(k<K).
    4) If the type of $lsizenn^-1((M * 2)) is Jnn, then:
      a) Let Jnn be $lsizenn^-1((M * 2)).
      b) Let c be $invlanes_(Jnn X K, $extend__(M, $lsizenn(Jnn), sx, j)^K).
      c) Push the value (V128.CONST c) to the stack.
  c. If vloadop__0 is of the case SPLAT, then:
    1) Let (SPLAT N) be vloadop__0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
    3) Let M be (128 / N).
    4) If the type of $lsize^-1(N) is Jnn, then:
      a) Let Jnn be $lsize^-1(N).
      b) Let j be $ibytes__1^-1(N, $mem(z, x).BYTES[(i + ao.OFFSET) : (N / 8)]).
      c) Let c be $invlanes_(Jnn X M, j^M).
      d) Push the value (V128.CONST c) to the stack.
  d. If vloadop__0 is of the case ZERO, then:
    1) Let (ZERO N) be vloadop__0.
    2) If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
    3) Let j be $ibytes__1^-1(N, $mem(z, x).BYTES[(i + ao.OFFSET) : (N / 8)]).
    4) Let c be $extend__(N, 128, U, j).
    5) Push the value (V128.CONST c) to the stack.

Step_read/vload_lane V128 N x ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c_1) from the stack.
4. Assert: Due to validation, a value of value type at is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. If (((i + ao.OFFSET) + (N / 8)) > |$mem(z, x).BYTES|), then:
  a. Trap.
7. Let M be ($vsize(V128) / N).
8. If the type of $lsize^-1(N) is Jnn, then:
  a. Let Jnn be $lsize^-1(N).
  b. Let k be $ibytes__1^-1(N, $mem(z, x).BYTES[(i + ao.OFFSET) : (N / 8)]).
  c. Let c be $invlanes_(Jnn X M, $lanes_(Jnn X M, c_1) with [j] replaced by k).
  d. Push the value (V128.CONST c) to the stack.

Step_read/memory.size x
1. Let z be the current state.
2. Assert: Due to validation, $mem(z, x).TYPE is of the case PAGE.
3. Let at lim PAGE be $mem(z, x).TYPE.
4. Let (n * (64 * $Ki())) be |$mem(z, x).BYTES|.
5. Push the value (at.CONST n) to the stack.

Step_read/memory.fill x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type at is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Assert: Due to validation, a value is on the top of the stack.
5. Pop the value val from the stack.
6. Assert: Due to validation, a value of value type at is on the top of the stack.
7. Pop the value (numtype_0.CONST i) from the stack.
8. If ((i + n) > |$mem(z, x).BYTES|), then:
  a. Trap.
9. If (n = 0), then:
  a. Do nothing.
10. Else:
  a. Push the value (at.CONST i) to the stack.
  b. Push the value val to the stack.
  c. Execute the instruction (STORE I32 ?(8) x $memarg0()).
  d. Push the value (at.CONST (i + 1)) to the stack.
  e. Push the value val to the stack.
  f. Push the value (at.CONST (n - 1)) to the stack.
  g. Execute the instruction (MEMORY.FILL x).

Step_read/memory.copy x_1 x_2
1. Let z be the current state.
2. Assert: Due to validation, a value of value type at' is on the top of the stack.
3. Pop the value (at'.CONST n) from the stack.
4. Assert: Due to validation, a value of value type at_2 is on the top of the stack.
5. Pop the value (at_2.CONST i_2) from the stack.
6. Assert: Due to validation, a value of value type at_1 is on the top of the stack.
7. Pop the value (at_1.CONST i_1) from the stack.
8. If ((i_1 + n) > |$mem(z, x_1).BYTES|), then:
  a. Trap.
9. If ((i_2 + n) > |$mem(z, x_2).BYTES|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else:
  a. If (i_1 <= i_2), then:
    1) Push the value (at_1.CONST i_1) to the stack.
    2) Push the value (at_2.CONST i_2) to the stack.
    3) Execute the instruction (LOAD I32 ?((8, U)) x_2 $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) x_1 $memarg0()).
    5) Push the value (at_1.CONST (i_1 + 1)) to the stack.
    6) Push the value (at_2.CONST (i_2 + 1)) to the stack.
  b. Else:
    1) Push the value (at_1.CONST ((i_1 + n) - 1)) to the stack.
    2) Push the value (at_2.CONST ((i_2 + n) - 1)) to the stack.
    3) Execute the instruction (LOAD I32 ?((8, U)) x_2 $memarg0()).
    4) Execute the instruction (STORE I32 ?(8) x_1 $memarg0()).
    5) Push the value (at_1.CONST i_1) to the stack.
    6) Push the value (at_2.CONST i_2) to the stack.
  c. Push the value (at'.CONST (n - 1)) to the stack.
  d. Execute the instruction (MEMORY.COPY x_1 x_2).

Step_read/memory.init x y
1. Let z be the current state.
2. Assert: Due to validation, a value of value type I32 is on the top of the stack.
3. Pop the value (I32.CONST n) from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST j) from the stack.
6. Assert: Due to validation, a value of value type at is on the top of the stack.
7. Pop the value (at.CONST i) from the stack.
8. If ((i + n) > |$mem(z, x).BYTES|), then:
  a. Trap.
9. If ((j + n) > |$data(z, y).BYTES|), then:
  a. Trap.
10. If (n = 0), then:
  a. Do nothing.
11. Else if (j < |$data(z, y).BYTES|), then:
  a. Push the value (at.CONST i) to the stack.
  b. Push the value (I32.CONST $data(z, y).BYTES[j]) to the stack.
  c. Execute the instruction (STORE I32 ?(8) x $memarg0()).
  d. Push the value (at.CONST (i + 1)) to the stack.
  e. Push the value (I32.CONST (j + 1)) to the stack.
  f. Push the value (I32.CONST (n - 1)) to the stack.
  g. Execute the instruction (MEMORY.INIT x y).

Step/throw x
1. Let z be the current state.
2. Assert: Due to validation, (x < |$tagaddr(z)|).
3. Assert: Due to validation, $expanddt($tag(z, x).TYPE) is of the case FUNC.
4. Let (FUNC functype_0) be $expanddt($tag(z, x).TYPE).
5. Let t^n -> resulttype_1 be functype_0.
6. Assert: Due to validation, (resulttype_1 = []).
7. Let a be |$exninst(z)|.
8. Assert: Due to validation, there are at least n values on the top of the stack.
9. Pop the values val^n from the stack.
10. Let exn be { TAG: $tagaddr(z)[x]; FIELDS: val^n; }.
11. Perform $add_exninst(z, [exn]).
12. Push the value (REF.EXN_ADDR a) to the stack.
13. Execute the instruction THROW_REF.

Step/struct.new x
1. Let z be the current state.
2. Assert: Due to validation, $expanddt($type(z, x)) is of the case STRUCT.
3. Let (STRUCT structtype_0) be $expanddt($type(z, x)).
4. Let (mut, zt)^n be structtype_0.
5. Let a be |$structinst(z)|.
6. Assert: Due to validation, there are at least n values on the top of the stack.
7. Pop the values val^n from the stack.
8. Let si be { TYPE: $type(z, x); FIELDS: $packfield_(zt, val)^n; }.
9. Push the value (REF.STRUCT_ADDR a) to the stack.
10. Perform $add_structinst(z, [si]).

Step/struct.set x i
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Assert: Due to validation, a value of value type instr is on the top of the stack.
5. Pop the value instr_u1 from the stack.
6. If instr_u1 is of the case REF.NULL, then:
  a. Trap.
7. If instr_u1 is of the case REF.STRUCT_ADDR, then:
  a. Let (REF.STRUCT_ADDR a) be instr_u1.
  b. Assert: Due to validation, $expanddt($type(z, x)) is of the case STRUCT.
  c. Let (STRUCT structtype_0) be $expanddt($type(z, x)).
  d. Let (mut, zt)* be structtype_0.
  e. If (i < |zt*|), then:
    1) Perform $with_struct(z, a, i, $packfield_(zt*[i], val)).

Step/array.new_fixed x n
1. Let z be the current state.
2. Assert: Due to validation, $expanddt($type(z, x)) is of the case ARRAY.
3. Let (ARRAY arraytype_0) be $expanddt($type(z, x)).
4. Let (mut, zt) be arraytype_0.
5. Let a be |$arrayinst(z)|.
6. Assert: Due to validation, there are at least n values on the top of the stack.
7. Pop the values val^n from the stack.
8. Let ai be { TYPE: $type(z, x); FIELDS: $packfield_(zt, val)^n; }.
9. Push the value (REF.ARRAY_ADDR a) to the stack.
10. Perform $add_arrayinst(z, [ai]).

Step/array.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Assert: Due to validation, a value of value type I32 is on the top of the stack.
5. Pop the value (I32.CONST i) from the stack.
6. Assert: Due to validation, a value of value type instr is on the top of the stack.
7. Pop the value instr_u1 from the stack.
8. If instr_u1 is of the case REF.NULL, then:
  a. Trap.
9. If instr_u1 is of the case REF.ARRAY_ADDR, then:
  a. Let (REF.ARRAY_ADDR a) be instr_u1.
  b. If ((a < |$arrayinst(z)|) /\ (i >= |$arrayinst(z)[a].FIELDS|)), then:
    1) Trap.
  c. Assert: Due to validation, $expanddt($type(z, x)) is of the case ARRAY.
  d. Let (ARRAY arraytype_0) be $expanddt($type(z, x)).
  e. Let (mut, zt) be arraytype_0.
  f. Perform $with_array(z, a, i, $packfield_(zt, val)).

Step/local.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_local(z, x, val).

Step/global.set x
1. Let z be the current state.
2. Assert: Due to validation, a value is on the top of the stack.
3. Pop the value val from the stack.
4. Perform $with_global(z, x, val).

Step/table.set x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type ref is on the top of the stack.
3. Pop the value ref from the stack.
4. Assert: Due to validation, a value of value type at is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. If (i >= |$table(z, x).REFS|), then:
  a. Trap.
7. Perform $with_table(z, x, i, ref).

Step/table.grow x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type at is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Assert: Due to validation, a value of value type ref is on the top of the stack.
5. Pop the value ref from the stack.
6. Either:
  a. Let ti be $growtable($table(z, x), n, ref).
  b. Push the value (at.CONST |$table(z, x).REFS|) to the stack.
  c. Perform $with_tableinst(z, x, ti).
7. Or:
  a. Push the value (at.CONST $invsigned_($size(at), (- 1))) to the stack.

Step/elem.drop x
1. Let z be the current state.
2. Perform $with_elem(z, x, []).

Step/store nt_u1 storeop_u1? x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type nt_u3 is on the top of the stack.
3. Pop the value (nt_u3.CONST c) from the stack.
4. Assert: Due to validation, a value of value type at is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. Let nt be nt_u3.
7. If ((((i + ao.OFFSET) + ($size(nt) / 8)) > |$mem(z, x).BYTES|) /\ ((nt_u1 = nt) /\ storeop_u1? is not defined)), then:
  a. Trap.
8. If ((nt_u1 = nt) /\ storeop_u1? is not defined), then:
  a. Let b* be $nbytes_(nt, c).
  b. Perform $with_mem(z, x, (i + ao.OFFSET), ($size(nt) / 8), b*).
9. If the type of nt_u3 is Inn, then:
  a. Let Inn be nt_u3.
  b. If ((nt_u1 = Inn) /\ storeop_u1? is defined), then:
    1) Let ?(n) be storeop_u1?.
    2) If (((i + ao.OFFSET) + (n / 8)) > |$mem(z, x).BYTES|), then:
      a) Trap.
    3) Let b* be $ibytes_(n, $wrap__($size(Inn), n, c)).
    4) Perform $with_mem(z, x, (i + ao.OFFSET), (n / 8), b*).

Step/vstore V128 x ao
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type at is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. If (((i + ao.OFFSET) + ($vsize(V128) / 8)) > |$mem(z, x).BYTES|), then:
  a. Trap.
7. Let b* be $vbytes_(V128, c).
8. Perform $with_mem(z, x, (i + ao.OFFSET), ($vsize(V128) / 8), b*).

Step/vstore_lane V128 N x ao j
1. Let z be the current state.
2. Assert: Due to validation, a value of value type V128 is on the top of the stack.
3. Pop the value (V128.CONST c) from the stack.
4. Assert: Due to validation, a value of value type at is on the top of the stack.
5. Pop the value (at.CONST i) from the stack.
6. If (((i + ao.OFFSET) + N) > |$mem(z, x).BYTES|), then:
  a. Trap.
7. Let M be (128 / N).
8. If the type of $lsize^-1(N) is Jnn, then:
  a. Let Jnn be $lsize^-1(N).
  b. If (j < |$lanes_(Jnn X M, c)|), then:
    1) Let b* be $ibytes_(N, $lanes_(Jnn X M, c)[j]).
    2) Perform $with_mem(z, x, (i + ao.OFFSET), (N / 8), b*).

Step/memory.grow x
1. Let z be the current state.
2. Assert: Due to validation, a value of value type at is on the top of the stack.
3. Pop the value (at.CONST n) from the stack.
4. Either:
  a. Let mi be $growmem($mem(z, x), n).
  b. Push the value (at.CONST (|$mem(z, x).BYTES| / (64 * $Ki()))) to the stack.
  c. Perform $with_meminst(z, x, mi).
5. Or:
  a. Push the value (at.CONST $invsigned_($size(at), (- 1))) to the stack.

Step/data.drop x
1. Let z be the current state.
2. Perform $with_data(z, x, []).

min i j
1. If (i <= j), then:
  a. Return i.
2. Return j.

sum n_u1*
1. If (n_u1* = []), then:
  a. Return 0.
2. Let [n] :: n'* be n_u1*.
3. Return (n + $sum(n'*)).

prod n_u1*
1. If (n_u1* = []), then:
  a. Return 1.
2. Let [n] :: n'* be n_u1*.
3. Return (n * $prod(n'*)).

opt_ X X_u1*
1. If (X_u1* = []), then:
  a. Return ?().
2. Assert: Due to validation, (|X_u1*| = 1).
3. Let [w] be X_u1*.
4. Return ?(w).

concat_ X X_u1*
1. If (X_u1* = []), then:
  a. Return [].
2. Let [w*] :: w'** be X_u1*.
3. Return w* :: $concat_(X, w'**).

concatn_ X X_u1* n
1. If (X_u1* = []), then:
  a. Return [].
2. Let [w^n] :: w'^n* be X_u1*.
3. Return w^n :: $concatn_(X, w'^n*, n).

disjoint_ X X_u1*
1. If (X_u1* = []), then:
  a. Return true.
2. Let [w] :: w'* be X_u1*.
3. Return (w is not contained in w'* /\ $disjoint_(X, w'*)).

setminus1_ X w X_u1*
1. If (X_u1* = []), then:
  a. Return [w].
2. Let [w_1] :: w'* be X_u1*.
3. If (w = w_1), then:
  a. Return [].
4. Return $setminus1_(X, w, w'*).

setminus_ X X_u1* w*
1. If (X_u1* = []), then:
  a. Return [].
2. Let [w_1] :: w'* be X_u1*.
3. Return $setminus1_(X, w_1, w*) :: $setminus_(X, w'*, w*).

setproduct2_ X w_1 X_u1*
1. If (X_u1* = []), then:
  a. Return [].
2. Let [w'*] :: w** be X_u1*.
3. Return [[w_1] :: w'*] :: $setproduct2_(X, w_1, w**).

setproduct1_ X X_u1* w**
1. If (X_u1* = []), then:
  a. Return [].
2. Let [w_1] :: w'* be X_u1*.
3. Return $setproduct2_(X, w_1, w**) :: $setproduct1_(X, w'*, w**).

setproduct_ X X_u1*
1. If (X_u1* = []), then:
  a. Return [[]].
2. Let [w_1*] :: w** be X_u1*.
3. Return $setproduct1_(X, w_1*, $setproduct_(X, w**)).

signif N_u1
1. If (N_u1 = 32), then:
  a. Return 23.
2. Assert: Due to validation, (N_u1 = 64).
3. Return 52.

expon N_u1
1. If (N_u1 = 32), then:
  a. Return 8.
2. Assert: Due to validation, (N_u1 = 64).
3. Return 11.

M N
1. Return $signif(N).

E N
1. Return $expon(N).

fzero N
1. Return (POS (SUBNORM 0)).

fone N
1. Return (POS (NORM 1 0)).

canon_ N
1. Return (2 ^ ($signif(N) - 1)).

cont b
1. Assert: Due to validation, (128 < b).
2. Assert: Due to validation, (b < 192).
3. Return (b - 128).

ANYREF
1. Return (REF ?(NULL) ANY).

EQREF
1. Return (REF ?(NULL) EQ).

I31REF
1. Return (REF ?(NULL) I31).

STRUCTREF
1. Return (REF ?(NULL) STRUCT).

ARRAYREF
1. Return (REF ?(NULL) ARRAY).

FUNCREF
1. Return (REF ?(NULL) FUNC).

EXTERNREF
1. Return (REF ?(NULL) EXTERN).

NULLREF
1. Return (REF ?(NULL) NONE).

NULLFUNCREF
1. Return (REF ?(NULL) NOFUNC).

NULLEXTERNREF
1. Return (REF ?(NULL) NOEXTERN).

size nt_u1
1. If (nt_u1 = I32), then:
  a. Return 32.
2. If (nt_u1 = I64), then:
  a. Return 64.
3. If (nt_u1 = F32), then:
  a. Return 32.
4. Assert: Due to validation, (nt_u1 = F64).
5. Return 64.

vsize V128
1. Return 128.

psize pt_u1
1. If (pt_u1 = I8), then:
  a. Return 8.
2. Assert: Due to validation, (pt_u1 = I16).
3. Return 16.

lsize lt_u1
1. If the type of lt_u1 is numtype, then:
  a. Let numtype be lt_u1.
  b. Return $size(numtype).
2. Assert: Due to validation, the type of lt_u1 is packtype.
3. Let packtype be lt_u1.
4. Return $psize(packtype).

zsize zt_u1
1. If the type of zt_u1 is numtype, then:
  a. Let numtype be zt_u1.
  b. Return $size(numtype).
2. If the type of zt_u1 is vectype, then:
  a. Let vectype be zt_u1.
  b. Return $vsize(vectype).
3. Assert: Due to validation, the type of zt_u1 is packtype.
4. Let packtype be zt_u1.
5. Return $psize(packtype).

sizenn nt
1. Return $size(nt).

sizenn1 nt
1. Return $size(nt).

sizenn2 nt
1. Return $size(nt).

vsizenn vt
1. Return $vsize(vt).

psizenn pt
1. Return $psize(pt).

lsizenn lt
1. Return $lsize(lt).

lsizenn1 lt
1. Return $lsize(lt).

lsizenn2 lt
1. Return $lsize(lt).

lunpack lt_u1
1. If the type of lt_u1 is numtype, then:
  a. Let numtype be lt_u1.
  b. Return numtype.
2. Assert: Due to validation, the type of lt_u1 is packtype.
3. Return I32.

unpack zt_u1
1. If the type of zt_u1 is valtype, then:
  a. Let valtype be zt_u1.
  b. Return valtype.
2. Assert: Due to validation, the type of zt_u1 is packtype.
3. Return I32.

nunpack zt_u1
1. If the type of zt_u1 is numtype, then:
  a. Let numtype be zt_u1.
  b. Return numtype.
2. If the type of zt_u1 is packtype, then:
  a. Return I32.

vunpack vectype
1. Return vectype.

cunpack zt_u1
1. If the type of zt_u1 is consttype, then:
  a. Let consttype be zt_u1.
  b. Return consttype.
2. If the type of zt_u1 is packtype, then:
  a. Return I32.
3. If the type of zt_u1 is lanetype, then:
  a. Let lanetype be zt_u1.
  b. Return $lunpack(lanetype).

dim Lnn X N
1. Return N.

lanetype Lnn X N
1. Return Lnn.

unpackshape Lnn X N
1. Return $lunpack(Lnn).

funcsxx xx_u1*
1. If (xx_u1* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be xx_u1*.
3. If externidx_0 is of the case FUNC, then:
  a. Let (FUNC x) be externidx_0.
  b. Return [x] :: $funcsxx(xx*).
4. Let [externidx] :: xx* be xx_u1*.
5. Return $funcsxx(xx*).

globalsxx xx_u1*
1. If (xx_u1* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be xx_u1*.
3. If externidx_0 is of the case GLOBAL, then:
  a. Let (GLOBAL x) be externidx_0.
  b. Return [x] :: $globalsxx(xx*).
4. Let [externidx] :: xx* be xx_u1*.
5. Return $globalsxx(xx*).

tablesxx xx_u1*
1. If (xx_u1* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be xx_u1*.
3. If externidx_0 is of the case TABLE, then:
  a. Let (TABLE x) be externidx_0.
  b. Return [x] :: $tablesxx(xx*).
4. Let [externidx] :: xx* be xx_u1*.
5. Return $tablesxx(xx*).

memsxx xx_u1*
1. If (xx_u1* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be xx_u1*.
3. If externidx_0 is of the case MEM, then:
  a. Let (MEM x) be externidx_0.
  b. Return [x] :: $memsxx(xx*).
4. Let [externidx] :: xx* be xx_u1*.
5. Return $memsxx(xx*).

tagsxx xx_u1*
1. If (xx_u1* = []), then:
  a. Return [].
2. Let [externidx_0] :: xx* be xx_u1*.
3. If externidx_0 is of the case TAG, then:
  a. Let (TAG x) be externidx_0.
  b. Return [x] :: $tagsxx(xx*).
4. Let [externidx] :: xx* be xx_u1*.
5. Return $tagsxx(xx*).

IN N_u1
1. If (N_u1 = 32), then:
  a. Return I32.
2. Assert: Due to validation, (N_u1 = 64).
3. Return I64.

FN N_u1
1. If (N_u1 = 32), then:
  a. Return F32.
2. Assert: Due to validation, (N_u1 = 64).
3. Return F64.

JN N_u1
1. If (N_u1 = 8), then:
  a. Return I8.
2. If (N_u1 = 16), then:
  a. Return I16.
3. If (N_u1 = 32), then:
  a. Return I32.
4. Assert: Due to validation, (N_u1 = 64).
5. Return I64.

minat at_1 at_2
1. If ($size(at_1) <= $size(at_2)), then:
  a. Return at_1.
2. Return at_2.

diffrt (REF nul1 ht_1) (REF nul_u1 ht_2)
1. If (nul_u1 = ?(NULL)), then:
  a. Return (REF ?() ht_1).
2. Assert: Due to validation, nul_u1 is not defined.
3. Return (REF nul1 ht_1).

funcsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is of the case FUNC, then:
  a. Let (FUNC dt) be externtype_0.
  b. Return [dt] :: $funcsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $funcsxt(xt*).

globalsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is of the case GLOBAL, then:
  a. Let (GLOBAL gt) be externtype_0.
  b. Return [gt] :: $globalsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $globalsxt(xt*).

tablesxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is of the case TABLE, then:
  a. Let (TABLE tt) be externtype_0.
  b. Return [tt] :: $tablesxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $tablesxt(xt*).

memsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is of the case MEM, then:
  a. Let (MEM mt) be externtype_0.
  b. Return [mt] :: $memsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $memsxt(xt*).

tagsxt xt_u1*
1. If (xt_u1* = []), then:
  a. Return [].
2. Let [externtype_0] :: xt* be xt_u1*.
3. If externtype_0 is of the case TAG, then:
  a. Let (TAG jt) be externtype_0.
  b. Return [jt] :: $tagsxt(xt*).
4. Let [externtype] :: xt* be xt_u1*.
5. Return $tagsxt(xt*).

subst_typevar tv tv_u1* yy_u1*
1. If ((tv_u1* = []) /\ (yy_u1* = [])), then:
  a. Return tv.
2. Assert: Due to validation, (|yy_u1*| >= 1).
3. Let [tu_1] :: tu'* be yy_u1*.
4. Assert: Due to validation, (|tv_u1*| >= 1).
5. Let [tv_1] :: tv'* be tv_u1*.
6. If (tv = tv_1), then:
  a. Return tu_1.
7. Return $subst_typevar(tv, tv'*, tu'*).

subst_packtype pt tv* tu*
1. Return pt.

subst_numtype nt tv* tu*
1. Return nt.

subst_vectype vt tv* tu*
1. Return vt.

subst_typeuse yy_u1 tv* tu*
1. If the type of yy_u1 is typevar, then:
  a. Let tv' be yy_u1.
  b. Return $subst_typevar(tv', tv*, tu*).
2. Assert: Due to validation, the type of yy_u1 is deftype.
3. Let dt be yy_u1.
4. Return $subst_deftype(dt, tv*, tu*).

subst_heaptype ht_u1 tv* tu*
1. If the type of ht_u1 is typevar, then:
  a. Let tv' be ht_u1.
  b. Return $subst_typevar(tv', tv*, tu*).
2. If the type of ht_u1 is deftype, then:
  a. Let dt be ht_u1.
  b. Return $subst_deftype(dt, tv*, tu*).
3. Let ht be ht_u1.
4. Return ht.

subst_reftype (REF nul ht) tv* tu*
1. Return (REF nul $subst_heaptype(ht, tv*, tu*)).

subst_valtype t_u1 tv* tu*
1. If the type of t_u1 is numtype, then:
  a. Let nt be t_u1.
  b. Return $subst_numtype(nt, tv*, tu*).
2. If the type of t_u1 is vectype, then:
  a. Let vt be t_u1.
  b. Return $subst_vectype(vt, tv*, tu*).
3. If the type of t_u1 is reftype, then:
  a. Let rt be t_u1.
  b. Return $subst_reftype(rt, tv*, tu*).
4. Assert: Due to validation, (t_u1 = BOT).
5. Return BOT.

subst_storagetype zt_u1 tv* tu*
1. If the type of zt_u1 is valtype, then:
  a. Let t be zt_u1.
  b. Return $subst_valtype(t, tv*, tu*).
2. Assert: Due to validation, the type of zt_u1 is packtype.
3. Let pt be zt_u1.
4. Return $subst_packtype(pt, tv*, tu*).

subst_fieldtype (mut, zt) tv* tu*
1. Return (mut, $subst_storagetype(zt, tv*, tu*)).

subst_comptype ct_u1 tv* tu*
1. If ct_u1 is of the case STRUCT, then:
  a. Let (STRUCT yt*) be ct_u1.
  b. Return (STRUCT $subst_fieldtype(yt, tv*, tu*)*).
2. If ct_u1 is of the case ARRAY, then:
  a. Let (ARRAY yt) be ct_u1.
  b. Return (ARRAY $subst_fieldtype(yt, tv*, tu*)).
3. Assert: Due to validation, ct_u1 is of the case FUNC.
4. Let (FUNC ft) be ct_u1.
5. Return (FUNC $subst_functype(ft, tv*, tu*)).

subst_subtype (SUB fin tu'* ct) tv* tu*
1. Return (SUB fin $subst_typeuse(tu', tv*, tu*)* $subst_comptype(ct, tv*, tu*)).

subst_rectype (REC st*) tv* tu*
1. Return (REC $subst_subtype(st, tv*, tu*)*).

subst_deftype (DEF qt i) tv* tu*
1. Return (DEF $subst_rectype(qt, tv*, tu*) i).

subst_functype t_1* -> t_2* tv* tu*
1. Return $subst_valtype(t_1, tv*, tu*)* -> $subst_valtype(t_2, tv*, tu*)*.

subst_addrtype at tv* tu*
1. Return at.

subst_globaltype (mut, t) tv* tu*
1. Return (mut, $subst_valtype(t, tv*, tu*)).

subst_tabletype (at, lim, rt) tv* tu*
1. Return (at, lim, $subst_reftype(rt, tv*, tu*)).

subst_memtype at lim PAGE tv* tu*
1. Return at lim PAGE.

subst_tagtype dt tv* tu*
1. Return $subst_deftype(dt, tv*, tu*).

subst_externtype xt_u1 tv* tu*
1. If xt_u1 is of the case FUNC, then:
  a. Let (FUNC dt) be xt_u1.
  b. Return (FUNC $subst_deftype(dt, tv*, tu*)).
2. If xt_u1 is of the case GLOBAL, then:
  a. Let (GLOBAL gt) be xt_u1.
  b. Return (GLOBAL $subst_globaltype(gt, tv*, tu*)).
3. If xt_u1 is of the case TABLE, then:
  a. Let (TABLE tt) be xt_u1.
  b. Return (TABLE $subst_tabletype(tt, tv*, tu*)).
4. If xt_u1 is of the case MEM, then:
  a. Let (MEM mt) be xt_u1.
  b. Return (MEM $subst_memtype(mt, tv*, tu*)).
5. Assert: Due to validation, xt_u1 is of the case TAG.
6. Let (TAG jt) be xt_u1.
7. Return (TAG $subst_tagtype(jt, tv*, tu*)).

subst_moduletype xt_1* -> xt_2* tv* tu*
1. Return $subst_externtype(xt_1, tv*, tu*)* -> $subst_externtype(xt_2, tv*, tu*)*.

subst_all_valtype t tu^n
1. Return $subst_valtype(t, (_IDX i)^(i<n), tu^n).

subst_all_reftype rt tu^n
1. Return $subst_reftype(rt, (_IDX i)^(i<n), tu^n).

subst_all_deftype dt tu^n
1. Return $subst_deftype(dt, (_IDX i)^(i<n), tu^n).

subst_all_globaltype gt tu^n
1. Return $subst_globaltype(gt, (_IDX i)^(i<n), tu^n).

subst_all_tabletype tt tu^n
1. Return $subst_tabletype(tt, (_IDX i)^(i<n), tu^n).

subst_all_memtype mt tu^n
1. Return $subst_memtype(mt, (_IDX i)^(i<n), tu^n).

subst_all_moduletype mmt tu^n
1. Return $subst_moduletype(mmt, (_IDX i)^(i<n), tu^n).

subst_all_deftypes dt_u1* tu*
1. If (dt_u1* = []), then:
  a. Return [].
2. Let [dt_1] :: dt* be dt_u1*.
3. Return [$subst_all_deftype(dt_1, tu*)] :: $subst_all_deftypes(dt*, tu*).

rollrt x rectype
1. Assert: Due to validation, rectype is of the case REC.
2. Let (REC subtype^n) be rectype.
3. Return (REC $subst_subtype(subtype, (_IDX (x + i))^(i<n), (REC i)^(i<n))^n).

unrollrt rectype
1. Assert: Due to validation, rectype is of the case REC.
2. Let (REC subtype^n) be rectype.
3. Return (REC $subst_subtype(subtype, (REC i)^(i<n), (DEF rectype i)^(i<n))^n).

rolldt x rectype
1. Assert: Due to validation, $rollrt(x, rectype) is of the case REC.
2. Let (REC subtype^n) be $rollrt(x, rectype).
3. Return (DEF (REC subtype^n) i)^(i<n).

unrolldt (DEF rectype i)
1. Assert: Due to validation, $unrollrt(rectype) is of the case REC.
2. Let (REC subtype*) be $unrollrt(rectype).
3. Return subtype*[i].

expanddt deftype
1. Assert: Due to validation, $unrolldt(deftype) is of the case SUB.
2. Let (SUB fin typeuse* comptype) be $unrolldt(deftype).
3. Return comptype.

memarg0
1. Return { ALIGN: 0; OFFSET: 0; }.

const consttype_u1 c
1. If the type of consttype_u1 is numtype, then:
  a. Let numtype be consttype_u1.
  b. Return (numtype.CONST c).
2. Assert: Due to validation, the type of consttype_u1 is vectype.
3. Let vectype be consttype_u1.
4. Return (vectype.CONST c).

free_opt free_u1?
1. If free_u1? is not defined, then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
2. Let ?(free) be free_u1?.
3. Return free.

free_list free_u1*
1. If (free_u1* = []), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
2. Let [free] :: free'* be free_u1*.
3. Return free ++ $free_list(free'*).

free_typeidx typeidx
1. Return { TYPES: [typeidx]; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_funcidx funcidx
1. Return { TYPES: []; FUNCS: [funcidx]; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_globalidx globalidx
1. Return { TYPES: []; FUNCS: []; GLOBALS: [globalidx]; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_tableidx tableidx
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: [tableidx]; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_memidx memidx
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: [memidx]; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_elemidx elemidx
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: [elemidx]; DATAS: []; LOCALS: []; LABELS: []; }.

free_dataidx dataidx
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: [dataidx]; LOCALS: []; LABELS: []; }.

free_localidx localidx
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: [localidx]; LABELS: []; }.

free_labelidx labelidx
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: [labelidx]; }.

free_externidx xx_u1
1. If xx_u1 is of the case FUNC, then:
  a. Let (FUNC funcidx) be xx_u1.
  b. Return $free_funcidx(funcidx).
2. If xx_u1 is of the case GLOBAL, then:
  a. Let (GLOBAL globalidx) be xx_u1.
  b. Return $free_globalidx(globalidx).
3. If xx_u1 is of the case TABLE, then:
  a. Let (TABLE tableidx) be xx_u1.
  b. Return $free_tableidx(tableidx).
4. Assert: Due to validation, xx_u1 is of the case MEM.
5. Let (MEM memidx) be xx_u1.
6. Return $free_memidx(memidx).

free_addrtype addrtype
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_numtype numtype
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_packtype packtype
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_lanetype lt_u1
1. If the type of lt_u1 is numtype, then:
  a. Let numtype be lt_u1.
  b. Return $free_numtype(numtype).
2. Assert: Due to validation, the type of lt_u1 is packtype.
3. Let packtype be lt_u1.
4. Return $free_packtype(packtype).

free_vectype vectype
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_consttype consttype_u1
1. If the type of consttype_u1 is numtype, then:
  a. Let numtype be consttype_u1.
  b. Return $free_numtype(numtype).
2. Assert: Due to validation, the type of consttype_u1 is vectype.
3. Let vectype be consttype_u1.
4. Return $free_vectype(vectype).

free_absheaptype absheaptype
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_typevar tv_u1
1. If tv_u1 is of the case _IDX, then:
  a. Let (_IDX typeidx) be tv_u1.
  b. Return $free_typeidx(typeidx).
2. Assert: Due to validation, tv_u1 is of the case REC.
3. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_heaptype ht_u1
1. If the type of ht_u1 is absheaptype, then:
  a. Let absheaptype be ht_u1.
  b. Return $free_absheaptype(absheaptype).
2. Assert: Due to validation, the type of ht_u1 is typeuse.
3. Let typeuse be ht_u1.
4. Return $free_typeuse(typeuse).

free_reftype (REF nul heaptype)
1. Return $free_heaptype(heaptype).

free_typeuse yy_u1
1. If the type of yy_u1 is typevar, then:
  a. Let typevar be yy_u1.
  b. Return $free_typevar(typevar).
2. Assert: Due to validation, the type of yy_u1 is deftype.
3. Let deftype be yy_u1.
4. Return $free_deftype(deftype).

free_valtype t_u1
1. If the type of t_u1 is numtype, then:
  a. Let numtype be t_u1.
  b. Return $free_numtype(numtype).
2. If the type of t_u1 is vectype, then:
  a. Let vectype be t_u1.
  b. Return $free_vectype(vectype).
3. If the type of t_u1 is reftype, then:
  a. Let reftype be t_u1.
  b. Return $free_reftype(reftype).
4. Assert: Due to validation, (t_u1 = BOT).
5. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_resulttype valtype*
1. Return $free_list($free_valtype(valtype)*).

free_storagetype zt_u1
1. If the type of zt_u1 is valtype, then:
  a. Let valtype be zt_u1.
  b. Return $free_valtype(valtype).
2. Assert: Due to validation, the type of zt_u1 is packtype.
3. Let packtype be zt_u1.
4. Return $free_packtype(packtype).

free_fieldtype (mut, storagetype)
1. Return $free_storagetype(storagetype).

free_structtype fieldtype*
1. Return $free_list($free_fieldtype(fieldtype)*).

free_arraytype fieldtype
1. Return $free_fieldtype(fieldtype).

free_functype resulttype_1 -> resulttype_2
1. Return $free_resulttype(resulttype_1) ++ $free_resulttype(resulttype_2).

free_comptype ct_u1
1. If ct_u1 is of the case STRUCT, then:
  a. Let (STRUCT structtype) be ct_u1.
  b. Return $free_structtype(structtype).
2. If ct_u1 is of the case ARRAY, then:
  a. Let (ARRAY arraytype) be ct_u1.
  b. Return $free_arraytype(arraytype).
3. Assert: Due to validation, ct_u1 is of the case FUNC.
4. Let (FUNC functype) be ct_u1.
5. Return $free_functype(functype).

free_subtype (SUB fin typeuse* comptype)
1. Return $free_list($free_typeuse(typeuse)*) ++ $free_comptype(comptype).

free_rectype (REC subtype*)
1. Return $free_list($free_subtype(subtype)*).

free_deftype (DEF rectype n)
1. Return $free_rectype(rectype).

free_globaltype (mut, valtype)
1. Return $free_valtype(valtype).

free_tabletype (addrtype, limits, reftype)
1. Return $free_addrtype(addrtype) ++ $free_reftype(reftype).

free_memtype addrtype limits PAGE
1. Return $free_addrtype(addrtype).

free_tagtype deftype
1. Return $free_deftype(deftype).

free_elemtype reftype
1. Return $free_reftype(reftype).

free_datatype OK
1. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_externtype xt_u1
1. If xt_u1 is of the case FUNC, then:
  a. Let (FUNC typeuse) be xt_u1.
  b. Return $free_typeuse(typeuse).
2. If xt_u1 is of the case GLOBAL, then:
  a. Let (GLOBAL globaltype) be xt_u1.
  b. Return $free_globaltype(globaltype).
3. If xt_u1 is of the case TABLE, then:
  a. Let (TABLE tabletype) be xt_u1.
  b. Return $free_tabletype(tabletype).
4. If xt_u1 is of the case MEM, then:
  a. Let (MEM memtype) be xt_u1.
  b. Return $free_memtype(memtype).
5. Assert: Due to validation, xt_u1 is of the case TAG.
6. Let (TAG tagtype) be xt_u1.
7. Return $free_tagtype(tagtype).

free_moduletype externtype_1* -> externtype_2*
1. Return $free_list($free_externtype(externtype_1)*) ++ $free_list($free_externtype(externtype_2)*).

free_shape lanetype X dim
1. Return $free_lanetype(lanetype).

free_blocktype bt_u1
1. If bt_u1 is of the case _RESULT, then:
  a. Let (_RESULT valtype?) be bt_u1.
  b. Return $free_opt($free_valtype(valtype)?).
2. Assert: Due to validation, bt_u1 is of the case _IDX.
3. Let (_IDX funcidx) be bt_u1.
4. Return $free_funcidx(funcidx).

shift_labelidxs l_u1*
1. If (l_u1* = []), then:
  a. Return [].
2. Let [labelidx_0] :: labelidx'* be l_u1*.
3. If (labelidx_0 = 0), then:
  a. Return $shift_labelidxs(labelidx'*).
4. Let [labelidx] :: labelidx'* be l_u1*.
5. Return [(labelidx - 1)] :: $shift_labelidxs(labelidx'*).

free_instr instr_u1
1. If (instr_u1 = NOP), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
2. If (instr_u1 = UNREACHABLE), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
3. If (instr_u1 = DROP), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
4. If instr_u1 is of the case SELECT, then:
  a. Let (SELECT valtype*?) be instr_u1.
  b. Return $free_opt($free_list($free_valtype(valtype)*)?).
5. If instr_u1 is of the case BLOCK, then:
  a. Let (BLOCK blocktype instr*) be instr_u1.
  b. Return $free_blocktype(blocktype) ++ $free_block(instr*).
6. If instr_u1 is of the case LOOP, then:
  a. Let (LOOP blocktype instr*) be instr_u1.
  b. Return $free_blocktype(blocktype) ++ $free_block(instr*).
7. If instr_u1 is of the case IF, then:
  a. Let (IF blocktype instr_1* ELSE instr_2*) be instr_u1.
  b. Return $free_blocktype(blocktype) ++ $free_block(instr_1*) ++ $free_block(instr_2*).
8. If instr_u1 is of the case BR, then:
  a. Let (BR labelidx) be instr_u1.
  b. Return $free_labelidx(labelidx).
9. If instr_u1 is of the case BR_IF, then:
  a. Let (BR_IF labelidx) be instr_u1.
  b. Return $free_labelidx(labelidx).
10. If instr_u1 is of the case BR_TABLE, then:
  a. Let (BR_TABLE labelidx* labelidx') be instr_u1.
  b. Return $free_list($free_labelidx(labelidx)*) ++ $free_labelidx(labelidx).
11. If instr_u1 is of the case BR_ON_NULL, then:
  a. Let (BR_ON_NULL labelidx) be instr_u1.
  b. Return $free_labelidx(labelidx).
12. If instr_u1 is of the case BR_ON_NON_NULL, then:
  a. Let (BR_ON_NON_NULL labelidx) be instr_u1.
  b. Return $free_labelidx(labelidx).
13. If instr_u1 is of the case BR_ON_CAST, then:
  a. Let (BR_ON_CAST labelidx reftype_1 reftype_2) be instr_u1.
  b. Return $free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2).
14. If instr_u1 is of the case BR_ON_CAST_FAIL, then:
  a. Let (BR_ON_CAST_FAIL labelidx reftype_1 reftype_2) be instr_u1.
  b. Return $free_labelidx(labelidx) ++ $free_reftype(reftype_1) ++ $free_reftype(reftype_2).
15. If instr_u1 is of the case CALL, then:
  a. Let (CALL funcidx) be instr_u1.
  b. Return $free_funcidx(funcidx).
16. If instr_u1 is of the case CALL_REF, then:
  a. Let (CALL_REF typeuse) be instr_u1.
  b. Return $free_typeuse(typeuse).
17. If instr_u1 is of the case CALL_INDIRECT, then:
  a. Let (CALL_INDIRECT tableidx typeuse) be instr_u1.
  b. Return $free_tableidx(tableidx) ++ $free_typeuse(typeuse).
18. If (instr_u1 = RETURN), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
19. If instr_u1 is of the case RETURN_CALL, then:
  a. Let (RETURN_CALL funcidx) be instr_u1.
  b. Return $free_funcidx(funcidx).
20. If instr_u1 is of the case RETURN_CALL_REF, then:
  a. Let (RETURN_CALL_REF typeuse) be instr_u1.
  b. Return $free_typeuse(typeuse).
21. If instr_u1 is of the case RETURN_CALL_INDIRECT, then:
  a. Let (RETURN_CALL_INDIRECT tableidx typeuse) be instr_u1.
  b. Return $free_tableidx(tableidx) ++ $free_typeuse(typeuse).
22. If instr_u1 is of the case CONST, then:
  a. Let (numtype.CONST numlit) be instr_u1.
  b. Return $free_numtype(numtype).
23. If instr_u1 is of the case UNOP, then:
  a. Let (UNOP numtype unop) be instr_u1.
  b. Return $free_numtype(numtype).
24. If instr_u1 is of the case BINOP, then:
  a. Let (BINOP numtype binop) be instr_u1.
  b. Return $free_numtype(numtype).
25. If instr_u1 is of the case TESTOP, then:
  a. Let (TESTOP numtype testop) be instr_u1.
  b. Return $free_numtype(numtype).
26. If instr_u1 is of the case RELOP, then:
  a. Let (RELOP numtype relop) be instr_u1.
  b. Return $free_numtype(numtype).
27. If instr_u1 is of the case CVTOP, then:
  a. Let (CVTOP numtype_1 numtype_2 cvtop) be instr_u1.
  b. Return $free_numtype(numtype_1) ++ $free_numtype(numtype_2).
28. If instr_u1 is of the case VCONST, then:
  a. Let (vectype.CONST veclit) be instr_u1.
  b. Return $free_vectype(vectype).
29. If instr_u1 is of the case VVUNOP, then:
  a. Let (VVUNOP vectype vvunop) be instr_u1.
  b. Return $free_vectype(vectype).
30. If instr_u1 is of the case VVBINOP, then:
  a. Let (VVBINOP vectype vvbinop) be instr_u1.
  b. Return $free_vectype(vectype).
31. If instr_u1 is of the case VVTERNOP, then:
  a. Let (VVTERNOP vectype vvternop) be instr_u1.
  b. Return $free_vectype(vectype).
32. If instr_u1 is of the case VVTESTOP, then:
  a. Let (VVTESTOP vectype vvtestop) be instr_u1.
  b. Return $free_vectype(vectype).
33. If instr_u1 is of the case VUNOP, then:
  a. Let (VUNOP shape vunop) be instr_u1.
  b. Return $free_shape(shape).
34. If instr_u1 is of the case VBINOP, then:
  a. Let (VBINOP shape vbinop) be instr_u1.
  b. Return $free_shape(shape).
35. If instr_u1 is of the case VTERNOP, then:
  a. Let (VTERNOP shape vternop) be instr_u1.
  b. Return $free_shape(shape).
36. If instr_u1 is of the case VTESTOP, then:
  a. Let (VTESTOP shape vtestop) be instr_u1.
  b. Return $free_shape(shape).
37. If instr_u1 is of the case VRELOP, then:
  a. Let (VRELOP shape vrelop) be instr_u1.
  b. Return $free_shape(shape).
38. If instr_u1 is of the case VSHIFTOP, then:
  a. Let (VSHIFTOP ishape vshiftop) be instr_u1.
  b. Return $free_shape(ishape).
39. If instr_u1 is of the case VBITMASK, then:
  a. Let (VBITMASK ishape) be instr_u1.
  b. Return $free_shape(ishape).
40. If instr_u1 is of the case VSWIZZLOP, then:
  a. Let (VSWIZZLOP bshape vswizzlop) be instr_u1.
  b. Return $free_shape(bshape).
41. If instr_u1 is of the case VSHUFFLE, then:
  a. Let (VSHUFFLE bshape laneidx*) be instr_u1.
  b. Return $free_shape(bshape).
42. If instr_u1 is of the case VEXTUNOP, then:
  a. Let (VEXTUNOP ishape_1 ishape_2 vextunop) be instr_u1.
  b. Return $free_shape(ishape_1) ++ $free_shape(ishape_2).
43. If instr_u1 is of the case VEXTBINOP, then:
  a. Let (VEXTBINOP ishape_1 ishape_2 vextbinop) be instr_u1.
  b. Return $free_shape(ishape_1) ++ $free_shape(ishape_2).
44. If instr_u1 is of the case VNARROW, then:
  a. Let (VNARROW ishape_1 ishape_2 sx) be instr_u1.
  b. Return $free_shape(ishape_1) ++ $free_shape(ishape_2).
45. If instr_u1 is of the case VCVTOP, then:
  a. Let (VCVTOP shape_1 shape_2 vcvtop half? zero?) be instr_u1.
  b. Return $free_shape(shape_1) ++ $free_shape(shape_2).
46. If instr_u1 is of the case VSPLAT, then:
  a. Let (VSPLAT shape) be instr_u1.
  b. Return $free_shape(shape).
47. If instr_u1 is of the case VEXTRACT_LANE, then:
  a. Let (VEXTRACT_LANE shape sx? laneidx) be instr_u1.
  b. Return $free_shape(shape).
48. If instr_u1 is of the case VREPLACE_LANE, then:
  a. Let (VREPLACE_LANE shape laneidx) be instr_u1.
  b. Return $free_shape(shape).
49. If instr_u1 is of the case REF.NULL, then:
  a. Let (REF.NULL heaptype) be instr_u1.
  b. Return $free_heaptype(heaptype).
50. If (instr_u1 = REF.IS_NULL), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
51. If (instr_u1 = REF.AS_NON_NULL), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
52. If (instr_u1 = REF.EQ), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
53. If instr_u1 is of the case REF.TEST, then:
  a. Let (REF.TEST reftype) be instr_u1.
  b. Return $free_reftype(reftype).
54. If instr_u1 is of the case REF.CAST, then:
  a. Let (REF.CAST reftype) be instr_u1.
  b. Return $free_reftype(reftype).
55. If instr_u1 is of the case REF.FUNC, then:
  a. Let (REF.FUNC funcidx) be instr_u1.
  b. Return $free_funcidx(funcidx).
56. If (instr_u1 = REF.I31), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
57. If instr_u1 is of the case I31.GET, then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
58. If instr_u1 is of the case STRUCT.NEW, then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
59. If instr_u1 is of the case STRUCT.NEW_DEFAULT, then:
  a. Let (STRUCT.NEW_DEFAULT typeidx) be instr_u1.
  b. Return $free_typeidx(typeidx).
60. If instr_u1 is of the case STRUCT.GET, then:
  a. Let (STRUCT.GET sx? typeidx u32) be instr_u1.
  b. Return $free_typeidx(typeidx).
61. If instr_u1 is of the case STRUCT.SET, then:
  a. Let (STRUCT.SET typeidx u32) be instr_u1.
  b. Return $free_typeidx(typeidx).
62. If instr_u1 is of the case ARRAY.NEW, then:
  a. Let (ARRAY.NEW typeidx) be instr_u1.
  b. Return $free_typeidx(typeidx).
63. If instr_u1 is of the case ARRAY.NEW_DEFAULT, then:
  a. Let (ARRAY.NEW_DEFAULT typeidx) be instr_u1.
  b. Return $free_typeidx(typeidx).
64. If instr_u1 is of the case ARRAY.NEW_FIXED, then:
  a. Let (ARRAY.NEW_FIXED typeidx u32) be instr_u1.
  b. Return $free_typeidx(typeidx).
65. If instr_u1 is of the case ARRAY.NEW_DATA, then:
  a. Let (ARRAY.NEW_DATA typeidx dataidx) be instr_u1.
  b. Return $free_typeidx(typeidx) ++ $free_dataidx(dataidx).
66. If instr_u1 is of the case ARRAY.NEW_ELEM, then:
  a. Let (ARRAY.NEW_ELEM typeidx elemidx) be instr_u1.
  b. Return $free_typeidx(typeidx) ++ $free_elemidx(elemidx).
67. If instr_u1 is of the case ARRAY.GET, then:
  a. Let (ARRAY.GET sx? typeidx) be instr_u1.
  b. Return $free_typeidx(typeidx).
68. If instr_u1 is of the case ARRAY.SET, then:
  a. Let (ARRAY.SET typeidx) be instr_u1.
  b. Return $free_typeidx(typeidx).
69. If (instr_u1 = ARRAY.LEN), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
70. If instr_u1 is of the case ARRAY.FILL, then:
  a. Let (ARRAY.FILL typeidx) be instr_u1.
  b. Return $free_typeidx(typeidx).
71. If instr_u1 is of the case ARRAY.COPY, then:
  a. Let (ARRAY.COPY typeidx_1 typeidx_2) be instr_u1.
  b. Return $free_typeidx(typeidx_1) ++ $free_typeidx(typeidx_2).
72. If instr_u1 is of the case ARRAY.INIT_DATA, then:
  a. Let (ARRAY.INIT_DATA typeidx dataidx) be instr_u1.
  b. Return $free_typeidx(typeidx) ++ $free_dataidx(dataidx).
73. If instr_u1 is of the case ARRAY.INIT_ELEM, then:
  a. Let (ARRAY.INIT_ELEM typeidx elemidx) be instr_u1.
  b. Return $free_typeidx(typeidx) ++ $free_elemidx(elemidx).
74. If (instr_u1 = EXTERN.CONVERT_ANY), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
75. If (instr_u1 = ANY.CONVERT_EXTERN), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
76. If instr_u1 is of the case LOCAL.GET, then:
  a. Let (LOCAL.GET localidx) be instr_u1.
  b. Return $free_localidx(localidx).
77. If instr_u1 is of the case LOCAL.SET, then:
  a. Let (LOCAL.SET localidx) be instr_u1.
  b. Return $free_localidx(localidx).
78. If instr_u1 is of the case LOCAL.TEE, then:
  a. Let (LOCAL.TEE localidx) be instr_u1.
  b. Return $free_localidx(localidx).
79. If instr_u1 is of the case GLOBAL.GET, then:
  a. Let (GLOBAL.GET globalidx) be instr_u1.
  b. Return $free_globalidx(globalidx).
80. If instr_u1 is of the case GLOBAL.SET, then:
  a. Let (GLOBAL.SET globalidx) be instr_u1.
  b. Return $free_globalidx(globalidx).
81. If instr_u1 is of the case TABLE.GET, then:
  a. Let (TABLE.GET tableidx) be instr_u1.
  b. Return $free_tableidx(tableidx).
82. If instr_u1 is of the case TABLE.SET, then:
  a. Let (TABLE.SET tableidx) be instr_u1.
  b. Return $free_tableidx(tableidx).
83. If instr_u1 is of the case TABLE.SIZE, then:
  a. Let (TABLE.SIZE tableidx) be instr_u1.
  b. Return $free_tableidx(tableidx).
84. If instr_u1 is of the case TABLE.GROW, then:
  a. Let (TABLE.GROW tableidx) be instr_u1.
  b. Return $free_tableidx(tableidx).
85. If instr_u1 is of the case TABLE.FILL, then:
  a. Let (TABLE.FILL tableidx) be instr_u1.
  b. Return $free_tableidx(tableidx).
86. If instr_u1 is of the case TABLE.COPY, then:
  a. Let (TABLE.COPY tableidx_1 tableidx_2) be instr_u1.
  b. Return $free_tableidx(tableidx_1) ++ $free_tableidx(tableidx_2).
87. If instr_u1 is of the case TABLE.INIT, then:
  a. Let (TABLE.INIT tableidx elemidx) be instr_u1.
  b. Return $free_tableidx(tableidx) ++ $free_elemidx(elemidx).
88. If instr_u1 is of the case ELEM.DROP, then:
  a. Let (ELEM.DROP elemidx) be instr_u1.
  b. Return $free_elemidx(elemidx).
89. If instr_u1 is of the case LOAD, then:
  a. Let (LOAD numtype loadop? memidx memarg) be instr_u1.
  b. Return $free_numtype(numtype) ++ $free_memidx(memidx).
90. If instr_u1 is of the case STORE, then:
  a. Let (STORE numtype storeop? memidx memarg) be instr_u1.
  b. Return $free_numtype(numtype) ++ $free_memidx(memidx).
91. If instr_u1 is of the case VLOAD, then:
  a. Let (VLOAD vectype vloadop? memidx memarg) be instr_u1.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
92. If instr_u1 is of the case VLOAD_LANE, then:
  a. Let (VLOAD_LANE vectype sz memidx memarg laneidx) be instr_u1.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
93. If instr_u1 is of the case VSTORE, then:
  a. Let (VSTORE vectype memidx memarg) be instr_u1.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
94. If instr_u1 is of the case VSTORE_LANE, then:
  a. Let (VSTORE_LANE vectype sz memidx memarg laneidx) be instr_u1.
  b. Return $free_vectype(vectype) ++ $free_memidx(memidx).
95. If instr_u1 is of the case MEMORY.SIZE, then:
  a. Let (MEMORY.SIZE memidx) be instr_u1.
  b. Return $free_memidx(memidx).
96. If instr_u1 is of the case MEMORY.GROW, then:
  a. Let (MEMORY.GROW memidx) be instr_u1.
  b. Return $free_memidx(memidx).
97. If instr_u1 is of the case MEMORY.FILL, then:
  a. Let (MEMORY.FILL memidx) be instr_u1.
  b. Return $free_memidx(memidx).
98. If instr_u1 is of the case MEMORY.COPY, then:
  a. Let (MEMORY.COPY memidx_1 memidx_2) be instr_u1.
  b. Return $free_memidx(memidx_1) ++ $free_memidx(memidx_2).
99. If instr_u1 is of the case MEMORY.INIT, then:
  a. Let (MEMORY.INIT memidx dataidx) be instr_u1.
  b. Return $free_memidx(memidx) ++ $free_dataidx(dataidx).
100. Assert: Due to validation, instr_u1 is of the case DATA.DROP.
101. Let (DATA.DROP dataidx) be instr_u1.
102. Return $free_dataidx(dataidx).

free_block instr*
1. Let free be $free_list($free_instr(instr)*).
2. Return free with .LABELS replaced by $shift_labelidxs(free.LABELS).

free_expr instr*
1. Return $free_list($free_instr(instr)*).

free_type (TYPE rectype)
1. Return $free_rectype(rectype).

free_local (LOCAL t)
1. Return $free_valtype(t).

free_func (FUNC typeidx local* expr)
1. Return $free_typeidx(typeidx) ++ $free_list($free_local(local)*) ++ $free_block(expr) with .LOCALS replaced by [].

free_global (GLOBAL globaltype expr)
1. Return $free_globaltype(globaltype) ++ $free_expr(expr).

free_table (TABLE tabletype expr)
1. Return $free_tabletype(tabletype) ++ $free_expr(expr).

free_mem (MEMORY memtype)
1. Return $free_memtype(memtype).

free_tag (TAG typeidx)
1. Return $free_typeidx(typeidx).

free_elemmode elemmode_u1
1. If elemmode_u1 is of the case ACTIVE, then:
  a. Let (ACTIVE tableidx expr) be elemmode_u1.
  b. Return $free_tableidx(tableidx) ++ $free_expr(expr).
2. If (elemmode_u1 = PASSIVE), then:
  a. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.
3. Assert: Due to validation, (elemmode_u1 = DECLARE).
4. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_elem (ELEM reftype expr* elemmode)
1. Return $free_reftype(reftype) ++ $free_list($free_expr(expr)*) ++ $free_elemmode(elemmode).

free_datamode datamode_u1
1. If datamode_u1 is of the case ACTIVE, then:
  a. Let (ACTIVE memidx expr) be datamode_u1.
  b. Return $free_memidx(memidx) ++ $free_expr(expr).
2. Assert: Due to validation, (datamode_u1 = PASSIVE).
3. Return { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; ELEMS: []; DATAS: []; LOCALS: []; LABELS: []; }.

free_data (DATA byte* datamode)
1. Return $free_datamode(datamode).

free_start (START funcidx)
1. Return $free_funcidx(funcidx).

free_export (EXPORT name externidx)
1. Return $free_externidx(externidx).

free_import (IMPORT name_1 name_2 externtype)
1. Return $free_externtype(externtype).

free_module (MODULE type* import* func* global* table* mem* tag* elem* data* start? export*)
1. Return $free_list($free_type(type)*) ++ $free_list($free_import(import)*) ++ $free_list($free_func(func)*) ++ $free_list($free_global(global)*) ++ $free_list($free_table(table)*) ++ $free_list($free_mem(mem)*) ++ $free_list($free_tag(tag)*) ++ $free_list($free_elem(elem)*) ++ $free_list($free_data(data)*) ++ $free_opt($free_start(start)?) ++ $free_list($free_export(export)*).

funcidx_module module
1. Return $free_module(module).FUNCS.

dataidx_funcs func*
1. Return $free_list($free_func(func)*).DATAS.

with_locals C localidx_u1* lct_u1*
1. If ((localidx_u1* = []) /\ (lct_u1* = [])), then:
  a. Return C.
2. Assert: Due to validation, (|lct_u1*| >= 1).
3. Let [lct_1] :: lct* be lct_u1*.
4. Assert: Due to validation, (|localidx_u1*| >= 1).
5. Let [x_1] :: x* be localidx_u1*.
6. Return $with_locals(C with .LOCALS[x_1] replaced by lct_1, x*, lct*).

clos_deftypes dt_u1*
1. If (dt_u1* = []), then:
  a. Return [].
2. Let dt* :: [dt_n] be dt_u1*.
3. Let dt'* be $clos_deftypes(dt*).
4. Return dt'* :: [$subst_all_deftype(dt_n, dt'*)].

clos_valtype C t
1. Let dt* be $clos_deftypes(C.TYPES).
2. Return $subst_all_valtype(t, dt*).

clos_deftype C dt
1. Let dt'* be $clos_deftypes(C.TYPES).
2. Return $subst_all_deftype(dt, dt'*).

clos_moduletype C mmt
1. Let dt* be $clos_deftypes(C.TYPES).
2. Return $subst_all_moduletype(mmt, dt*).

before yy_u1 x i
1. If the type of yy_u1 is deftype, then:
  a. Return true.
2. If yy_u1 is of the case _IDX, then:
  a. Let (_IDX typeidx) be yy_u1.
  b. Return (typeidx < x).
3. Assert: Due to validation, yy_u1 is of the case REC.
4. Let (REC j) be yy_u1.
5. Return (j < i).

unrollht C ht_u1
1. If the type of ht_u1 is deftype, then:
  a. Let deftype be ht_u1.
  b. Return $unrolldt(deftype).
2. If ht_u1 is of the case _IDX, then:
  a. Let (_IDX typeidx) be ht_u1.
  b. Return $unrolldt(C.TYPES[typeidx]).
3. Assert: Due to validation, ht_u1 is of the case REC.
4. Let (REC i) be ht_u1.
5. Return C.RECS[i].

default_ t_u1
1. If the type of t_u1 is Inn, then:
  a. Let Inn be t_u1.
  b. Return ?((Inn.CONST 0)).
2. If the type of t_u1 is Fnn, then:
  a. Let Fnn be t_u1.
  b. Return ?((Fnn.CONST $fzero($size(Fnn)))).
3. If the type of t_u1 is Vnn, then:
  a. Let Vnn be t_u1.
  b. Return ?((Vnn.CONST 0)).
4. Assert: Due to validation, t_u1 is of the case REF.
5. Let (REF NULL_opt_0 ht) be t_u1.
6. If (NULL_opt_0 = ?(NULL)), then:
  a. Return ?((REF.NULL ht)).
7. Assert: Due to validation, NULL_opt_0 is not defined.
8. Return ?().

funcidx_nonfuncs (global*, table*, mem*, elem*, data*)
1. Return $funcidx_module((MODULE [] [] [] global* table* mem* [] elem* data* ?() [])).

relaxed2 i X X_1 X_2
1. If $ND(), then:
  a. Return [X_1, X_2][i].
2. Return [X_1, X_2][0].

relaxed4 i X X_1 X_2 X_3 X_4
1. If $ND(), then:
  a. Return [X_1, X_2, X_3, X_4][i].
2. Return [X_1, X_2, X_3, X_4][0].

invibytes_ N b*
1. Let n be $ibytes__1^-1(N, b*).
2. Return n.

invfbytes_ N b*
1. Let p be $fbytes__1^-1(N, b*).
2. Return p.

signed_ N i
1. If (i < (2 ^ (N - 1))), then:
  a. Return i.
2. Assert: Due to validation, ((2 ^ (N - 1)) <= i).
3. Assert: Due to validation, (i < (2 ^ N)).
4. Return (i - (2 ^ N)).

invsigned_ N i
1. Let j be $signed__1^-1(N, i).
2. Return j.

sx zt_u1
1. If the type of zt_u1 is consttype, then:
  a. Return ?().
2. Assert: Due to validation, the type of zt_u1 is packtype.
3. Return ?(S).

zero lt_u1
1. If the type of lt_u1 is Jnn, then:
  a. Return 0.
2. Assert: Due to validation, the type of lt_u1 is Fnn.
3. Let Fnn be lt_u1.
4. Return $fzero($size(Fnn)).

bool b_u1
1. If (b_u1 = false), then:
  a. Return 0.
2. Assert: Due to validation, (b_u1 = true).
3. Return 1.

sat_u_ N i
1. If (i < 0), then:
  a. Return 0.
2. If (i > ((2 ^ N) - 1)), then:
  a. Return ((2 ^ N) - 1).
3. Return i.

sat_s_ N i
1. If (i < (- (2 ^ (N - 1)))), then:
  a. Return (- (2 ^ (N - 1))).
2. If (i > ((2 ^ (N - 1)) - 1)), then:
  a. Return ((2 ^ (N - 1)) - 1).
3. Return i.

ineg_ N i_1
1. Return $invsigned_(N, (- $signed_(N, i_1))).

iabs_ N i_1
1. If ($signed_(N, i_1) >= 0), then:
  a. Return i_1.
2. Return $ineg_(N, i_1).

iextend_ N M sx_u1 i
1. If (sx_u1 = U), then:
  a. Return (i \ (2 ^ M)).
2. Assert: Due to validation, (sx_u1 = S).
3. Return $invsigned_(N, $signed_(M, (i \ (2 ^ M)))).

iadd_ N i_1 i_2
1. Return ((i_1 + i_2) \ (2 ^ N)).

isub_ N i_1 i_2
1. Return ((((2 ^ N) + i_1) - i_2) \ (2 ^ N)).

imul_ N i_1 i_2
1. Return ((i_1 * i_2) \ (2 ^ N)).

iadd_sat_ N sx_u1 i_1 i_2
1. If (sx_u1 = U), then:
  a. Return $sat_u_(N, (i_1 + i_2)).
2. Assert: Due to validation, (sx_u1 = S).
3. Return $invsigned_(N, $sat_s_(N, ($signed_(N, i_1) + $signed_(N, i_2)))).

isub_sat_ N sx_u1 i_1 i_2
1. If (sx_u1 = U), then:
  a. Return $sat_u_(N, (i_1 - i_2)).
2. Assert: Due to validation, (sx_u1 = S).
3. Return $invsigned_(N, $sat_s_(N, ($signed_(N, i_1) - $signed_(N, i_2)))).

ieqz_ N i_1
1. Return $bool((i_1 = 0)).

inez_ N i_1
1. Return $bool((i_1 =/= 0)).

ieq_ N i_1 i_2
1. Return $bool((i_1 = i_2)).

ine_ N i_1 i_2
1. Return $bool((i_1 =/= i_2)).

ilt_ N sx_u1 i_1 i_2
1. If (sx_u1 = U), then:
  a. Return $bool((i_1 < i_2)).
2. Assert: Due to validation, (sx_u1 = S).
3. Return $bool(($signed_(N, i_1) < $signed_(N, i_2))).

igt_ N sx_u1 i_1 i_2
1. If (sx_u1 = U), then:
  a. Return $bool((i_1 > i_2)).
2. Assert: Due to validation, (sx_u1 = S).
3. Return $bool(($signed_(N, i_1) > $signed_(N, i_2))).

ile_ N sx_u1 i_1 i_2
1. If (sx_u1 = U), then:
  a. Return $bool((i_1 <= i_2)).
2. Assert: Due to validation, (sx_u1 = S).
3. Return $bool(($signed_(N, i_1) <= $signed_(N, i_2))).

ige_ N sx_u1 i_1 i_2
1. If (sx_u1 = U), then:
  a. Return $bool((i_1 >= i_2)).
2. Assert: Due to validation, (sx_u1 = S).
3. Return $bool(($signed_(N, i_1) >= $signed_(N, i_2))).

lpacknum_ lt_u1 c
1. If the type of lt_u1 is numtype, then:
  a. Return c.
2. Assert: Due to validation, the type of lt_u1 is packtype.
3. Let packtype be lt_u1.
4. Return $wrap__($size($lunpack(packtype)), $psize(packtype), c).

lunpacknum_ lt_u1 c
1. If the type of lt_u1 is numtype, then:
  a. Return c.
2. Assert: Due to validation, the type of lt_u1 is packtype.
3. Let packtype be lt_u1.
4. Return $extend__($psize(packtype), $size($lunpack(packtype)), U, c).

cpacknum_ zt_u1 c
1. If the type of zt_u1 is consttype, then:
  a. Return c.
2. Assert: Due to validation, the type of zt_u1 is packtype.
3. Let packtype be zt_u1.
4. Return $wrap__($size($lunpack(packtype)), $psize(packtype), c).

cunpacknum_ zt_u1 c
1. If the type of zt_u1 is consttype, then:
  a. Return c.
2. Assert: Due to validation, the type of zt_u1 is packtype.
3. Let packtype be zt_u1.
4. Return $extend__($psize(packtype), $size($lunpack(packtype)), U, c).

unop_ nt_u1 unop_u1 i_u1
1. If the type of nt_u1 is Inn, then:
  a. Let Inn be nt_u1.
  b. Let i be i_u1.
  c. If (unop_u1 = CLZ), then:
    1) Return [$iclz_($sizenn(Inn), i)].
  d. If (unop_u1 = CTZ), then:
    1) Return [$ictz_($sizenn(Inn), i)].
  e. If (unop_u1 = POPCNT), then:
    1) Return [$ipopcnt_($sizenn(Inn), i)].
  f. Assert: Due to validation, unop_u1 is of the case EXTEND.
  g. Let (EXTEND M) be unop_u1.
  h. Return [$iextend_($sizenn(Inn), M, S, i)].
2. Assert: Due to validation, the type of nt_u1 is Fnn.
3. Let Fnn be nt_u1.
4. Let f be i_u1.
5. If (unop_u1 = ABS), then:
  a. Return $fabs_($sizenn(Fnn), f).
6. If (unop_u1 = NEG), then:
  a. Return $fneg_($sizenn(Fnn), f).
7. If (unop_u1 = SQRT), then:
  a. Return $fsqrt_($sizenn(Fnn), f).
8. If (unop_u1 = CEIL), then:
  a. Return $fceil_($sizenn(Fnn), f).
9. If (unop_u1 = FLOOR), then:
  a. Return $ffloor_($sizenn(Fnn), f).
10. If (unop_u1 = TRUNC), then:
  a. Return $ftrunc_($sizenn(Fnn), f).
11. Assert: Due to validation, (unop_u1 = NEAREST).
12. Return $fnearest_($sizenn(Fnn), f).

binop_ nt_u1 binop_u1 i_u1 i_u2
1. If the type of nt_u1 is Inn, then:
  a. Let Inn be nt_u1.
  b. Let i_1 be i_u1.
  c. Let i_2 be i_u2.
  d. If (binop_u1 = ADD), then:
    1) Return [$iadd_($sizenn(Inn), i_1, i_2)].
  e. If (binop_u1 = SUB), then:
    1) Return [$isub_($sizenn(Inn), i_1, i_2)].
  f. If (binop_u1 = MUL), then:
    1) Return [$imul_($sizenn(Inn), i_1, i_2)].
  g. If binop_u1 is of the case DIV, then:
    1) Let (DIV sx) be binop_u1.
    2) Return $idiv_($sizenn(Inn), sx, i_1, i_2).
  h. If binop_u1 is of the case REM, then:
    1) Let (REM sx) be binop_u1.
    2) Return $irem_($sizenn(Inn), sx, i_1, i_2).
  i. If (binop_u1 = AND), then:
    1) Return [$iand_($sizenn(Inn), i_1, i_2)].
  j. If (binop_u1 = OR), then:
    1) Return [$ior_($sizenn(Inn), i_1, i_2)].
  k. If (binop_u1 = XOR), then:
    1) Return [$ixor_($sizenn(Inn), i_1, i_2)].
  l. If (binop_u1 = SHL), then:
    1) Return [$ishl_($sizenn(Inn), i_1, i_2)].
  m. If binop_u1 is of the case SHR, then:
    1) Let (SHR sx) be binop_u1.
    2) Return [$ishr_($sizenn(Inn), sx, i_1, i_2)].
  n. If (binop_u1 = ROTL), then:
    1) Return [$irotl_($sizenn(Inn), i_1, i_2)].
  o. If (binop_u1 = ROTR), then:
    1) Return [$irotr_($sizenn(Inn), i_1, i_2)].
2. Assert: Due to validation, the type of nt_u1 is Fnn.
3. Let Fnn be nt_u1.
4. Let f_1 be i_u1.
5. Let f_2 be i_u2.
6. If (binop_u1 = ADD), then:
  a. Return $fadd_($sizenn(Fnn), f_1, f_2).
7. If (binop_u1 = SUB), then:
  a. Return $fsub_($sizenn(Fnn), f_1, f_2).
8. If (binop_u1 = MUL), then:
  a. Return $fmul_($sizenn(Fnn), f_1, f_2).
9. If (binop_u1 = DIV), then:
  a. Return $fdiv_($sizenn(Fnn), f_1, f_2).
10. If (binop_u1 = MIN), then:
  a. Return $fmin_($sizenn(Fnn), f_1, f_2).
11. If (binop_u1 = MAX), then:
  a. Return $fmax_($sizenn(Fnn), f_1, f_2).
12. Assert: Due to validation, (binop_u1 = COPYSIGN).
13. Return $fcopysign_($sizenn(Fnn), f_1, f_2).

testop_ Inn EQZ i
1. Return $ieqz_($sizenn(Inn), i).

relop_ nt_u1 relop_u1 i_u1 i_u2
1. If the type of nt_u1 is Inn, then:
  a. Let Inn be nt_u1.
  b. Let i_1 be i_u1.
  c. Let i_2 be i_u2.
  d. If (relop_u1 = EQ), then:
    1) Return $ieq_($sizenn(Inn), i_1, i_2).
  e. If (relop_u1 = NE), then:
    1) Return $ine_($sizenn(Inn), i_1, i_2).
  f. If relop_u1 is of the case LT, then:
    1) Let (LT sx) be relop_u1.
    2) Return $ilt_($sizenn(Inn), sx, i_1, i_2).
  g. If relop_u1 is of the case GT, then:
    1) Let (GT sx) be relop_u1.
    2) Return $igt_($sizenn(Inn), sx, i_1, i_2).
  h. If relop_u1 is of the case LE, then:
    1) Let (LE sx) be relop_u1.
    2) Return $ile_($sizenn(Inn), sx, i_1, i_2).
  i. If relop_u1 is of the case GE, then:
    1) Let (GE sx) be relop_u1.
    2) Return $ige_($sizenn(Inn), sx, i_1, i_2).
2. Assert: Due to validation, the type of nt_u1 is Fnn.
3. Let Fnn be nt_u1.
4. Let f_1 be i_u1.
5. Let f_2 be i_u2.
6. If (relop_u1 = EQ), then:
  a. Return $feq_($sizenn(Fnn), f_1, f_2).
7. If (relop_u1 = NE), then:
  a. Return $fne_($sizenn(Fnn), f_1, f_2).
8. If (relop_u1 = LT), then:
  a. Return $flt_($sizenn(Fnn), f_1, f_2).
9. If (relop_u1 = GT), then:
  a. Return $fgt_($sizenn(Fnn), f_1, f_2).
10. If (relop_u1 = LE), then:
  a. Return $fle_($sizenn(Fnn), f_1, f_2).
11. Assert: Due to validation, (relop_u1 = GE).
12. Return $fge_($sizenn(Fnn), f_1, f_2).

cvtop__ nt_u1 nt_u3 cvtop_u1 i_u1
1. If the type of nt_u1 is Inn, then:
  a. Let Inn_1 be nt_u1.
  b. If the type of nt_u3 is Inn, then:
    1) Let Inn_2 be nt_u3.
    2) If cvtop_u1 is of the case EXTEND, then:
      a) Let (EXTEND sx) be cvtop_u1.
      b) Let i_1 be i_u1.
      c) Return [$extend__($sizenn1(Inn_1), $sizenn2(Inn_2), sx, i_1)].
    3) Let i_1 be i_u1.
    4) If (cvtop_u1 = WRAP), then:
      a) Return [$wrap__($sizenn1(Inn_1), $sizenn2(Inn_2), i_1)].
2. If the type of nt_u1 is Fnn, then:
  a. Let Fnn_1 be nt_u1.
  b. If the type of nt_u3 is Inn, then:
    1) Let Inn_2 be nt_u3.
    2) If cvtop_u1 is of the case TRUNC, then:
      a) Let (TRUNC sx) be cvtop_u1.
      b) Let f_1 be i_u1.
      c) Return $trunc__($sizenn1(Fnn_1), $sizenn2(Inn_2), sx, f_1).
    3) If cvtop_u1 is of the case TRUNC_SAT, then:
      a) Let (TRUNC_SAT sx) be cvtop_u1.
      b) Let f_1 be i_u1.
      c) Return $trunc_sat__($sizenn1(Fnn_1), $sizenn2(Inn_2), sx, f_1).
3. If the type of nt_u1 is Inn, then:
  a. Let Inn_1 be nt_u1.
  b. If the type of nt_u3 is Fnn, then:
    1) Let Fnn_2 be nt_u3.
    2) If cvtop_u1 is of the case CONVERT, then:
      a) Let (CONVERT sx) be cvtop_u1.
      b) Let i_1 be i_u1.
      c) Return [$convert__($sizenn1(Inn_1), $sizenn2(Fnn_2), sx, i_1)].
4. If the type of nt_u1 is Fnn, then:
  a. Let Fnn_1 be nt_u1.
  b. If the type of nt_u3 is Fnn, then:
    1) Let Fnn_2 be nt_u3.
    2) Let f_1 be i_u1.
    3) If (cvtop_u1 = PROMOTE), then:
      a) Return $promote__($sizenn1(Fnn_1), $sizenn2(Fnn_2), f_1).
    4) If (cvtop_u1 = DEMOTE), then:
      a) Return $demote__($sizenn1(Fnn_1), $sizenn2(Fnn_2), f_1).
5. If the type of nt_u1 is Inn, then:
  a. Let Inn_1 be nt_u1.
  b. If the type of nt_u3 is Fnn, then:
    1) Let Fnn_2 be nt_u3.
    2) Let i_1 be i_u1.
    3) If ((cvtop_u1 = REINTERPRET) /\ ($size(Inn_1) = $size(Fnn_2))), then:
      a) Return [$reinterpret__(Inn_1, Fnn_2, i_1)].
6. Assert: Due to validation, the type of nt_u1 is Fnn.
7. Let Fnn_1 be nt_u1.
8. Assert: Due to validation, the type of nt_u3 is Inn.
9. Let Inn_2 be nt_u3.
10. Let f_1 be i_u1.
11. Assert: Due to validation, (cvtop_u1 = REINTERPRET).
12. Assert: Due to validation, ($size(Fnn_1) = $size(Inn_2)).
13. Return [$reinterpret__(Fnn_1, Inn_2, f_1)].

invlanes_ sh c*
1. Let vc be $lanes__1^-1(sh, c*).
2. Return vc.

half__ lt_u1 X M_1 lt_u2 X M_2 half_u1 i j
1. If (the type of lt_u1 is Jnn /\ the type of lt_u2 is Jnn), then:
  a. If (half_u1 = LOW), then:
    1) Return i.
  b. If (half_u1 = HIGH), then:
    1) Return j.
2. Assert: Due to validation, the type of lt_u2 is Fnn.
3. Assert: Due to validation, (half_u1 = LOW).
4. Return i.

iswizzle_lane_ N c* i
1. If (i < |c*|), then:
  a. Return c*[i].
2. Return 0.

irelaxed_swizzle_lane_ N c* i
1. If (i < |c*|), then:
  a. Return c*[i].
2. If ($signed_(N, i) < 0), then:
  a. Return 0.
3. Return $relaxed2($R_swizzle(), iN(N), 0, c*[(i \ |c*|)]).

ivunop_ Jnn X M $f_ v_1
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c* be $f_($lsizenn(Jnn), c_1)*.
3. Return [$invlanes_(Jnn X M, c*)].

fvunop_ Fnn X M $f_ v_1
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $f_($sizenn(Fnn), c_1)*).
3. Return $invlanes_(Fnn X M, c*)*.

ivbinop_ Jnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be $f_($lsizenn(Jnn), c_1, c_2)*.
4. Return [$invlanes_(Jnn X M, c*)].

ivbinopsx_ Jnn X M $f_ sx v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be $f_($lsizenn(Jnn), sx, c_1, c_2)*.
4. Return [$invlanes_(Jnn X M, c*)].

ivbinopsxnd_ Jnn X M $f_ sx v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c** be $setproduct_(lane_((Jnn : Jnn <: lanetype)), $f_($lsizenn(Jnn), sx, c_1, c_2)*).
4. Return $invlanes_(Jnn X M, c*)*.

fvbinop_ Fnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c_2* be $lanes_(Fnn X M, v_2).
3. Let c** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $f_($sizenn(Fnn), c_1, c_2)*).
4. Return $invlanes_(Fnn X M, c*)*.

ivternopnd_ Jnn X M $f_ v_1 v_2 v_3
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c_3* be $lanes_(Jnn X M, v_3).
4. Let c** be $setproduct_(lane_((Jnn : Jnn <: lanetype)), $f_($lsizenn(Jnn), c_1, c_2, c_3)*).
5. Return $invlanes_(Jnn X M, c*)*.

fvternop_ Fnn X M $f_ v_1 v_2 v_3
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c_2* be $lanes_(Fnn X M, v_2).
3. Let c_3* be $lanes_(Fnn X M, v_3).
4. Let c** be $setproduct_(lane_((Fnn : Fnn <: lanetype)), $f_($sizenn(Fnn), c_1, c_2, c_3)*).
5. Return $invlanes_(Fnn X M, c*)*.

ivtestop_ Jnn X M $f_ v_1
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c* be $f_($lsizenn(Jnn), c_1)*.
3. Return $prod(c*).

fvtestop_ Fnn X M $f_ v_1
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c* be $f_($sizenn(Fnn), c_1)*.
3. Return $prod(c*).

ivrelop_ Jnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be $extend__(1, $lsizenn(Jnn), S, $f_($lsizenn(Jnn), c_1, c_2))*.
4. Return $invlanes_(Jnn X M, c*).

ivrelopsx_ Jnn X M $f_ sx v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be $extend__(1, $lsizenn(Jnn), S, $f_($lsizenn(Jnn), sx, c_1, c_2))*.
4. Return $invlanes_(Jnn X M, c*).

fvrelop_ Fnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Fnn X M, v_1).
2. Let c_2* be $lanes_(Fnn X M, v_2).
3. Assert: Due to validation, the type of $size^-1($size(Fnn)) is Inn.
4. Let Inn be $size^-1($size(Fnn)).
5. Let c* be $extend__(1, $sizenn(Fnn), S, $f_($sizenn(Fnn), c_1, c_2))*.
6. Return $invlanes_(Inn X M, c*).

ivshiftop_ Jnn X M $f_ v_1 i
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c* be $f_($lsizenn(Jnn), c_1, i)*.
3. Return $invlanes_(Jnn X M, c*).

ivshiftopsx_ Jnn X M $f_ sx v_1 i
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c* be $f_($lsizenn(Jnn), sx, c_1, i)*.
3. Return $invlanes_(Jnn X M, c*).

ivbitmaskop_ Jnn X M v_1
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c be $ibits__1^-1(32, $ilt_($lsize(Jnn), S, c_1, 0)*).
3. Return c.

ivswizzlop_ Jnn X M $f_ v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be $f_($lsizenn(Jnn), c_1*, c_2)*.
4. Return $invlanes_(Jnn X M, c*).

ivshufflop_ Jnn X M i* v_1 v_2
1. Let c_1* be $lanes_(Jnn X M, v_1).
2. Let c_2* be $lanes_(Jnn X M, v_2).
3. Let c* be c_1* :: c_2*[i]*.
4. Return $invlanes_(Jnn X M, c*).

vvunop_ Vnn NOT v
1. Return [$inot_($vsizenn(Vnn), v)].

vvbinop_ Vnn vvbinop_u1 v_1 v_2
1. If (vvbinop_u1 = AND), then:
  a. Return [$iand_($vsizenn(Vnn), v_1, v_2)].
2. If (vvbinop_u1 = ANDNOT), then:
  a. Return [$iandnot_($vsizenn(Vnn), v_1, v_2)].
3. If (vvbinop_u1 = OR), then:
  a. Return [$ior_($vsizenn(Vnn), v_1, v_2)].
4. Assert: Due to validation, (vvbinop_u1 = XOR).
5. Return [$ixor_($vsizenn(Vnn), v_1, v_2)].

vvternop_ Vnn BITSELECT v_1 v_2 v_3
1. Return [$ibitselect_($vsizenn(Vnn), v_1, v_2, v_3)].

vunop_ lt_u1 X M vunop_u1 v
1. If the type of lt_u1 is Fnn, then:
  a. Let Fnn be lt_u1.
  b. If (vunop_u1 = ABS), then:
    1) Return $fvunop_(Fnn X M, $fabs_, v).
  c. If (vunop_u1 = NEG), then:
    1) Return $fvunop_(Fnn X M, $fneg_, v).
  d. If (vunop_u1 = SQRT), then:
    1) Return $fvunop_(Fnn X M, $fsqrt_, v).
  e. If (vunop_u1 = CEIL), then:
    1) Return $fvunop_(Fnn X M, $fceil_, v).
  f. If (vunop_u1 = FLOOR), then:
    1) Return $fvunop_(Fnn X M, $ffloor_, v).
  g. If (vunop_u1 = TRUNC), then:
    1) Return $fvunop_(Fnn X M, $ftrunc_, v).
  h. If (vunop_u1 = NEAREST), then:
    1) Return $fvunop_(Fnn X M, $fnearest_, v).
2. Assert: Due to validation, the type of lt_u1 is Jnn.
3. Let Jnn be lt_u1.
4. If (vunop_u1 = ABS), then:
  a. Return $ivunop_(Jnn X M, $iabs_, v).
5. If (vunop_u1 = NEG), then:
  a. Return $ivunop_(Jnn X M, $ineg_, v).
6. Assert: Due to validation, (vunop_u1 = POPCNT).
7. Return $ivunop_(Jnn X M, $ipopcnt_, v).

vbinop_ lt_u1 X M vbinop_u1 v_1 v_2
1. If the type of lt_u1 is Jnn, then:
  a. Let Jnn be lt_u1.
  b. If (vbinop_u1 = ADD), then:
    1) Return $ivbinop_(Jnn X M, $iadd_, v_1, v_2).
  c. If (vbinop_u1 = SUB), then:
    1) Return $ivbinop_(Jnn X M, $isub_, v_1, v_2).
  d. If (vbinop_u1 = MUL), then:
    1) Return $ivbinop_(Jnn X M, $imul_, v_1, v_2).
  e. If vbinop_u1 is of the case ADD_SAT, then:
    1) Let (ADD_SAT sx) be vbinop_u1.
    2) Return $ivbinopsx_(Jnn X M, $iadd_sat_, sx, v_1, v_2).
  f. If vbinop_u1 is of the case SUB_SAT, then:
    1) Let (SUB_SAT sx) be vbinop_u1.
    2) Return $ivbinopsx_(Jnn X M, $isub_sat_, sx, v_1, v_2).
  g. If vbinop_u1 is of the case MIN, then:
    1) Let (MIN sx) be vbinop_u1.
    2) Return $ivbinopsx_(Jnn X M, $imin_, sx, v_1, v_2).
  h. If vbinop_u1 is of the case MAX, then:
    1) Let (MAX sx) be vbinop_u1.
    2) Return $ivbinopsx_(Jnn X M, $imax_, sx, v_1, v_2).
  i. If (vbinop_u1 = AVGRU), then:
    1) Return $ivbinopsx_(Jnn X M, $iavgr_, U, v_1, v_2).
  j. If (vbinop_u1 = Q15MULR_SATS), then:
    1) Return $ivbinopsx_(Jnn X M, $iq15mulr_sat_, S, v_1, v_2).
  k. If (vbinop_u1 = RELAXED_Q15MULRS), then:
    1) Return $ivbinopsxnd_(Jnn X M, $irelaxed_q15mulr_, S, v_1, v_2).
2. Assert: Due to validation, the type of lt_u1 is Fnn.
3. Let Fnn be lt_u1.
4. If (vbinop_u1 = ADD), then:
  a. Return $fvbinop_(Fnn X M, $fadd_, v_1, v_2).
5. If (vbinop_u1 = SUB), then:
  a. Return $fvbinop_(Fnn X M, $fsub_, v_1, v_2).
6. If (vbinop_u1 = MUL), then:
  a. Return $fvbinop_(Fnn X M, $fmul_, v_1, v_2).
7. If (vbinop_u1 = DIV), then:
  a. Return $fvbinop_(Fnn X M, $fdiv_, v_1, v_2).
8. If (vbinop_u1 = MIN), then:
  a. Return $fvbinop_(Fnn X M, $fmin_, v_1, v_2).
9. If (vbinop_u1 = MAX), then:
  a. Return $fvbinop_(Fnn X M, $fmax_, v_1, v_2).
10. If (vbinop_u1 = PMIN), then:
  a. Return $fvbinop_(Fnn X M, $fpmin_, v_1, v_2).
11. If (vbinop_u1 = PMAX), then:
  a. Return $fvbinop_(Fnn X M, $fpmax_, v_1, v_2).
12. If (vbinop_u1 = RELAXED_MIN), then:
  a. Return $fvbinop_(Fnn X M, $frelaxed_min_, v_1, v_2).
13. Assert: Due to validation, (vbinop_u1 = RELAXED_MAX).
14. Return $fvbinop_(Fnn X M, $frelaxed_max_, v_1, v_2).

vternop_ lt_u1 X M vternop_u1 v_1 v_2 v_3
1. If the type of lt_u1 is Jnn, then:
  a. Let Jnn be lt_u1.
  b. If (vternop_u1 = RELAXED_LANESELECT), then:
    1) Return $ivternopnd_(Jnn X M, $irelaxed_laneselect_, v_1, v_2, v_3).
2. Assert: Due to validation, the type of lt_u1 is Fnn.
3. Let Fnn be lt_u1.
4. If (vternop_u1 = RELAXED_MADD), then:
  a. Return $fvternop_(Fnn X M, $frelaxed_madd_, v_1, v_2, v_3).
5. Assert: Due to validation, (vternop_u1 = RELAXED_NMADD).
6. Return $fvternop_(Fnn X M, $frelaxed_nmadd_, v_1, v_2, v_3).

vtestop_ Jnn X M ALL_TRUE v
1. Return $ivtestop_(Jnn X M, $inez_, v).

vrelop_ lt_u1 X M vrelop_u1 v_1 v_2
1. If the type of lt_u1 is Jnn, then:
  a. Let Jnn be lt_u1.
  b. If (vrelop_u1 = EQ), then:
    1) Return $ivrelop_(Jnn X M, $ieq_, v_1, v_2).
  c. If (vrelop_u1 = NE), then:
    1) Return $ivrelop_(Jnn X M, $ine_, v_1, v_2).
  d. If vrelop_u1 is of the case LT, then:
    1) Let (LT sx) be vrelop_u1.
    2) Return $ivrelopsx_(Jnn X M, $ilt_, sx, v_1, v_2).
  e. If vrelop_u1 is of the case GT, then:
    1) Let (GT sx) be vrelop_u1.
    2) Return $ivrelopsx_(Jnn X M, $igt_, sx, v_1, v_2).
  f. If vrelop_u1 is of the case LE, then:
    1) Let (LE sx) be vrelop_u1.
    2) Return $ivrelopsx_(Jnn X M, $ile_, sx, v_1, v_2).
  g. If vrelop_u1 is of the case GE, then:
    1) Let (GE sx) be vrelop_u1.
    2) Return $ivrelopsx_(Jnn X M, $ige_, sx, v_1, v_2).
2. Assert: Due to validation, the type of lt_u1 is Fnn.
3. Let Fnn be lt_u1.
4. If (vrelop_u1 = EQ), then:
  a. Return $fvrelop_(Fnn X M, $feq_, v_1, v_2).
5. If (vrelop_u1 = NE), then:
  a. Return $fvrelop_(Fnn X M, $fne_, v_1, v_2).
6. If (vrelop_u1 = LT), then:
  a. Return $fvrelop_(Fnn X M, $flt_, v_1, v_2).
7. If (vrelop_u1 = GT), then:
  a. Return $fvrelop_(Fnn X M, $fgt_, v_1, v_2).
8. If (vrelop_u1 = LE), then:
  a. Return $fvrelop_(Fnn X M, $fle_, v_1, v_2).
9. Assert: Due to validation, (vrelop_u1 = GE).
10. Return $fvrelop_(Fnn X M, $fge_, v_1, v_2).

lcvtop__ lt_u3 X M_1 lt_u1 X M_2 vcvtop_u1 c_1
1. If the type of lt_u3 is Jnn, then:
  a. Let Jnn_1 be lt_u3.
  b. If the type of lt_u1 is Jnn, then:
    1) Let Jnn_2 be lt_u1.
    2) If vcvtop_u1 is of the case EXTEND, then:
      a) Let (EXTEND sx) be vcvtop_u1.
      b) Let c be $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx, c_1).
      c) Return [c].
  c. If the type of lt_u1 is Fnn, then:
    1) Let Fnn_2 be lt_u1.
    2) If vcvtop_u1 is of the case CONVERT, then:
      a) Let (CONVERT sx) be vcvtop_u1.
      b) Let c be $convert__($lsizenn1(Jnn_1), $lsizenn2(Fnn_2), sx, c_1).
      c) Return [c].
2. Assert: Due to validation, the type of lt_u3 is Fnn.
3. Let Fnn_1 be lt_u3.
4. If the type of lt_u1 is Inn, then:
  a. Let Inn_2 be lt_u1.
  b. If vcvtop_u1 is of the case TRUNC_SAT, then:
    1) Let (TRUNC_SAT sx) be vcvtop_u1.
    2) Let c? be $trunc_sat__($lsizenn1(Fnn_1), $lsizenn2(Inn_2), sx, c_1).
    3) Return c?.
  c. If vcvtop_u1 is of the case RELAXED_TRUNC, then:
    1) Let (RELAXED_TRUNC sx) be vcvtop_u1.
    2) Let c? be $relaxed_trunc__($lsizenn1(Fnn_1), $lsizenn2(Inn_2), sx, c_1).
    3) Return c?.
5. Assert: Due to validation, the type of lt_u1 is Fnn.
6. Let Fnn_2 be lt_u1.
7. If (vcvtop_u1 = DEMOTE), then:
  a. Let c* be $demote__($lsizenn1(Fnn_1), $lsizenn2(Fnn_2), c_1).
  b. Return c*.
8. Assert: Due to validation, (vcvtop_u1 = PROMOTE).
9. Let c* be $promote__($lsizenn1(Fnn_1), $lsizenn2(Fnn_2), c_1).
10. Return c*.

vcvtop__ Lnn_1 X n_u1 Lnn_2 X n_u2 vcvtop half_u1? zero_u1? v_1
1. Let M be n_u2.
2. If (half_u1? is not defined /\ (zero_u1? is not defined /\ (n_u1 = M))), then:
  a. Let c_1* be $lanes_(Lnn_1 X M, v_1).
  b. Let c** be $setproduct_(lane_(Lnn_2), $lcvtop__(Lnn_1 X M, Lnn_2 X M, vcvtop, c_1)*).
  c. Let v be an element of $invlanes_(Lnn_2 X M, c*)*.
  d. Return v.
3. Let M_1 be n_u1.
4. Let M_2 be n_u2.
5. If (zero_u1? is not defined /\ half_u1? is defined), then:
  a. Let ?(half) be half_u1?.
  b. Let c_1* be $lanes_(Lnn_1 X M_1, v_1)[$half__(Lnn_1 X M_1, Lnn_2 X M_2, half, 0, M_2) : M_2].
  c. Let c** be $setproduct_(lane_(Lnn_2), $lcvtop__(Lnn_1 X M_1, Lnn_2 X M_2, vcvtop, c_1)*).
  d. Let v be an element of $invlanes_(Lnn_2 X M_2, c*)*.
  e. Return v.
6. Assert: Due to validation, half_u1? is not defined.
7. Assert: Due to validation, zero_u1? is defined.
8. Let c_1* be $lanes_(Lnn_1 X M_1, v_1).
9. Let c** be $setproduct_(lane_(Lnn_2), $lcvtop__(Lnn_1 X M_1, Lnn_2 X M_2, vcvtop, c_1)* :: [$zero(Lnn_2)]^M_1).
10. Let v be an element of $invlanes_(Lnn_2 X M_2, c*)*.
11. Return v.

vshiftop_ Jnn X M vshiftop_u1 v i
1. If (vshiftop_u1 = SHL), then:
  a. Return $ivshiftop_(Jnn X M, $ishl_, v, i).
2. Assert: Due to validation, vshiftop_u1 is of the case SHR.
3. Let (SHR sx) be vshiftop_u1.
4. Return $ivshiftopsx_(Jnn X M, $ishr_, sx, v, i).

vbitmaskop_ Jnn X M v
1. Return $ivbitmaskop_(Jnn X M, v).

vswizzlop_ I8 X M swizzlop_u1 v_1 v_2
1. If (swizzlop_u1 = SWIZZLE), then:
  a. Return $ivswizzlop_(I8 X M, $iswizzle_lane_, v_1, v_2).
2. Assert: Due to validation, (swizzlop_u1 = RELAXED_SWIZZLE).
3. Return $ivswizzlop_(I8 X M, $irelaxed_swizzle_lane_, v_1, v_2).

vshufflop_ I8 X M i* v_1 v_2
1. Return $ivshufflop_(I8 X M, i*, v_1, v_2).

vnarrowop__ Jnn_1 X M_1 Jnn_2 X M_2 sx v_1 v_2
1. Let c_1* be $lanes_(Jnn_1 X M_1, v_1).
2. Let c_2* be $lanes_(Jnn_1 X M_1, v_2).
3. Let c'_1* be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, c_1)*.
4. Let c'_2* be $narrow__($lsize(Jnn_1), $lsize(Jnn_2), sx, c_2)*.
5. Let v be $invlanes_(Jnn_2 X M_2, c'_1* :: c'_2*).
6. Return v.

ivadd_pairwise_ N i*
1. Let [j_1, j_2]* be $concat__1^-1(N, i*).
2. Return $iadd_(N, j_1, j_2)*.

ivextunop__ Jnn_1 X M_1 Jnn_2 X M_2 $f_ sx v_1
1. Let c_1* be $lanes_(Jnn_1 X M_1, v_1).
2. Let c'_1* be $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx, c_1)*.
3. Let c* be $f_($lsizenn2(Jnn_2), c'_1*).
4. Return $invlanes_(Jnn_2 X M_2, c*).

vextunop__ Jnn_1 X M_1 Jnn_2 X M_2 (EXTADD_PAIRWISE sx) v_1
1. Return $ivextunop__(Jnn_1 X M_1, Jnn_2 X M_2, $ivadd_pairwise_, sx, v_1).

ivdot_ N i_1* i_2*
1. Let [j_1, j_2]* be $concat__1^-1(iN(N), $imul_(N, i_1, i_2)*).
2. Return $iadd_(N, j_1, j_2)*.

ivdot_sat_ N i_1* i_2*
1. Let [j_1, j_2]* be $concat__1^-1(iN(N), $imul_(N, i_1, i_2)*).
2. Return $iadd_sat_(N, S, j_1, j_2)*.

ivextbinop__ Jnn_1 X M_1 Jnn_2 X M_2 $f_ sx_1 sx_2 i k v_1 v_2
1. Let c_1* be $lanes_(Jnn_1 X M_1, v_1)[i : k].
2. Let c_2* be $lanes_(Jnn_1 X M_1, v_2)[i : k].
3. Let c'_1* be $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx_1, c_1)*.
4. Let c'_2* be $extend__($lsizenn1(Jnn_1), $lsizenn2(Jnn_2), sx_2, c_2)*.
5. Let c* be $f_($lsizenn2(Jnn_2), c'_1*, c'_2*).
6. Return $invlanes_(Jnn_2 X M_2, c*).

ivmul_ N i_1* i_2*
1. Return $imul_(N, i_1, i_2)*.

vextbinop__ Jnn_1 X M_1 Jnn_2 X M_2 vextbinop_u1 v_1 v_2
1. If vextbinop_u1 is of the case EXTMUL, then:
  a. Let (EXTMUL sx half) be vextbinop_u1.
  b. Let i be $half__(Jnn_1 X M_1, Jnn_2 X M_2, half, 0, M_2).
  c. Return $ivextbinop__(Jnn_1 X M_1, Jnn_2 X M_2, $ivmul_, sx, sx, i, M_2, v_1, v_2).
2. If (vextbinop_u1 = DOTS), then:
  a. Return $ivextbinop__(Jnn_1 X M_1, Jnn_2 X M_2, $ivdot_, S, S, 0, M_1, v_1, v_2).
3. Assert: Due to validation, (vextbinop_u1 = RELAXED_DOTS).
4. Return $ivextbinop__(Jnn_1 X M_1, Jnn_2 X M_2, $ivdot_sat_, S, $relaxed2($R_idot(), sx, S, U), 0, M_1, v_1, v_2).

vextternop__ Jnn_1 X M_1 Jnn_2 X M_2 RELAXED_DOT_ADDS c_1 c_2 c_3
1. Let M be (2 * M_2).
2. Assert: Due to validation, the type of $lsizenn^-1((2 * $lsizenn1(Jnn_1))) is Jnn.
3. Let Jnn be $lsizenn^-1((2 * $lsizenn1(Jnn_1))).
4. Let c' be $vextbinop__(Jnn_1 X M_1, Jnn X M, RELAXED_DOTS, c_1, c_2).
5. Let c'' be $vextunop__(Jnn X M, Jnn_2 X M_2, (EXTADD_PAIRWISE S), c').
6. Let c be an element of $vbinop_(Jnn_2 X M_2, ADD, c'', c_3).
7. Return c.

inst_valtype moduleinst t
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_valtype(t, dt*).

inst_reftype moduleinst rt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_reftype(rt, dt*).

inst_globaltype moduleinst gt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_globaltype(gt, dt*).

inst_tabletype moduleinst tt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_tabletype(tt, dt*).

inst_memtype moduleinst mt
1. Let dt* be moduleinst.TYPES.
2. Return $subst_all_memtype(mt, dt*).

Ki
1. Return 1024.

packfield_ zt_u1 v_u1
1. If the type of zt_u1 is valtype, then:
  a. Let val be v_u1.
  b. Return val.
2. Assert: Due to validation, the type of zt_u1 is packtype.
3. Let packtype be zt_u1.
4. Assert: Due to validation, v_u1 is of the case CONST.
5. Let (numtype_0.CONST i) be v_u1.
6. Assert: Due to validation, (numtype_0 = I32).
7. Return (PACK packtype $wrap__(32, $psize(packtype), i)).

unpackfield_ zt_u1 sx_u1? fv_u1
1. If (the type of zt_u1 is valtype /\ the type of fv_u1 is val), then:
  a. Let val be fv_u1.
  b. If sx_u1? is not defined, then:
    1) Return val.
2. Assert: Due to validation, fv_u1 is of the case PACK.
3. Let (PACK packtype i) be fv_u1.
4. Assert: Due to validation, sx_u1? is defined.
5. Let ?(sx) be sx_u1?.
6. Assert: Due to validation, (zt_u1 = packtype).
7. Return (I32.CONST $extend__($psize(packtype), 32, sx, i)).

funcsxa xa_u1*
1. If (xa_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be xa_u1*.
3. If externaddr_0 is of the case FUNC, then:
  a. Let (FUNC a) be externaddr_0.
  b. Return [a] :: $funcsxa(xa*).
4. Let [externaddr] :: xa* be xa_u1*.
5. Return $funcsxa(xa*).

globalsxa xa_u1*
1. If (xa_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be xa_u1*.
3. If externaddr_0 is of the case GLOBAL, then:
  a. Let (GLOBAL a) be externaddr_0.
  b. Return [a] :: $globalsxa(xa*).
4. Let [externaddr] :: xa* be xa_u1*.
5. Return $globalsxa(xa*).

tablesxa xa_u1*
1. If (xa_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be xa_u1*.
3. If externaddr_0 is of the case TABLE, then:
  a. Let (TABLE a) be externaddr_0.
  b. Return [a] :: $tablesxa(xa*).
4. Let [externaddr] :: xa* be xa_u1*.
5. Return $tablesxa(xa*).

memsxa xa_u1*
1. If (xa_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be xa_u1*.
3. If externaddr_0 is of the case MEM, then:
  a. Let (MEM a) be externaddr_0.
  b. Return [a] :: $memsxa(xa*).
4. Let [externaddr] :: xa* be xa_u1*.
5. Return $memsxa(xa*).

tagsxa xa_u1*
1. If (xa_u1* = []), then:
  a. Return [].
2. Let [externaddr_0] :: xa* be xa_u1*.
3. If externaddr_0 is of the case TAG, then:
  a. Let (TAG a) be externaddr_0.
  b. Return [a] :: $tagsxa(xa*).
4. Let [externaddr] :: xa* be xa_u1*.
5. Return $tagsxa(xa*).

store z
1. Return.

frame z
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return f.

tagaddr z
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return f.MODULE.TAGS.

moduleinst z
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return f.MODULE.

funcinst z
1. Return s.FUNCS.

globalinst z
1. Return s.GLOBALS.

tableinst z
1. Return s.TABLES.

meminst z
1. Return s.MEMS.

taginst z
1. Return s.TAGS.

eleminst z
1. Return s.ELEMS.

datainst z
1. Return s.DATAS.

structinst z
1. Return s.STRUCTS.

arrayinst z
1. Return s.ARRAYS.

exninst z
1. Return s.EXNS.

type z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return f.MODULE.TYPES[x].

func z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return s.FUNCS[f.MODULE.FUNCS[x]].

global z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return s.GLOBALS[f.MODULE.GLOBALS[x]].

table z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return s.TABLES[f.MODULE.TABLES[x]].

mem z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return s.MEMS[f.MODULE.MEMS[x]].

tag z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return s.TAGS[f.MODULE.TAGS[x]].

elem z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return s.ELEMS[f.MODULE.ELEMS[x]].

data z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return s.DATAS[f.MODULE.DATAS[x]].

local z x
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Return f.LOCALS[x].

with_local z x v
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace f.LOCALS[x] with ?(v).

with_global z x v
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace s.GLOBALS[f.MODULE.GLOBALS[x]].VALUE with v.

with_table z x i r
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace s.TABLES[f.MODULE.TABLES[x]].REFS[i] with r.

with_tableinst z x ti
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace s.TABLES[f.MODULE.TABLES[x]] with ti.

with_mem z x i j b*
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace s.MEMS[f.MODULE.MEMS[x]].BYTES[i : j] with b*.

with_meminst z x mi
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace s.MEMS[f.MODULE.MEMS[x]] with mi.

with_elem z x r*
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace s.ELEMS[f.MODULE.ELEMS[x]].REFS with r*.

with_data z x b*
1. Let (FRAME_ _ { f }) be the current FRAME_ context.
2. Replace s.DATAS[f.MODULE.DATAS[x]].BYTES with b*.

with_struct z a i fv
1. Replace s.STRUCTS[a].FIELDS[i] with fv.

with_array z a i fv
1. Replace s.ARRAYS[a].FIELDS[i] with fv.

add_structinst z si*
1. Append si* to the s.STRUCTS.

add_arrayinst z ai*
1. Append ai* to the s.ARRAYS.

add_exninst z exn*
1. Append exn* to the s.EXNS.

growtable tableinst n r
1. Let { TYPE: (at, ([ i .. j ]), rt); REFS: r'*; } be tableinst.
2. If ((|r'*| + n) <= j), then:
  a. Let i' be (|r'*| + n).
  b. Let tableinst' be { TYPE: (at, ([ i' .. j ]), rt); REFS: r'* :: r^n; }.
  c. Return tableinst'.

growmem meminst n
1. Let { TYPE: at ([ i .. j ]) PAGE; BYTES: b*; } be meminst.
2. If (((|b*| / (64 * $Ki())) + n) <= j), then:
  a. Let i' be ((|b*| / (64 * $Ki())) + n).
  b. Let meminst' be { TYPE: at ([ i' .. j ]) PAGE; BYTES: b* :: 0^(n * (64 * $Ki())); }.
  c. Return meminst'.

blocktype_ z bt_u1
1. If bt_u1 is of the case _IDX, then:
  a. Let (_IDX x) be bt_u1.
  b. Assert: Due to validation, $expanddt($type(z, x)) is of the case FUNC.
  c. Let (FUNC ft) be $expanddt($type(z, x)).
  d. Return ft.
2. Assert: Due to validation, bt_u1 is of the case _RESULT.
3. Let (_RESULT t?) be bt_u1.
4. Return [] -> t?.

alloctypes type_u1*
1. If (type_u1* = []), then:
  a. Return [].
2. Let type'* :: [type] be type_u1*.
3. Assert: Due to validation, type is of the case TYPE.
4. Let (TYPE rectype) be type.
5. Let deftype'* be $alloctypes(type'*).
6. Let x be |deftype'*|.
7. Let deftype* be $subst_all_deftypes($rolldt(x, rectype), deftype'*).
8. Return deftype'* :: deftype*.

allocfunc s deftype funccode moduleinst
1. Let funcinst be { TYPE: deftype; MODULE: moduleinst; CODE: funccode; }.
2. Let a be |s.FUNCS|.
3. Append funcinst to the s.FUNCS.
4. Return a.

allocfuncs s dt_u1* funccode_u1* moduleinst_u1*
1. If (dt_u1* = []), then:
  a. Assert: Due to validation, (funccode_u1* = []).
  b. Assert: Due to validation, (moduleinst_u1* = []).
  c. Return [].
2. Else:
  a. Let [dt] :: dt'* be dt_u1*.
  b. Assert: Due to validation, (|funccode_u1*| >= 1).
  c. Let [funccode] :: funccode'* be funccode_u1*.
  d. Assert: Due to validation, (|moduleinst_u1*| >= 1).
  e. Let [moduleinst] :: moduleinst'* be moduleinst_u1*.
  f. Let fa be $allocfunc(s, dt, funccode, moduleinst).
  g. Let fa'* be $allocfuncs(s, dt'*, funccode'*, moduleinst'*).
  h. Return [fa] :: fa'*.

allocglobal s globaltype val
1. Let globalinst be { TYPE: globaltype; VALUE: val; }.
2. Let a be |s.GLOBALS|.
3. Append globalinst to the s.GLOBALS.
4. Return a.

allocglobals s gt_u1* v_u1*
1. If (gt_u1* = []), then:
  a. Assert: Due to validation, (v_u1* = []).
  b. Return [].
2. Else:
  a. Let [globaltype] :: globaltype'* be gt_u1*.
  b. Assert: Due to validation, (|v_u1*| >= 1).
  c. Let [val] :: val'* be v_u1*.
  d. Let ga be $allocglobal(s, globaltype, val).
  e. Let ga'* be $allocglobals(s, globaltype'*, val'*).
  f. Return [ga] :: ga'*.

alloctable s (at, ([ i .. j ]), rt) ref
1. Let tableinst be { TYPE: (at, ([ i .. j ]), rt); REFS: ref^i; }.
2. Let a be |s.TABLES|.
3. Append tableinst to the s.TABLES.
4. Return a.

alloctables s tt_u1* r_u1*
1. If ((tt_u1* = []) /\ (r_u1* = [])), then:
  a. Return [].
2. Assert: Due to validation, (|r_u1*| >= 1).
3. Let [ref] :: ref'* be r_u1*.
4. Assert: Due to validation, (|tt_u1*| >= 1).
5. Let [tabletype] :: tabletype'* be tt_u1*.
6. Let ta be $alloctable(s, tabletype, ref).
7. Let ta'* be $alloctables(s, tabletype'*, ref'*).
8. Return [ta] :: ta'*.

allocmem s at ([ i .. j ]) PAGE
1. Let meminst be { TYPE: at ([ i .. j ]) PAGE; BYTES: 0^(i * (64 * $Ki())); }.
2. Let a be |s.MEMS|.
3. Append meminst to the s.MEMS.
4. Return a.

allocmems s mt_u1*
1. If (mt_u1* = []), then:
  a. Return [].
2. Let [memtype] :: memtype'* be mt_u1*.
3. Let ma be $allocmem(s, memtype).
4. Let ma'* be $allocmems(s, memtype'*).
5. Return [ma] :: ma'*.

alloctag s tagtype
1. Let taginst be { TYPE: tagtype; }.
2. Let a be |s.TAGS|.
3. Append taginst to the s.TAGS.
4. Return a.

alloctags s jt_u1*
1. If (jt_u1* = []), then:
  a. Return [].
2. Let [jt] :: jt'* be jt_u1*.
3. Let ja be $alloctag(s, jt).
4. Let ja'* be $alloctags(s, jt'*).
5. Return [ja] :: ja'*.

allocelem s elemtype ref*
1. Let eleminst be { TYPE: elemtype; REFS: ref*; }.
2. Let a be |s.ELEMS|.
3. Append eleminst to the s.ELEMS.
4. Return a.

allocelems s elemtype_u1* r_u1*
1. If ((elemtype_u1* = []) /\ (r_u1* = [])), then:
  a. Return [].
2. Assert: Due to validation, (|r_u1*| >= 1).
3. Let [ref*] :: ref'** be r_u1*.
4. Assert: Due to validation, (|elemtype_u1*| >= 1).
5. Let [rt] :: rt'* be elemtype_u1*.
6. Let ea be $allocelem(s, rt, ref*).
7. Let ea'* be $allocelems(s, rt'*, ref'**).
8. Return [ea] :: ea'*.

allocdata s OK byte*
1. Let datainst be { BYTES: byte*; }.
2. Let a be |s.DATAS|.
3. Append datainst to the s.DATAS.
4. Return a.

allocdatas s ok_u1* b_u1*
1. If ((ok_u1* = []) /\ (b_u1* = [])), then:
  a. Return [].
2. Assert: Due to validation, (|b_u1*| >= 1).
3. Let [b*] :: b'** be b_u1*.
4. Assert: Due to validation, (|ok_u1*| >= 1).
5. Let [ok] :: ok'* be ok_u1*.
6. Let da be $allocdata(s, ok, b*).
7. Let da'* be $allocdatas(s, ok'*, b'**).
8. Return [da] :: da'*.

allocexport moduleinst (EXPORT name xx_u1)
1. If xx_u1 is of the case FUNC, then:
  a. Let (FUNC x) be xx_u1.
  b. Return { NAME: name; ADDR: (FUNC moduleinst.FUNCS[x]); }.
2. If xx_u1 is of the case GLOBAL, then:
  a. Let (GLOBAL x) be xx_u1.
  b. Return { NAME: name; ADDR: (GLOBAL moduleinst.GLOBALS[x]); }.
3. If xx_u1 is of the case TABLE, then:
  a. Let (TABLE x) be xx_u1.
  b. Return { NAME: name; ADDR: (TABLE moduleinst.TABLES[x]); }.
4. If xx_u1 is of the case MEM, then:
  a. Let (MEM x) be xx_u1.
  b. Return { NAME: name; ADDR: (MEM moduleinst.MEMS[x]); }.
5. Assert: Due to validation, xx_u1 is of the case TAG.
6. Let (TAG x) be xx_u1.
7. Return { NAME: name; ADDR: (TAG moduleinst.TAGS[x]); }.

allocexports moduleinst export*
1. Return $allocexport(moduleinst, export)*.

allocmodule s module externaddr* val_G* ref_T* ref_E**
1. Assert: Due to validation, module is of the case MODULE.
2. Let (MODULE type* import* func* global* table* mem* tag* elem* data* start? export*) be module.
3. Let fa_I* be $funcsxa(externaddr*).
4. Let ga_I* be $globalsxa(externaddr*).
5. Let aa_I* be $tagsxa(externaddr*).
6. Let ma_I* be $memsxa(externaddr*).
7. Let ta_I* be $tablesxa(externaddr*).
8. Let fa* be (|s.FUNCS| + i_F)^(i_F<|func*|).
9. Let ga* be (|s.GLOBALS| + i_G)^(i_G<|global*|).
10. Let ta* be (|s.TABLES| + i_T)^(i_T<|table*|).
11. Let aa* be (|s.TAGS| + i_A)^(i_A<|tag*|).
12. Let ma* be (|s.MEMS| + i_M)^(i_M<|mem*|).
13. Let ea* be (|s.ELEMS| + i_E)^(i_E<|elem*|).
14. Let da* be (|s.DATAS| + i_D)^(i_D<|data*|).
15. Assert: Due to validation, mem is of the case MEMORY*.
16. Let (MEMORY memtype)* be mem*.
17. Let dt* be $alloctypes(type*).
18. Assert: Due to validation, tag is of the case TAG*.
19. Let (TAG y)* be tag*.
20. Assert: Due to validation, data is of the case DATA*.
21. Let (DATA byte* datamode)* be data*.
22. Assert: Due to validation, global is of the case GLOBAL*.
23. Let (GLOBAL globaltype expr_G)* be global*.
24. Assert: Due to validation, table is of the case TABLE*.
25. Let (TABLE tabletype expr_T)* be table*.
26. Assert: Due to validation, elem is of the case ELEM*.
27. Let (ELEM elemtype expr_E* elemmode)* be elem*.
28. Assert: Due to validation, func is of the case FUNC*.
29. Let (FUNC x local* expr_F)* be func*.
30. Let xi* be $allocexports({ TYPES: []; FUNCS: fa_I* :: fa*; GLOBALS: ga_I* :: ga*; TABLES: ta_I* :: ta*; MEMS: ma_I* :: ma*; TAGS: aa_I* :: aa*; ELEMS: []; DATAS: []; EXPORTS: []; }, export*).
31. Let moduleinst be { TYPES: dt*; FUNCS: fa_I* :: fa*; GLOBALS: ga_I* :: ga*; TABLES: ta_I* :: ta*; MEMS: ma_I* :: ma*; TAGS: aa_I* :: aa*; ELEMS: ea*; DATAS: da*; EXPORTS: xi*; }.
32. Let funcaddr_0* be $allocfuncs(s, dt*[x]*, (FUNC x local* expr_F)*, moduleinst^|func*|).
33. Assert: Due to validation, (funcaddr_0* = fa*).
34. Let globaladdr_0* be $allocglobals(s, $subst_all_globaltype(globaltype, dt*)*, val_G*).
35. Assert: Due to validation, (globaladdr_0* = ga*).
36. Let tableaddr_0* be $alloctables(s, $subst_all_tabletype(tabletype, dt*)*, ref_T*).
37. Assert: Due to validation, (tableaddr_0* = ta*).
38. Let memaddr_0* be $allocmems(s, $subst_all_memtype(memtype, dt*)*).
39. Assert: Due to validation, (memaddr_0* = ma*).
40. Let tagaddr_0* be $alloctags(s, dt*[y]*).
41. Assert: Due to validation, (tagaddr_0* = aa*).
42. Let elemaddr_0* be $allocelems(s, $subst_all_reftype(elemtype, dt*)*, ref_E**).
43. Assert: Due to validation, (elemaddr_0* = ea*).
44. Let dataaddr_0* be $allocdatas(s, OK^|data*|, byte**).
45. Assert: Due to validation, (dataaddr_0* = da*).
46. Return moduleinst.

runelem_ x (ELEM rt e^n elemmode_u1)
1. If (elemmode_u1 = PASSIVE), then:
  a. Return [].
2. If (elemmode_u1 = DECLARE), then:
  a. Return [(ELEM.DROP x)].
3. Assert: Due to validation, elemmode_u1 is of the case ACTIVE.
4. Let (ACTIVE y instr*) be elemmode_u1.
5. Return instr* :: [(I32.CONST 0), (I32.CONST n), (TABLE.INIT y x), (ELEM.DROP x)].

rundata_ x (DATA b^n datamode_u1)
1. If (datamode_u1 = PASSIVE), then:
  a. Return [].
2. Assert: Due to validation, datamode_u1 is of the case ACTIVE.
3. Let (ACTIVE y instr*) be datamode_u1.
4. Return instr* :: [(I32.CONST 0), (I32.CONST n), (MEMORY.INIT y x), (DATA.DROP x)].

evalglobals z gt_u1* e_u1*
1. Let (FRAME_ _ { z }) be the current FRAME_ context.
2. If ((gt_u1* = []) /\ (e_u1* = [])), then:
  a. Return [].
3. Assert: Due to validation, (|e_u1*| >= 1).
4. Let [expr] :: expr'* be e_u1*.
5. Assert: Due to validation, (|gt_u1*| >= 1).
6. Let [gt] :: gt'* be gt_u1*.
7. Let f be z.
8. Let [val] be $eval_expr(expr).
9. Let a be $allocglobal(s, gt, val).
10. Append a to the f.MODULE.GLOBALS.
11. Let val'* be $evalglobals(z, gt'*, expr'*).
12. Return [val] :: val'*.

instantiate s module externaddr*
1. Let xt_I* -> xt_E* be $Module_ok(module).
2. Assert: Due to validation, module is of the case MODULE.
3. Let (MODULE type* import* func* global* table* mem* tag* elem* data* start? export*) be module.
4. If not $Externaddr_type(externaddr, xt_I)*, then:
  a. Fail.
5. Let instr_D* be $concat_(instr, $rundata_(i_D, data*[i_D])^(i_D<|data*|)).
6. Let instr_E* be $concat_(instr, $runelem_(i_E, elem*[i_E])^(i_E<|elem*|)).
7. Assert: Due to validation, start is of the case START?.
8. Let (START x)? be start?.
9. Let moduleinst_0 be { TYPES: $alloctypes(type*); FUNCS: $funcsxa(externaddr*) :: (|s.FUNCS| + i_F)^(i_F<|func*|); GLOBALS: $globalsxa(externaddr*); TABLES: []; MEMS: []; TAGS: []; ELEMS: []; DATAS: []; EXPORTS: []; }.
10. Assert: Due to validation, data is of the case DATA*.
11. Assert: Due to validation, table is of the case TABLE*.
12. Let (TABLE tabletype expr_T)* be table*.
13. Assert: Due to validation, global is of the case GLOBAL*.
14. Let (GLOBAL globaltype expr_G)* be global*.
15. Assert: Due to validation, elem is of the case ELEM*.
16. Let (ELEM reftype expr_E* elemmode)* be elem*.
17. Let instr_S? be (CALL x)?.
18. Let z be { LOCALS: []; MODULE: moduleinst_0; }.
19. Push the evaluation context (FRAME_ 0 { z }) to the stack.
20. Let val_G* be $evalglobals(z, globaltype*, expr_G*).
21. Pop the evaluation context (FRAME_ 0 { z' }) from the stack.
22. Push the evaluation context (FRAME_ 0 { z' }) to the stack.
23. Let [ref_T]* be $eval_expr(expr_T)*.
24. Pop the evaluation context (FRAME_ 0 { _f }) from the stack.
25. Push the evaluation context (FRAME_ 0 { z' }) to the stack.
26. Let [ref_E]** be $eval_expr(expr_E)**.
27. Pop the evaluation context (FRAME_ 0 { _f }) from the stack.
28. Let moduleinst be $allocmodule(s, module, externaddr*, val_G*, ref_T*, ref_E**).
29. Let f be { LOCALS: []; MODULE: moduleinst; }.
30. Push the evaluation context (FRAME_ 0 { f }) to the stack.
31. Execute the sequence (instr_E*).
32. Execute the sequence (instr_D*).
33. Execute the sequence (instr_S?).
34. Pop the evaluation context (FRAME_ 0 { f }) from the stack.
35. Return f.MODULE.

invoke s funcaddr val*
1. Assert: Due to validation, $expanddt(s.FUNCS[funcaddr].TYPE) is of the case FUNC.
2. Let (FUNC functype_0) be $expanddt(s.FUNCS[funcaddr].TYPE).
3. Let t_1* -> t_2* be functype_0.
4. Let f be { LOCALS: []; MODULE: { TYPES: []; FUNCS: []; GLOBALS: []; TABLES: []; MEMS: []; TAGS: []; ELEMS: []; DATAS: []; EXPORTS: []; }; }.
5. If not $Val_type(val, t_1)*, then:
  a. Fail.
6. Let k be |t_2*|.
7. Push the evaluation context (FRAME_ k { f }) to the stack.
8. Push the values val* to the stack.
9. Push the value (REF.FUNC_ADDR funcaddr) to the stack.
10. Execute the instruction (CALL_REF s.FUNCS[funcaddr].TYPE).
11. Pop all values val* from the top of the stack.
12. Pop the evaluation context (FRAME_ k { f }) from the stack.
13. Push the values val* to the stack.
14. Pop the values val^k from the stack.
15. Return val^k.

allocXs s X Y X_u1* Y_u1*
1. If (X_u1* = []), then:
  a. Assert: Due to validation, (Y_u1* = []).
  b. Return [].
2. Else:
  a. Let [X] :: X'* be X_u1*.
  b. Assert: Due to validation, (|Y_u1*| >= 1).
  c. Let [Y] :: Y'* be Y_u1*.
  d. Let a be $allocX(s, X, Y, X, Y).
  e. Let a'* be $allocXs(s, X, Y, X'*, Y'*).
  f. Return [a] :: a'*.

var X
1. Return 0.

eval_expr instr*
1. Execute the instruction instr*.
2. Pop the value val from the stack.
3. Return [val].

== Complete.
```
