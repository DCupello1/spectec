;;
;; Lists
;;

;; TODO: enable writing X^n
syntax list(syntax X) = X*  -- if |X*| < $(2^32)


;;
;; Values
;;

;; Integers

syntax byte hint(desc "byte") = 0x00 | ... | 0xFF

syntax uN hint(desc "unsigned integer") hint(show u#%) = nat
syntax sN hint(desc "signed integer") hint(show s#%) = int
syntax iN hint(desc "integer") hint(show i#%) = uN
syntax u31 = uN
syntax u32 = uN
syntax u64 = uN

var b : byte


;; Floating-point

def $signif(N) : nat hint(partial) 
def $signif(32) = 23
def $signif(64) = 52

def $expon(N) : nat hint(partial) 
def $expon(32) = 8
def $expon(64) = 11

def $M(N) : nat hint(show `M)
def $M(N) = $signif(N)

def $E(N) : nat hint(show `E)
def $E(N) = $expon(N)

syntax fN hint(desc "floating-point number") hint(show f#%) = real

syntax f32 = fN
syntax f64 = fN

def $fzero(N) : fN hint(show $(+0))
def $fzero(N) = 0

def $fone(N) : fN  hint(show $(+1))
def $fone(N) = 1

def $canon_(N) : nat
def $canon_(N) = $(2^($signif(N)-1))


;;
;; Names
;;

syntax char hint(desc "character") = U+0000 | ... | U+D7FF | U+E000 | ... | U+10FFFF

def $utf8(char*) : byte*

syntax name hint(desc "name") = char*  -- if |$utf8(char*)| < $(2^32)

var nm : name


;;
;; Indices
;;

syntax idx hint(desc "index") = u32

syntax typeidx hint(desc "type index") = idx
syntax funcidx hint(desc "function index") = idx
syntax globalidx hint(desc "global index") = idx
syntax tableidx hint(desc "table index") = idx
syntax memidx hint(desc "memory index") = idx
syntax labelidx hint(desc "label index") = idx
syntax localidx hint(desc "local index") = idx

var x : idx
var y : idx
var l : labelidx

;; NOTE: We might want to change this as valtype should be based on inn and fnn
;; Types

syntax valtype hint(desc "number type") =
  | INN inn 
  | FNN fnn

syntax inn hint(show I#n) = I32 | I64
syntax fnn hint(show F#n) = F32 | F64

def $optionSize(valtype?) : nat
def $optionSize(valtype) = 1
def $optionSize(eps) = 0

var t : valtype

syntax resulttype hint(desc "result type") =
  valtype?

syntax mut = MUT?

syntax limits hint(desc "limits") =
  `[u32 .. u32]
syntax globaltype hint(desc "global type") =
  mut valtype
syntax functype hint(desc "function type") =
  valtype* -> valtype*
syntax tabletype hint(desc "table type") =
  limits
syntax memtype hint(desc "memory type") =
  limits
syntax externtype hint(desc "external type") =
  | FUNC functype | GLOBAL globaltype | TABLE tabletype | MEM memtype

var lim : limits
var ft : functype
var gt : globaltype
var tt : tabletype
var mt : memtype
var xt : externtype


;; Constants

def $size(valtype) : nat hint(show |%|)

syntax val_(valtype)
syntax val_(INN inn) = iN
syntax val_(FNN fnn) = fN


;; Operators

syntax sx hint(desc "signedness") = U | S

syntax unop_(valtype)
syntax unop_(INN inn) = CLZ | CTZ | POPCNT
syntax unop_(FNN fnn) = ABS | NEG | SQRT | CEIL | FLOOR | TRUNC | NEAREST

syntax binop_(valtype)
syntax binop_(INN inn) =
  | ADD | SUB | MUL | DIV sx hint(show DIV_#%) | REM sx hint(show REM_#%)
  | AND | OR | XOR | SHL | SHR sx hint(show SHR_#%) | ROTL | ROTR
syntax binop_(FNN fnn) =
  | ADD | SUB | MUL | DIV | MIN | MAX | COPYSIGN

syntax testop_(valtype)
syntax testop_(INN inn) = EQZ
syntax testop_(FNN fnn) = |      ;; uninhabited

syntax relop_(valtype)
syntax relop_(INN inn) =
  | EQ | NE \
  | LT sx hint(show LT_#%) | GT sx hint(show GT_#%) \
  | LE sx hint(show LE_#%) | GE sx hint(show GE_#%)
syntax relop_(FNN fnn) =
  | EQ | NE | LT | GT | LE | GE

syntax cvtop = CONVERT | REINTERPRET


syntax memop hint(desc "memory operator") = {ALIGN u32, OFFSET u32}

var mo:memop


;; Instructions

syntax blocktype hint(desc "block type") = valtype?

var bt : blocktype

syntax instr/parametric hint(desc "parametric instruction") =
  | NOP
  | UNREACHABLE
  | DROP
  | SELECT
  | ...

syntax instr/block hint(desc "block instruction") = ...
  | BLOCK blocktype instr*
  | LOOP blocktype instr*
  | IF blocktype instr* ELSE instr*
  | ...

syntax instr/br hint(desc "branch instruction") = ...
  | BR labelidx
  | BR_IF labelidx
  | BR_TABLE labelidx* labelidx
  | ...

syntax instr/call hint(desc "call instruction") = ...
  | CALL funcidx
  | CALL_INDIRECT typeidx
  | RETURN
  | ...

syntax instr/num hint(desc "numeric instruction") = ...
  | CONST valtype val_(valtype)      hint(show %.CONST %)
  | UNOP valtype unop_(valtype)      hint(show %.%)
  | BINOP valtype binop_(valtype)    hint(show %.%)
  | TESTOP valtype testop_(valtype)  hint(show %.%)
  | RELOP valtype relop_(valtype)    hint(show %.%)
  | CVTOP valtype_1 cvtop valtype_2 sx?  hint(show %.%#_#%) hint(show %.%#_#%#_#%)
    -- if valtype_1 =/= valtype_2
  | ...

syntax instr/local hint(desc "local instruction") = ...
  | LOCAL.GET localidx
  | LOCAL.SET localidx
  | LOCAL.TEE localidx
  | ...

syntax instr/global hint(desc "global instruction") = ...
  | GLOBAL.GET globalidx
  | GLOBAL.SET globalidx
  | ...

syntax packsize hint(desc "pack size") = 8 | 16 | 32
syntax ww hint(show w) = packsize

syntax instr/memory hint(desc "memory instruction") = ...
  | LOAD valtype (ww _ sx)? memop  hint(show %.LOAD % %)    hint(show %.LOAD#% % %)
    -- (if valtype = INN inn /\ ww < $size(INN inn))?  ;; TODO: take size implicitly
  | STORE valtype ww? memop        hint(show %.STORE % %)   hint(show %.STORE#% % %)
    -- (if valtype = INN inn /\ ww < $size(INN inn))?  ;; TODO: take size implicitly
  | MEMORY.SIZE
  | MEMORY.GROW

syntax expr hint(desc "expression") =
  instr*

syntax instr hint(desc "instruction")

var in : instr
var e : expr


;; Modules

syntax type hint(desc "type") =
  TYPE functype
syntax local hint(desc "local") =
  LOCAL valtype
syntax func hint(desc "function") =
  FUNC typeidx local* expr
syntax global hint(desc "global") =
  GLOBAL globaltype expr
syntax table hint(desc "table") =
  TABLE tabletype
syntax mem hint(desc "memory") =
  MEMORY memtype
syntax elem hint(desc "table segment") =
  ELEM expr funcidx*
syntax data hint(desc "memory segment") =
  DATA expr byte*
syntax start hint(desc "start function") =
  START funcidx

syntax externidx hint(desc "external index") =
  | FUNC funcidx | GLOBAL globalidx | TABLE tableidx | MEM memidx
syntax export hint(desc "export") =
  EXPORT name externidx
syntax import hint(desc "import") =
  IMPORT name name externtype

syntax module hint(desc "module") =
  MODULE type* import* func* global* table* mem* elem* data* start* export*


var ty : type
var loc : local
var glob : global
var tab : table
var im : import
var ex : export
var st : start
var xx : externidx
