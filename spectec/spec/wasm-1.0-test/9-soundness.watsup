;; Store and Frame 
var S : store
var F : frame

;; Value type ok

relation Val_ok: |- val : valtype

rule Val_ok:
  |- CONST t c_t : t


;; Result type ok

relation Result_ok: |- result : valtype*

rule Result_ok/result:
  |- _VALS v* : t*
  -- (Val_ok: |- v : t)*

rule Result_ok/trap:
  |- TRAP : t*

;; Externvals

relation Externvals_ok: store |- externval : externtype

rule Externvals_ok/func:
  S |- FUNC a : FUNC ext
    -- if S.FUNCS[a] = {TYPE ext, MODULE minst, CODE code_func}

rule Externvals_ok/table:
  S |- TABLE a : TABLE tt
    -- if S.TABLES[a] = {TYPE tt, REFS fa?*}

rule Externvals_ok/mem:
  S |- MEM a : MEM mt
    -- if S.MEMS[a] = {TYPE mt, BYTES b*}
    -- if mt = `[n .. m]
    -- if |b*| = $(n * 64 * $Ki)

rule Externvals_ok/global:
  S |- GLOBAL a : GLOBAL gt
    -- if S.GLOBALS[a] = {TYPE gt, VALUE v}

;; Memory instance 

relation Memory_instance_ok: store |- meminst : memtype

rule Memory_instance_ok:
  S |- {TYPE mt, BYTES b*} : mt
  -- if mt = `[n .. m]
  -- if |b*| = n
  -- Memtype_ok : |- mt : OK

;; Table instance

relation Table_instance_ok: store |- tableinst : tabletype

rule Table_instance_ok:
  S |- {TYPE tt, REFS (fa?)*} : tt
  -- if tt = `[n .. m]
  -- if |(fa?)*| = n
  -- ((Externvals_ok: S |- FUNC fa : FUNC functype)?)*
  -- Tabletype_ok : |- tt : OK

;; Global Instance

relation Global_instance_ok: store |- globalinst : globaltype

rule Global_instance_ok:
  S |- {TYPE gt, VALUE v} : gt
    -- if gt = mut vt
    -- Globaltype_ok: |- gt : OK
    -- Val_ok: |- v : vt

;; Export Instance

relation Export_instance_ok: store |- exportinst : OK

rule Export_instance_ok:
  S |- {NAME name, VALUE eval} : OK
    -- Externvals_ok: S |- eval : ext

;; Module Instance

relation Module_instance_ok: store |- moduleinst : context

rule Module_instance_ok:
  S |- { TYPES functype*, FUNCS funcaddr*, GLOBALS globaladdr*, TABLES tableaddr*, MEMS memaddr*, EXPORTS exportinst* } : {TYPES functype*, FUNCS functype'*, GLOBALS globaltype*, TABLES tabletype*, MEMS memtype*}
    -- (Functype_ok: |- functype : OK)*
    -- (Externvals_ok: S |- FUNC funcaddr : FUNC functype')*
    -- (Externvals_ok: S |- TABLE tableaddr : TABLE tabletype)*
    -- (Externvals_ok: S |- GLOBAL globaladdr : GLOBAL globaltype)*
    -- (Externvals_ok: S |- MEM memaddr : MEM memtype)*
    -- (Export_instance_ok: S |- exportinst : OK)*
    ;; TODO disjoint exportinst.name

;; Function instance

relation Function_instance_ok: store |- funcinst : functype

rule Function_instance_ok:
  S |- { TYPE functype, MODULE moduleinst, CODE func } : functype
  -- Functype_ok: |- functype : OK
  -- Module_instance_ok: S |- moduleinst : C
  -- Func_ok: C |- func : functype

;; Store ok

relation Store_ok: |- store : OK

rule Store_ok:
  |- S : OK
  -- if S = {FUNCS funcinst*, GLOBALS globalinst*, TABLES tableinst*, MEMS meminst*}
  -- (Function_instance_ok: S |- funcinst : functype)*
  -- (Global_instance_ok: S |- globalinst : globaltype)*
  -- (Table_instance_ok: S |- tableinst : tabletype)*
  -- (Memory_instance_ok: S |- meminst : memtype)*

;; Administrative instructions ok

relation Admin_instr_ok: store; context |- admininstr : functype
relation Admin_instrs_ok: store; context |- admininstr* : functype
relation Thread_ok: store ; resulttype |- frame; admininstr* : resulttype


;; Administrative instruction sequences

rule Admin_instrs_ok/empty:
  S; C |- eps : eps -> eps

rule Admin_instrs_ok/seq:
  S; C |- admininstr_1* admininstr_2 : t_1* -> t_3*
  -- Admin_instrs_ok: S; C |- admininstr_1* : t_1* -> t_2*
  -- Admin_instr_ok: S; C |- admininstr_2 : t_2* -> t_3*

rule Admin_instrs_ok/frame:
  S; C |- admininstr* : t* t_1* -> t* t_2*
  -- Admin_instrs_ok: S; C |- admininstr* : t_1* -> t_2*

;; Administrative intructions 

rule Admin_instr_ok/instr:
  S; C |- instr : functype
  -- Instr_ok: C |- instr : functype

rule Admin_instr_ok/trap:
  S; C |- TRAP : t_1* -> t_2*

rule Admin_instr_ok/call_addr:
  S; C |- CALL_ADDR funcaddr : t_1* -> t_2*
  -- Externvals_ok: S |- FUNC funcaddr: FUNC (t_1* -> t_2*)

rule Admin_instr_ok/label:
  S; C |- LABEL_ n `{instr*} admininstr* : eps -> t_2?
  -- Instrs_ok: C |- instr: t_1* -> t_2?
  -- Admin_instrs_ok: S; C |- admininstr: eps -> t_2?

rule Admin_instr_ok/frame:
  S; C |- FRAME_ n `{F} admininstr* : eps -> t?
  -- Thread_ok: S; t? |- F; admininstr*: t?

;; Configuration validity

relation Frame_ok: store |- frame : context

rule Frame_ok:
  S |- { LOCALS val*, MODULE moduleinst } : C, LOCALS t*
  -- Module_instance_ok: S |- moduleinst : C
  -- (Val_ok: |- val : t)*

rule Thread_ok:
  S; rt? |- F; instr* : t?
  -- Frame_ok: S |- F : C
  -- Instrs_ok: C, RETURN rt? |- instr* : eps -> t?

relation Config_ok: |- config : resulttype

rule Config_ok:
  |- (S; F); admininstr* : t?
  -- Store_ok: |- S : OK
  -- Thread_ok: S; eps |- F; admininstr* : t?


